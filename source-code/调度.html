<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>基础 | duangdong的react</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="react相关知识归纳总结">
    <meta name="keywords" content="react,react进阶,react性能优化,react-hooks,react源码">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.27287fd6.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/149.e24c9de5.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/100.27126660.js"><link rel="prefetch" href="/assets/js/101.09cf74ec.js"><link rel="prefetch" href="/assets/js/102.8cd6b4eb.js"><link rel="prefetch" href="/assets/js/103.c4f25168.js"><link rel="prefetch" href="/assets/js/104.4f1b4569.js"><link rel="prefetch" href="/assets/js/105.bc4fc023.js"><link rel="prefetch" href="/assets/js/106.b9d5be0c.js"><link rel="prefetch" href="/assets/js/107.f9a44dd7.js"><link rel="prefetch" href="/assets/js/108.0424a7b7.js"><link rel="prefetch" href="/assets/js/109.086a89ae.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/110.1e4c2c77.js"><link rel="prefetch" href="/assets/js/111.16e80560.js"><link rel="prefetch" href="/assets/js/112.441e61a6.js"><link rel="prefetch" href="/assets/js/113.41a44465.js"><link rel="prefetch" href="/assets/js/114.9efb5469.js"><link rel="prefetch" href="/assets/js/115.d095bf75.js"><link rel="prefetch" href="/assets/js/116.b368a7c1.js"><link rel="prefetch" href="/assets/js/117.3a319a71.js"><link rel="prefetch" href="/assets/js/118.7ea17677.js"><link rel="prefetch" href="/assets/js/119.df1f998f.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/120.935f9aea.js"><link rel="prefetch" href="/assets/js/121.c09de772.js"><link rel="prefetch" href="/assets/js/122.32443376.js"><link rel="prefetch" href="/assets/js/123.d0f8ea63.js"><link rel="prefetch" href="/assets/js/124.fdbcd92d.js"><link rel="prefetch" href="/assets/js/125.0de5eb94.js"><link rel="prefetch" href="/assets/js/126.fb5e629b.js"><link rel="prefetch" href="/assets/js/127.866d8d58.js"><link rel="prefetch" href="/assets/js/128.1aad073e.js"><link rel="prefetch" href="/assets/js/129.328f52fd.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/130.ac9676d9.js"><link rel="prefetch" href="/assets/js/131.9852c015.js"><link rel="prefetch" href="/assets/js/132.806bcfe3.js"><link rel="prefetch" href="/assets/js/133.073ecd1e.js"><link rel="prefetch" href="/assets/js/134.e2683d73.js"><link rel="prefetch" href="/assets/js/135.d16cdb0b.js"><link rel="prefetch" href="/assets/js/136.c3b47da6.js"><link rel="prefetch" href="/assets/js/137.f7fec328.js"><link rel="prefetch" href="/assets/js/138.ec6ab500.js"><link rel="prefetch" href="/assets/js/139.18b97522.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/140.c7df1047.js"><link rel="prefetch" href="/assets/js/141.484c6ca5.js"><link rel="prefetch" href="/assets/js/142.8eff7a66.js"><link rel="prefetch" href="/assets/js/143.60569694.js"><link rel="prefetch" href="/assets/js/144.01883b7c.js"><link rel="prefetch" href="/assets/js/145.a9241012.js"><link rel="prefetch" href="/assets/js/146.4b6f364c.js"><link rel="prefetch" href="/assets/js/147.9ed57153.js"><link rel="prefetch" href="/assets/js/148.e18d806a.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.f1afbc9c.js"><link rel="prefetch" href="/assets/js/24.7f3fc444.js"><link rel="prefetch" href="/assets/js/25.5a945cd4.js"><link rel="prefetch" href="/assets/js/26.7ef56339.js"><link rel="prefetch" href="/assets/js/27.74941107.js"><link rel="prefetch" href="/assets/js/28.20a36928.js"><link rel="prefetch" href="/assets/js/29.7cda6a44.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.97f5cf7e.js"><link rel="prefetch" href="/assets/js/31.eeee5c14.js"><link rel="prefetch" href="/assets/js/32.a2125816.js"><link rel="prefetch" href="/assets/js/33.b3fdf3bc.js"><link rel="prefetch" href="/assets/js/34.908ac5fb.js"><link rel="prefetch" href="/assets/js/35.9459a7c7.js"><link rel="prefetch" href="/assets/js/36.dc8e2582.js"><link rel="prefetch" href="/assets/js/37.27c69606.js"><link rel="prefetch" href="/assets/js/38.10b82911.js"><link rel="prefetch" href="/assets/js/39.fdc5aecb.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.901c96dc.js"><link rel="prefetch" href="/assets/js/41.4cbb9c4b.js"><link rel="prefetch" href="/assets/js/42.da47ce58.js"><link rel="prefetch" href="/assets/js/43.a7669073.js"><link rel="prefetch" href="/assets/js/44.08cc8605.js"><link rel="prefetch" href="/assets/js/45.5461c987.js"><link rel="prefetch" href="/assets/js/46.4c5ed7f9.js"><link rel="prefetch" href="/assets/js/47.450abe13.js"><link rel="prefetch" href="/assets/js/48.d0a778f3.js"><link rel="prefetch" href="/assets/js/49.611d9085.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.2563fd92.js"><link rel="prefetch" href="/assets/js/51.ff64258c.js"><link rel="prefetch" href="/assets/js/52.d47acb9b.js"><link rel="prefetch" href="/assets/js/53.09fd35d1.js"><link rel="prefetch" href="/assets/js/54.5e523072.js"><link rel="prefetch" href="/assets/js/55.8278650d.js"><link rel="prefetch" href="/assets/js/56.425f7e44.js"><link rel="prefetch" href="/assets/js/57.44699db6.js"><link rel="prefetch" href="/assets/js/58.25067fcf.js"><link rel="prefetch" href="/assets/js/59.3814ee9e.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/60.82621500.js"><link rel="prefetch" href="/assets/js/61.9880375b.js"><link rel="prefetch" href="/assets/js/62.3924c2b9.js"><link rel="prefetch" href="/assets/js/63.ff3650b8.js"><link rel="prefetch" href="/assets/js/64.0d46b236.js"><link rel="prefetch" href="/assets/js/65.f255f222.js"><link rel="prefetch" href="/assets/js/66.d797120d.js"><link rel="prefetch" href="/assets/js/67.aa46c62c.js"><link rel="prefetch" href="/assets/js/68.0dbf39cf.js"><link rel="prefetch" href="/assets/js/69.116b53df.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/70.a05986f2.js"><link rel="prefetch" href="/assets/js/71.562a4365.js"><link rel="prefetch" href="/assets/js/72.c10c6194.js"><link rel="prefetch" href="/assets/js/73.d85c71e5.js"><link rel="prefetch" href="/assets/js/74.73f72e00.js"><link rel="prefetch" href="/assets/js/75.62c76a28.js"><link rel="prefetch" href="/assets/js/76.8d0d9036.js"><link rel="prefetch" href="/assets/js/77.4ede6642.js"><link rel="prefetch" href="/assets/js/78.7d4d4152.js"><link rel="prefetch" href="/assets/js/79.720e767d.js"><link rel="prefetch" href="/assets/js/80.e9d86233.js"><link rel="prefetch" href="/assets/js/81.40ea5e9f.js"><link rel="prefetch" href="/assets/js/82.78074ee1.js"><link rel="prefetch" href="/assets/js/83.72133cbf.js"><link rel="prefetch" href="/assets/js/84.52c5ea65.js"><link rel="prefetch" href="/assets/js/85.afce36a7.js"><link rel="prefetch" href="/assets/js/86.bdc638dd.js"><link rel="prefetch" href="/assets/js/87.11e34480.js"><link rel="prefetch" href="/assets/js/88.5fd9f0ef.js"><link rel="prefetch" href="/assets/js/89.718ec134.js"><link rel="prefetch" href="/assets/js/90.11f956de.js"><link rel="prefetch" href="/assets/js/91.985d80f2.js"><link rel="prefetch" href="/assets/js/92.9c876df3.js"><link rel="prefetch" href="/assets/js/93.da92c068.js"><link rel="prefetch" href="/assets/js/94.cf4ee959.js"><link rel="prefetch" href="/assets/js/95.665f55e6.js"><link rel="prefetch" href="/assets/js/96.2e80356d.js"><link rel="prefetch" href="/assets/js/97.d7d8ba2d.js"><link rel="prefetch" href="/assets/js/98.70eab878.js"><link rel="prefetch" href="/assets/js/99.60ddb42d.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的react</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/events/" class="nav-link">
  事件机制
</a></div><div class="nav-item"><a href="/fiber/" class="nav-link">
  Fiber
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  进阶
</a></div><div class="nav-item"><a href="/hooks/" class="nav-link">
  Hooks
</a></div><div class="nav-item"><a href="/source-code/" class="nav-link router-link-active">
  源码解读
</a></div><div class="nav-item"><a href="/performance/" class="nav-link">
  性能优化
</a></div><div class="nav-item"><a href="/base/" class="nav-link">
  基础
</a></div><div class="nav-item"><a href="/jest/" class="nav-link">
  单元测试
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/events/" class="nav-link">
  事件机制
</a></div><div class="nav-item"><a href="/fiber/" class="nav-link">
  Fiber
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  进阶
</a></div><div class="nav-item"><a href="/hooks/" class="nav-link">
  Hooks
</a></div><div class="nav-item"><a href="/source-code/" class="nav-link router-link-active">
  源码解读
</a></div><div class="nav-item"><a href="/performance/" class="nav-link">
  性能优化
</a></div><div class="nav-item"><a href="/base/" class="nav-link">
  基础
</a></div><div class="nav-item"><a href="/jest/" class="nav-link">
  单元测试
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/source-code/" aria-current="page" class="sidebar-link">章节列表</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实现-concurrent</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实现-diff</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实现-hooks</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实现-状态更新</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>架构-commit阶段</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>架构-render阶段</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>理念-react理念</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>理念-源码结构</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/source-code/生命周期.html" class="sidebar-link">生命周期</a></li><li><a href="/source-code/调度.html" class="active sidebar-link">基础</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h1> <h2 id="react-api"><a href="#react-api" class="header-anchor">#</a> React API</h2> <blockquote><p>虽然平时我们都喜欢说我们用<code>React</code>作为我们的核心框架，但其实大部分人都不知道<code>React</code>到底是个什么东东。事实上自从Facebook把<code>React</code>和<code>ReactDOM</code>分包发布之后，<code>React</code>就不仅仅是一开始的前端框架了，如果在15版本之后去看一下<code>react</code>和<code>react-dom</code>的源码大小，你就会发现，<code>react</code>仅仅1000多行代码，而<code>react-dom</code>却将近2w行。是的你没看错，而且你很可能也没有想错，其实大部分的框架逻辑都在<code>react-dom</code>当中，那么<code>react</code>到底是个什么东东呢？</p></blockquote> <p>关于版本，本书是在React16+的基础上写的，React16相较于之前的版本是核心上的一次重写，虽然主要的API都没有变化，但是增加了很多能力。并且首次引入了<code>Fiber</code>的概念，之后新的功能都是围绕<code>Fiber</code>进行实现，比如<code>AsyncMode</code>，<code>Profiler</code>等。</p> <p>这里并不会讲16版本之前的实现，一是面向未来，二是之前版本的源码我也没看过。</p> <p>我们来看一下React暴露出来的API</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> React <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">Children</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    map<span class="token punctuation">,</span>
    forEach<span class="token punctuation">,</span>
    count<span class="token punctuation">,</span>
    toArray<span class="token punctuation">,</span>
    only<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  createRef<span class="token punctuation">,</span>
  Component<span class="token punctuation">,</span>
  PureComponent<span class="token punctuation">,</span>

  createContext<span class="token punctuation">,</span>
  forwardRef<span class="token punctuation">,</span>

  <span class="token literal-property property">Fragment</span><span class="token operator">:</span> <span class="token constant">REACT_FRAGMENT_TYPE</span><span class="token punctuation">,</span>
  <span class="token literal-property property">StrictMode</span><span class="token operator">:</span> <span class="token constant">REACT_STRICT_MODE_TYPE</span><span class="token punctuation">,</span>
  <span class="token literal-property property">unstable_AsyncMode</span><span class="token operator">:</span> <span class="token constant">REACT_ASYNC_MODE_TYPE</span><span class="token punctuation">,</span>
  <span class="token literal-property property">unstable_Profiler</span><span class="token operator">:</span> <span class="token constant">REACT_PROFILER_TYPE</span><span class="token punctuation">,</span>

  <span class="token literal-property property">createElement</span><span class="token operator">:</span> __DEV__ <span class="token operator">?</span> createElementWithValidation <span class="token operator">:</span> createElement<span class="token punctuation">,</span>
  <span class="token literal-property property">cloneElement</span><span class="token operator">:</span> __DEV__ <span class="token operator">?</span> cloneElementWithValidation <span class="token operator">:</span> cloneElement<span class="token punctuation">,</span>
  <span class="token literal-property property">createFactory</span><span class="token operator">:</span> __DEV__ <span class="token operator">?</span> createFactoryWithValidation <span class="token operator">:</span> createFactory<span class="token punctuation">,</span>
  <span class="token literal-property property">isValidElement</span><span class="token operator">:</span> isValidElement<span class="token punctuation">,</span>

  <span class="token literal-property property">version</span><span class="token operator">:</span> ReactVersion<span class="token punctuation">,</span>

  <span class="token literal-property property">__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</span><span class="token operator">:</span> ReactSharedInternals<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>请先无视<code>__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</code></p> <h3 id="children"><a href="#children" class="header-anchor">#</a> Children</h3> <p>这个对象提供了一堆帮你处理<code>props.children</code>的方法，因为<code>children</code>是一个类似数组但是不是数组的数据结构，如果你要对其进行处理可以用<code>React.Children</code>外挂的方法。</p> <h3 id="createref"><a href="#createref" class="header-anchor">#</a> createRef</h3> <p>新的<code>ref</code>用法，React即将抛弃``这种<code>string ref</code>的用法，将来你只能使用两种方式来使用<code>ref</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token comment">// or</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>funRef <span class="token operator">=</span> node<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h3 id="component-purecomponent"><a href="#component-purecomponent" class="header-anchor">#</a> Component &amp; PureComponent</h3> <p>这两个类基本相同，唯一的区别是<code>PureComponent</code>的原型上多了一个标识</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>ctor<span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> ctor<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isPureReactComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldProps<span class="token punctuation">,</span> newProps<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是检查组件是否需要更新的一个判断，<code>ctor</code>就是你声明的继承自<code>Component or PureComponent</code>的类，他会判断你是否继承自<code>PureComponent</code>，如果是的话就<code>shallowEqual</code>比较<code>state</code>和<code>props</code>。</p> <p>顺便说一下：<strong>React中对比一个ClassComponent是否需要更新，只有两个地方。一是看有没有<code>shouldComponentUpdate</code>方法，二就是这里的<code>PureComponent</code>判断</strong></p> <h3 id="createcontext"><a href="#createcontext" class="header-anchor">#</a> createContext</h3> <p><code>createContext</code>是官方定稿的<code>context</code>方案，在这之前我们一直在用的老的<code>context API</code>都是React不推荐的API，现在新的API释出，官方也已经确定在17大版本会把老<code>API</code>去除。</p> <p>新API的使用方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> Provider<span class="token punctuation">,</span> Consumer <span class="token punctuation">}</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">'defaultValue'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">ProviderComp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>Provider value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'realValue'</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
    <span class="token punctuation">{</span>props<span class="token punctuation">.</span>children<span class="token punctuation">}</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>Provider<span class="token operator">&gt;</span>
<span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">ConsumerComp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>Consumer<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span><span class="token punctuation">}</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>Consumber<span class="token operator">&gt;</span>
<span class="token punctuation">)</span>
</code></pre></div><p>后面讲<code>context</code>会专门比较新老的API的差异，提前说一句，老API的性能不是一般的差</p> <h3 id="forwardref"><a href="#forwardref" class="header-anchor">#</a> forwardRef</h3> <p><code>forwardRef</code>是用来解决HOC组件传递<code>ref</code>的问题的，所谓HOC就是<code>Higher Order Component</code>，比如使用<code>redux</code>的时候，我们用<code>connect</code>来给组件绑定需要的state，这其中其实就是给我们的组件在外部包了一层组件，然后通过<code>...props</code>的方式把外部的<code>props</code>传入到实际组件。<code>forwardRef</code>的使用方法如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> TargetComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>TargetComponent ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>这也是为什么要提供<code>createRef</code>作为新的<code>ref</code>使用方法的原因，如果用<code>string ref</code>就没法当作参数传递了。</p> <p>这里只是简单说一下使用方法，后面讲<code>ref</code>的时候会详细分析。</p> <h3 id="类型"><a href="#类型" class="header-anchor">#</a> 类型</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">Fragment</span><span class="token operator">:</span> <span class="token constant">REACT_FRAGMENT_TYPE</span><span class="token punctuation">,</span>
<span class="token literal-property property">StrictMode</span><span class="token operator">:</span> <span class="token constant">REACT_STRICT_MODE_TYPE</span><span class="token punctuation">,</span>
<span class="token literal-property property">unstable_AsyncMode</span><span class="token operator">:</span> <span class="token constant">REACT_ASYNC_MODE_TYPE</span><span class="token punctuation">,</span>
<span class="token literal-property property">unstable_Profiler</span><span class="token operator">:</span> <span class="token constant">REACT_PROFILER_TYPE</span><span class="token punctuation">,</span>
</code></pre></div><p>这四个都是React提供的<em>组件</em>，但他们呢其实都只是占位符，都是一个<code>Symbol</code>，在React实际检测到他们的时候会做一些特殊的处理，比如<code>StrictMode</code>和<code>AsyncMode</code>会让他们的子节点对应的Fiber的<code>mode</code>都变成和他们一样的<code>mode</code></p> <h3 id="createelement-cloneelement-createfactory-isvalidelement"><a href="#createelement-cloneelement-createfactory-isvalidelement" class="header-anchor">#</a> createElement &amp; cloneElement &amp; createFactory &amp; isValidElement</h3> <p><code>createElement</code>可谓是React中最重要的API了，他是用来创建<code>ReactElement</code>的，但是很多同学却从没见过也没用过，这是为啥呢？因为你用了JSX，JSX并不是标准的js，所以要经过编译才能变成可运行的js，而编译之后，<code>createElement</code>就出现了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// jsx</span>
<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>content<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token comment">// js</span>
React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'app'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'content'</span><span class="token punctuation">)</span>
</code></pre></div><p><code>cloneElement</code>就很明显了，是用来克隆一个<code>ReactElement</code>的</p> <p><code>createFactory</code>是用来创建专门用来创建某一类<code>ReactElement</code>的工厂的，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createFactory</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> factory <span class="token operator">=</span> <span class="token function">createElement</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  factory<span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
  <span class="token keyword">return</span> factory<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>他其实就是绑定了第一个参数的<code>createElement</code>，一般我们用JSX进行编程的时候不会用到这个API</p> <p><code>isValidElement</code>顾名思义就是用来验证是否是一个<code>ReactElement</code>的，基本也用不太到</p> <h2 id="reactelement"><a href="#reactelement" class="header-anchor">#</a> ReactElement</h2> <p><code>ReactElement</code>通过<code>createElement</code>创建，调用该方法需要传入三个参数：</p> <ul><li>type</li> <li>config</li> <li>children</li></ul> <p><code>type</code>指代这个<code>ReactElement</code>的类型</p> <ul><li>字符串比如<code>div</code>，<code>p</code>代表原生DOM，称为<code>HostComponent</code></li> <li>Class类型是我们继承自<code>Component</code>或者<code>PureComponent</code>的组件，称为<code>ClassComponent</code></li> <li>方法就是<code>functional Component</code></li> <li>原生提供的<code>Fragment</code>、<code>AsyncMode</code>等是Symbol，会被特殊处理</li> <li>TODO: 是否有其他的</li></ul> <p>从源码可以看出虽然创建的时候都是通过<code>config</code>传入的，但是<code>key</code>和<code>ref</code>不会跟其他<code>config</code>中的变量一起被处理，而是单独作为变量出现在<code>ReactElement</code>上。</p> <p>在最后创建<code>ReactElement</code>我们看到了这么一个变量<code>$$typeof</code>，这是个啥呢，在这里可以看出来他是一个常量：<code>REACT_ELEMENT_TYPE</code>，但有一个特例：<code>ReactDOM.createPortal</code>的时候是<code>REACT_PORTAL_TYPE</code>，不过他不是通过<code>createElement</code>创建的，所以他应该也不属于<code>ReactElement</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> config<span class="token punctuation">,</span> children</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 处理参数</span>

  <span class="token keyword">return</span> <span class="token function">ReactElement</span><span class="token punctuation">(</span>
    type<span class="token punctuation">,</span>
    key<span class="token punctuation">,</span>
    ref<span class="token punctuation">,</span>
    self<span class="token punctuation">,</span>
    source<span class="token punctuation">,</span>
    ReactCurrentOwner<span class="token punctuation">.</span>current<span class="token punctuation">,</span>
    props<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">ReactElement</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> key<span class="token punctuation">,</span> ref<span class="token punctuation">,</span> self<span class="token punctuation">,</span> source<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// This tag allows us to uniquely identify this as a React Element</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_ELEMENT_TYPE</span><span class="token punctuation">,</span>

    <span class="token comment">// Built-in properties that belong on the element</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> type<span class="token punctuation">,</span>
    <span class="token literal-property property">key</span><span class="token operator">:</span> key<span class="token punctuation">,</span>
    <span class="token literal-property property">ref</span><span class="token operator">:</span> ref<span class="token punctuation">,</span>
    <span class="token literal-property property">props</span><span class="token operator">:</span> props<span class="token punctuation">,</span>

    <span class="token comment">// Record the component responsible for creating this element.</span>
    <span class="token literal-property property">_owner</span><span class="token operator">:</span> owner<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> element
<span class="token punctuation">}</span>
</code></pre></div><p><code>ReactElement</code>只是一个用来承载信息的容器，他会告诉后续的操作这个节点的以下信息：</p> <ol><li><code>type</code>类型，用于判断如何创建节点</li> <li><code>key</code>和<code>ref</code>这些特殊信息</li> <li><code>props</code>新的属性内容</li> <li><code>$$typeof</code>用于确定是否属于<code>ReactElement</code></li></ol> <p>这些信息对于后期构建应用的树结构是非常重要的，<strong>而React通过提供这种类型的数据，来脱离平台的限制</strong></p> <h2 id="react-children"><a href="#react-children" class="header-anchor">#</a> React Children</h2> <blockquote><p>最开始<code>React.Children</code>这个 API 是不想讲的，一方面平时不怎么用，另一方面跟数组处理功能差不多，不深究实现是比较容易理解的。但是后来实际去看了一下源码之后发现，他的实现方式还是非常有趣的，尤其是<code>map</code>和<code>forEach</code>，我们就按照<code>map</code>的流程来看一下，<code>forEach</code>其实差不多，只是没有返回新的节点。</p></blockquote> <p>先来看一下流程图：</p> <p><img src="https://pozvqg.dm.files.1drv.com/y4mmeXuR-FkgNj-8c2xEInueibhFoYSEdG7un9nWggJFV1nYGsjb6S8m0D776nWAyuXHwKz1kCVMelh96STs4RYe9EVppRjlQyiu7jwrPqH9iM-cR4YPS7UbJkFTZHg62yMg6k8n_c-DMQOoEzZhvmCdR8LAEPFY4JQvypWYj3LF1EpeR5zp6OIfkPOk3qei4Qwz903Q9lxtWpavsva6TceyQ?width=768&amp;height=1152&amp;cropmode=none" alt="map流程"></p> <p>当然这么看肯定云里雾里，接下去会对各个函数进行讲解，然后再回过头来配合图片观看更好理解。</p> <h3 id="开始"><a href="#开始" class="header-anchor">#</a> 开始</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mapChildren</span><span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span> func<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>children <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> children
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token function">mapIntoWithKeyPrefixInternal</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> result<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> func<span class="token punctuation">,</span> context<span class="token punctuation">)</span>
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">mapIntoWithKeyPrefixInternal</span><span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span> array<span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> func<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> escapedPrefix <span class="token operator">=</span> <span class="token string">''</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prefix <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    escapedPrefix <span class="token operator">=</span> <span class="token function">escapeUserProvidedKey</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'/'</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> traverseContext <span class="token operator">=</span> <span class="token function">getPooledTraverseContext</span><span class="token punctuation">(</span>
    array<span class="token punctuation">,</span>
    escapedPrefix<span class="token punctuation">,</span>
    func<span class="token punctuation">,</span>
    context<span class="token punctuation">,</span>
  <span class="token punctuation">)</span>
  <span class="token function">traverseAllChildren</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> mapSingleChildIntoContext<span class="token punctuation">,</span> traverseContext<span class="token punctuation">)</span>
  <span class="token function">releaseTraverseContext</span><span class="token punctuation">(</span>traverseContext<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>map</code>和<code>forEach</code>的最大区别就是有没有<code>return result</code>。</p> <p><code>getPooledTraverseContext</code>就是从<code>pool</code>里面找一个对象，<code>releaseTraverseContext</code>会把当前的<code>context</code>对象清空然后放回到<code>pool</code>中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">POOL_SIZE</span> <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">const</span> traverseContextPool <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">function</span> <span class="token function">getPooledTraverseContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// args</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>traverseContextPool<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> traverseContext <span class="token operator">=</span> traverseContextPool<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// set attrs</span>
    <span class="token keyword">return</span> traverseContext
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token comment">/* attrs */</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">releaseTraverseContext</span><span class="token punctuation">(</span><span class="token parameter">traverseContext</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// clear attrs</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>traverseContextPool<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token constant">POOL_SIZE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    traverseContextPool<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>traverseContext<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么按照这个流程来看，是不是<code>pool</code>永远都只有一个值呢，毕竟推出之后操作完了就推入了，这么循环着。答案肯定是否的，这就要讲到<code>React.Children.map</code>的一个特性了，那就是对每个节点的<code>map</code>返回的如果是数组，那么还会继续展开，这是一个递归的过程。接下去我们就来看看。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">traverseAllChildren</span><span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> traverseContext</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>children <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token function">traverseAllChildrenImpl</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> traverseContext<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">traverseAllChildrenImpl</span><span class="token punctuation">(</span>
  <span class="token parameter">children<span class="token punctuation">,</span>
  nameSoFar<span class="token punctuation">,</span>
  callback<span class="token punctuation">,</span>
  traverseContext<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> type <span class="token operator">=</span> <span class="token keyword">typeof</span> children

  <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">'undefined'</span> <span class="token operator">||</span> type <span class="token operator">===</span> <span class="token string">'boolean'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    children <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> invokeCallback <span class="token operator">=</span> <span class="token boolean">false</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>children <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    invokeCallback <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'string'</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">'number'</span><span class="token operator">:</span>
        invokeCallback <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'object'</span><span class="token operator">:</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>children<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">case</span> <span class="token constant">REACT_ELEMENT_TYPE</span><span class="token operator">:</span>
          <span class="token keyword">case</span> <span class="token constant">REACT_PORTAL_TYPE</span><span class="token operator">:</span>
            invokeCallback <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>invokeCallback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">callback</span><span class="token punctuation">(</span>
      traverseContext<span class="token punctuation">,</span>
      children<span class="token punctuation">,</span>
      nameSoFar <span class="token operator">===</span> <span class="token string">''</span> <span class="token operator">?</span> <span class="token constant">SEPARATOR</span> <span class="token operator">+</span> <span class="token function">getComponentKey</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> nameSoFar<span class="token punctuation">,</span>
    <span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> child
  <span class="token keyword">let</span> nextName
  <span class="token keyword">let</span> subtreeCount <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// Count of children found in the current subtree.</span>
  <span class="token keyword">const</span> nextNamePrefix <span class="token operator">=</span> nameSoFar <span class="token operator">===</span> <span class="token string">''</span> <span class="token operator">?</span> <span class="token constant">SEPARATOR</span> <span class="token operator">:</span> nameSoFar <span class="token operator">+</span> <span class="token constant">SUBSEPARATOR</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      child <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
      nextName <span class="token operator">=</span> nextNamePrefix <span class="token operator">+</span> <span class="token function">getComponentKey</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
      subtreeCount <span class="token operator">+=</span> <span class="token function">traverseAllChildrenImpl</span><span class="token punctuation">(</span>
        child<span class="token punctuation">,</span>
        nextName<span class="token punctuation">,</span>
        callback<span class="token punctuation">,</span>
        traverseContext<span class="token punctuation">,</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> iteratorFn <span class="token operator">=</span> <span class="token function">getIteratorFn</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> iteratorFn <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// iterator，和array差不多</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 提醒不正确的children类型</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> subtreeCount
<span class="token punctuation">}</span>
</code></pre></div><p>这里就是一层递归了，对于可循环的<code>children</code>，都会重复调用<code>traverseAllChildrenImpl</code>，直到是一个节点的情况，然后调用<code>callback</code>，也就是<code>mapSingleChildIntoContext</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mapSingleChildIntoContext</span><span class="token punctuation">(</span><span class="token parameter">bookKeeping<span class="token punctuation">,</span> child<span class="token punctuation">,</span> childKey</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> result<span class="token punctuation">,</span> keyPrefix<span class="token punctuation">,</span> func<span class="token punctuation">,</span> context <span class="token punctuation">}</span> <span class="token operator">=</span> bookKeeping

  <span class="token keyword">let</span> mappedChild <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> child<span class="token punctuation">,</span> bookKeeping<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>mappedChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mapIntoWithKeyPrefixInternal</span><span class="token punctuation">(</span>mappedChild<span class="token punctuation">,</span> result<span class="token punctuation">,</span> childKey<span class="token punctuation">,</span> <span class="token parameter">c</span> <span class="token operator">=&gt;</span> c<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mappedChild <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValidElement</span><span class="token punctuation">(</span>mappedChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      mappedChild <span class="token operator">=</span> <span class="token function">cloneAndReplaceKey</span><span class="token punctuation">(</span>
        mappedChild<span class="token punctuation">,</span>
        keyPrefix <span class="token operator">+</span>
          <span class="token punctuation">(</span>mappedChild<span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>child <span class="token operator">||</span> child<span class="token punctuation">.</span>key <span class="token operator">!==</span> mappedChild<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
            <span class="token operator">?</span> <span class="token function">escapeUserProvidedKey</span><span class="token punctuation">(</span>mappedChild<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'/'</span>
            <span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token operator">+</span>
          childKey<span class="token punctuation">,</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mappedChild<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>mapSingleChildIntoContext</code>这个方法其实就是调用<code>React.Children.map(children, callback)</code>这里的<code>callback</code>，就是我们传入的第二个参数，并得到<code>map</code>之后的结果。注意重点来了，<strong>如果<code>map</code>之后的节点还是一个数组，那么再次进入<code>mapIntoWithKeyPrefixInternal</code>，那么这个时候我们就会再次从<code>pool</code>里面去<code>context</code>了，而<code>pool</code>的意义大概也就是在这里了，如果循环嵌套多了，可以减少很多对象创建和<code>gc</code>的损耗。</strong></p> <p>而如果不是数组并且是一个合规的<code>ReactElement</code>，就触达顶点了，替换一下<code>key</code>就推入<code>result</code>了。</p> <p>React 这么实现主要是两个目的：</p> <ol><li>拆分<code>map</code>出来的数组</li> <li>因为对<code>Children</code>的处理一般在<code>render</code>里面，所以会比较频繁，所以设置一个<code>pool</code>减少声明和<code>gc</code>的开销</li></ol> <p>这就是<code>Children.map</code>的实现，虽然不算什么特别神奇的代码，但是阅读一下还是挺有意思的。</p> <h2 id="react-中的数据结构"><a href="#react-中的数据结构" class="header-anchor">#</a> React 中的数据结构</h2> <blockquote><p>本文中使用 gist 进行展示，可能会被 Adblock 屏蔽，如果发现无法看到 gist 的内容请尝试刷新，如果还不行可以<a href="mailto:jokcy@hotmail.com">反馈给我</a></p></blockquote> <h3 id="fiberroot"><a href="#fiberroot" class="header-anchor">#</a> FiberRoot</h3> <div class="language-js extra-class"><pre class="language-js"><code>type BaseFiberRootProperties <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">|</span>
  <span class="token comment">// root节点，render方法接收的第二个参数</span>
  <span class="token literal-property property">containerInfo</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token comment">// 只有在持久更新中会用到，也就是不支持增量更新的平台，react-dom不会用到</span>
  <span class="token literal-property property">pendingChildren</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token comment">// 当前应用对应的Fiber对象，是Root Fiber</span>
  <span class="token literal-property property">current</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>

  <span class="token comment">// 一下的优先级是用来区分</span>
  <span class="token comment">// 1) 没有提交(committed)的任务</span>
  <span class="token comment">// 2) 没有提交的挂起任务</span>
  <span class="token comment">// 3) 没有提交的可能被挂起的任务</span>
  <span class="token comment">// 我们选择不追踪每个单独的阻塞登记，为了兼顾性能</span>
  <span class="token comment">// The earliest and latest priority levels that are suspended from committing.</span>
  <span class="token comment">// 最老和新的在提交的时候被挂起的任务</span>
  <span class="token literal-property property">earliestSuspendedTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>
  <span class="token literal-property property">latestSuspendedTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>
  <span class="token comment">// The earliest and latest priority levels that are not known to be suspended.</span>
  <span class="token comment">// 最老和最新的不确定是否会挂起的优先级（所有任务进来一开始都是这个状态）</span>
  <span class="token literal-property property">earliestPendingTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>
  <span class="token literal-property property">latestPendingTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>
  <span class="token comment">// The latest priority level that was pinged by a resolved promise and can</span>
  <span class="token comment">// be retried.</span>
  <span class="token comment">// 最新的通过一个promise被reslove并且可以重新尝试的优先级</span>
  <span class="token literal-property property">latestPingedTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>

  <span class="token comment">// 如果有错误被抛出并且没有更多的更新存在，我们尝试在处理错误前同步重新从头渲染</span>
  <span class="token comment">// 在`renderRoot`出现无法处理的错误时会被设置为`true`</span>
  <span class="token literal-property property">didError</span><span class="token operator">:</span> boolean<span class="token punctuation">,</span>

  <span class="token comment">// 正在等待提交的任务的`expirationTime`</span>
  <span class="token literal-property property">pendingCommitExpirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>
  <span class="token comment">// 已经完成的任务的FiberRoot对象，如果你只有一个Root，那他永远只可能是这个Root对应的Fiber，或者是null</span>
  <span class="token comment">// 在commit阶段只会处理这个值对应的任务</span>
  <span class="token literal-property property">finishedWork</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 在任务被挂起的时候通过setTimeout设置的返回内容，用来下一次如果有新的任务挂起时清理还没触发的timeout</span>
  <span class="token literal-property property">timeoutHandle</span><span class="token operator">:</span> TimeoutHandle <span class="token operator">|</span> NoTimeout<span class="token punctuation">,</span>
  <span class="token comment">// 顶层context对象，只有主动调用`renderSubtreeIntoContainer`时才会有用</span>
  <span class="token literal-property property">context</span><span class="token operator">:</span> Object <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">pendingContext</span><span class="token operator">:</span> Object <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 用来确定第一次渲染的时候是否需要融合</span>
  <span class="token operator">+</span>hydrate<span class="token operator">:</span> boolean<span class="token punctuation">,</span>
  <span class="token comment">// 当前root上剩余的过期时间</span>
  <span class="token comment">// TODO: 提到renderer里面区处理</span>
  <span class="token literal-property property">nextExpirationTimeToWorkOn</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>
  <span class="token comment">// 当前更新对应的过期时间</span>
  <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>
  <span class="token comment">// List of top-level batches. This list indicates whether a commit should be</span>
  <span class="token comment">// deferred. Also contains completion callbacks.</span>
  <span class="token comment">// TODO: Lift this into the renderer</span>
  <span class="token comment">// 顶层批次（批处理任务？）这个变量指明一个commit是否应该被推迟</span>
  <span class="token comment">// 同时包括完成之后的回调</span>
  <span class="token comment">// 貌似用在测试的时候？</span>
  <span class="token literal-property property">firstBatch</span><span class="token operator">:</span> Batch <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// root之间关联的链表结构</span>
  <span class="token literal-property property">nextScheduledRoot</span><span class="token operator">:</span> FiberRoot <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token operator">|</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="fiber"><a href="#fiber" class="header-anchor">#</a> Fiber</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Fiber对应一个组件需要被处理或者已经处理了，一个组件可以有一个或者多个Fiber</span>
type Fiber <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">|</span>
  <span class="token comment">// 标记不同的组件类型</span>
  <span class="token literal-property property">tag</span><span class="token operator">:</span> WorkTag<span class="token punctuation">,</span>

  <span class="token comment">// ReactElement里面的key</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> string<span class="token punctuation">,</span>

  <span class="token comment">// ReactElement.type，也就是我们调用`createElement`的第一个参数</span>
  <span class="token literal-property property">elementType</span><span class="token operator">:</span> any<span class="token punctuation">,</span>

  <span class="token comment">// The resolved function/class/ associated with this fiber.</span>
  <span class="token comment">// 异步组件resolved之后返回的内容，一般是`function`或者`class`</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> any<span class="token punctuation">,</span>

  <span class="token comment">// The local state associated with this fiber.</span>
  <span class="token comment">// 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）</span>
  <span class="token literal-property property">stateNode</span><span class="token operator">:</span> any<span class="token punctuation">,</span>

  <span class="token comment">// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回</span>
  <span class="token keyword">return</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 单链表树结构</span>
  <span class="token comment">// 指向自己的第一个子节点</span>
  <span class="token literal-property property">child</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 指向自己的兄弟结构</span>
  <span class="token comment">// 兄弟节点的return指向同一个父节点</span>
  <span class="token literal-property property">sibling</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">index</span><span class="token operator">:</span> number<span class="token punctuation">,</span>

  <span class="token comment">// ref属性</span>
  <span class="token literal-property property">ref</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">handle</span><span class="token operator">:</span> mixed</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span><span class="token literal-property property">_stringRef</span><span class="token operator">:</span> <span class="token operator">?</span>string<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">|</span> RefObject<span class="token punctuation">,</span>

  <span class="token comment">// 新的变动带来的新的props</span>
  <span class="token literal-property property">pendingProps</span><span class="token operator">:</span> any<span class="token punctuation">,</span> 
  <span class="token comment">// 上一次渲染完成之后的props</span>
  <span class="token literal-property property">memoizedProps</span><span class="token operator">:</span> any<span class="token punctuation">,</span>

  <span class="token comment">// 该Fiber对应的组件产生的Update会存放在这个队列里面</span>
  <span class="token literal-property property">updateQueue</span><span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 上一次渲染的时候的state</span>
  <span class="token literal-property property">memoizedState</span><span class="token operator">:</span> any<span class="token punctuation">,</span>

  <span class="token comment">// 一个列表，存放这个Fiber依赖的context</span>
  <span class="token literal-property property">firstContextDependency</span><span class="token operator">:</span> ContextDependency<span class="token operator">&lt;</span>mixed<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 用来描述当前Fiber和他子树的`Bitfield`</span>
  <span class="token comment">// 共存的模式表示这个子树是否默认是异步渲染的</span>
  <span class="token comment">// Fiber被创建的时候他会继承父Fiber</span>
  <span class="token comment">// 其他的标识也可以在创建的时候被设置</span>
  <span class="token comment">// 但是在创建之后不应该再被修改，特别是他的子Fiber创建之前</span>
  <span class="token literal-property property">mode</span><span class="token operator">:</span> TypeOfMode<span class="token punctuation">,</span>

  <span class="token comment">// Effect</span>
  <span class="token comment">// 用来记录Side Effect</span>
  <span class="token literal-property property">effectTag</span><span class="token operator">:</span> SideEffectTag<span class="token punctuation">,</span>

  <span class="token comment">// 单链表用来快速查找下一个side effect</span>
  <span class="token literal-property property">nextEffect</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 子树中第一个side effect</span>
  <span class="token literal-property property">firstEffect</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 子树中最后一个side effect</span>
  <span class="token literal-property property">lastEffect</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 代表任务在未来的哪个时间点应该被完成</span>
  <span class="token comment">// 不包括他的子树产生的任务</span>
  <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>

  <span class="token comment">// 快速确定子树中是否有不在等待的变化</span>
  <span class="token literal-property property">childExpirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>

  <span class="token comment">// 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber</span>
  <span class="token comment">// 我们称他为`current &lt;==&gt; workInProgress`</span>
  <span class="token comment">// 在渲染完成之后他们会交换位置</span>
  <span class="token literal-property property">alternate</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 下面是调试相关的，收集每个Fiber和子树渲染时间的</span>

  actualDuration<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>

  <span class="token comment">// If the Fiber is currently active in the &quot;render&quot; phase,</span>
  <span class="token comment">// This marks the time at which the work began.</span>
  <span class="token comment">// This field is only set when the enableProfilerTimer flag is enabled.</span>
  actualStartTime<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>

  <span class="token comment">// Duration of the most recent render time for this Fiber.</span>
  <span class="token comment">// This value is not updated when we bailout for memoization purposes.</span>
  <span class="token comment">// This field is only set when the enableProfilerTimer flag is enabled.</span>
  selfBaseDuration<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>

  <span class="token comment">// Sum of base times for all descedents of this Fiber.</span>
  <span class="token comment">// This value bubbles up during the &quot;complete&quot; phase.</span>
  <span class="token comment">// This field is only set when the enableProfilerTimer flag is enabled.</span>
  treeBaseDuration<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>

  <span class="token comment">// Conceptual aliases</span>
  <span class="token comment">// workInProgress : Fiber -&gt;  alternate The alternate used for reuse happens</span>
  <span class="token comment">// to be the same as work in progress.</span>
  <span class="token comment">// __DEV__ only</span>
  _debugID<span class="token operator">?</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
  _debugSource<span class="token operator">?</span><span class="token operator">:</span> Source <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  _debugOwner<span class="token operator">?</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  _debugIsCurrentlyTiming<span class="token operator">?</span><span class="token operator">:</span> boolean<span class="token punctuation">,</span>
<span class="token operator">|</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="effecttags"><a href="#effecttags" class="header-anchor">#</a> effectTags</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */</span>

<span class="token keyword">export</span> type SideEffectTag <span class="token operator">=</span> number<span class="token punctuation">;</span>

<span class="token comment">// Don't change these two values. They're used by React Dev Tools.</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> NoEffect <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b00000000000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> PerformedWork <span class="token operator">=</span> <span class="token comment">/*         */</span> <span class="token number">0b00000000001</span><span class="token punctuation">;</span>

<span class="token comment">// You can change the rest (and add more).</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*             */</span> <span class="token number">0b00000000010</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b00000000100</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> PlacementAndUpdate <span class="token operator">=</span> <span class="token comment">/*    */</span> <span class="token number">0b00000000110</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b00000001000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ContentReset <span class="token operator">=</span> <span class="token comment">/*          */</span> <span class="token number">0b00000010000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Callback <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b00000100000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> DidCapture <span class="token operator">=</span> <span class="token comment">/*            */</span> <span class="token number">0b00001000000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Ref <span class="token operator">=</span> <span class="token comment">/*                   */</span> <span class="token number">0b00010000000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Snapshot <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b00100000000</span><span class="token punctuation">;</span>

<span class="token comment">// Update &amp; Callback &amp; Ref &amp; Snapshot</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> LifecycleEffectMask <span class="token operator">=</span> <span class="token comment">/*   */</span> <span class="token number">0b00110100100</span><span class="token punctuation">;</span>

<span class="token comment">// Union of all host effects</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostEffectMask <span class="token operator">=</span> <span class="token comment">/*        */</span> <span class="token number">0b00111111111</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> Incomplete <span class="token operator">=</span> <span class="token comment">/*            */</span> <span class="token number">0b01000000000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ShouldCapture <span class="token operator">=</span> <span class="token comment">/*         */</span> <span class="token number">0b10000000000</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="reactworktag"><a href="#reactworktag" class="header-anchor">#</a> ReactWorkTag</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> FunctionComponent <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ClassComponent <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> IndeterminateComponent <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// Before we know whether it is function or class</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostRoot <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// Root of a host tree. Could be nested inside another node.</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostPortal <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// A subtree. Could be an entry point to a different renderer.</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostComponent <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostText <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Fragment <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Mode <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ContextConsumer <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ContextProvider <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ForwardRef <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Profiler <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> SuspenseComponent <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> MemoComponent <span class="token operator">=</span> <span class="token number">14</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> SimpleMemoComponent <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> LazyComponent <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> IncompleteClassComponent <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="sideeffects"><a href="#sideeffects" class="header-anchor">#</a> sideEffects</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */</span>

<span class="token keyword">export</span> type SideEffectTag <span class="token operator">=</span> number<span class="token punctuation">;</span>

<span class="token comment">// Don't change these two values. They're used by React Dev Tools.</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> NoEffect <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b00000000000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> PerformedWork <span class="token operator">=</span> <span class="token comment">/*         */</span> <span class="token number">0b00000000001</span><span class="token punctuation">;</span>

<span class="token comment">// You can change the rest (and add more).</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*             */</span> <span class="token number">0b00000000010</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b00000000100</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> PlacementAndUpdate <span class="token operator">=</span> <span class="token comment">/*    */</span> <span class="token number">0b00000000110</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b00000001000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ContentReset <span class="token operator">=</span> <span class="token comment">/*          */</span> <span class="token number">0b00000010000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Callback <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b00000100000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> DidCapture <span class="token operator">=</span> <span class="token comment">/*            */</span> <span class="token number">0b00001000000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Ref <span class="token operator">=</span> <span class="token comment">/*                   */</span> <span class="token number">0b00010000000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Snapshot <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b00100000000</span><span class="token punctuation">;</span>

<span class="token comment">// Update &amp; Callback &amp; Ref &amp; Snapshot</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> LifecycleEffectMask <span class="token operator">=</span> <span class="token comment">/*   */</span> <span class="token number">0b00110100100</span><span class="token punctuation">;</span>

<span class="token comment">// Union of all host effects</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> HostEffectMask <span class="token operator">=</span> <span class="token comment">/*        */</span> <span class="token number">0b00111111111</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> Incomplete <span class="token operator">=</span> <span class="token comment">/*            */</span> <span class="token number">0b01000000000</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> ShouldCapture <span class="token operator">=</span> <span class="token comment">/*         */</span> <span class="token number">0b10000000000</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="update-updatequeue"><a href="#update-updatequeue" class="header-anchor">#</a> Update &amp; UpdateQueue</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> type Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 更新的过期时间</span>
  <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>

  <span class="token comment">// export const UpdateState = 0;</span>
  <span class="token comment">// export const ReplaceState = 1;</span>
  <span class="token comment">// export const ForceUpdate = 2;</span>
  <span class="token comment">// export const CaptureUpdate = 3;</span>
  <span class="token comment">// 指定更新的类型，值为以上几种</span>
  <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token comment">// 更新内容，比如`setState`接收的第一个参数</span>
  <span class="token literal-property property">payload</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token comment">// 对应的回调，`setState`，`render`都有</span>
  <span class="token literal-property property">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> mixed<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 指向下一个更新</span>
  <span class="token literal-property property">next</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 指向下一个`side effect`</span>
  <span class="token literal-property property">nextEffect</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> type UpdateQueue<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 每次操作完更新之后的`state`</span>
  <span class="token literal-property property">baseState</span><span class="token operator">:</span> State<span class="token punctuation">,</span>

  <span class="token comment">// 队列中的第一个`Update`</span>
  <span class="token literal-property property">firstUpdate</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 队列中的最后一个`Update`</span>
  <span class="token literal-property property">lastUpdate</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 第一个捕获类型的`Update`</span>
  <span class="token literal-property property">firstCapturedUpdate</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 最后一个捕获类型的`Update`</span>
  <span class="token literal-property property">lastCapturedUpdate</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 第一个`side effect`</span>
  <span class="token literal-property property">firstEffect</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 最后一个`side effect`</span>
  <span class="token literal-property property">lastEffect</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 第一个和最后一个捕获产生的`side effect`</span>
  <span class="token literal-property property">firstCapturedEffect</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">lastCapturedEffect</span><span class="token operator">:</span> Update<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h1 id="创建更新"><a href="#创建更新" class="header-anchor">#</a> 创建更新</h1> <h2 id="reactdom-render"><a href="#reactdom-render" class="header-anchor">#</a> ReactDOM.render</h2> <h3 id="开始-2"><a href="#开始-2" class="header-anchor">#</a> 开始</h3> <p>创建<code>ReactRoot</code>，并且根据情况调用<code>root.legacy_renderSubtreeIntoContainer</code>或者<code>root.render</code>，前者是遗留的 API 将来应该会删除，根据<code>ReactDOM.render</code>的调用情况也可以发现<code>parentComponent</code>是写死的<code>null</code></p> <p><code>DOMRenderer.unbatchedUpdates</code>制定不使用<code>batchedUpdates</code>，因为这是初次渲染，需要尽快完成。</p> <div class="language-js extra-class"><pre class="language-js"><code>ReactDOM <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span>
    <span class="token parameter"><span class="token literal-property property">element</span><span class="token operator">:</span> React$Element<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">container</span><span class="token operator">:</span> DOMContainer<span class="token punctuation">,</span>
    <span class="token literal-property property">callback</span><span class="token operator">:</span> <span class="token operator">?</span>Function<span class="token punctuation">,</span></span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">legacyRenderSubtreeIntoContainer</span><span class="token punctuation">(</span>
      <span class="token keyword">null</span><span class="token punctuation">,</span>
      element<span class="token punctuation">,</span>
      container<span class="token punctuation">,</span>
      <span class="token boolean">false</span><span class="token punctuation">,</span>
      callback<span class="token punctuation">,</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">legacyRenderSubtreeIntoContainer</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">parentComponent</span><span class="token operator">:</span> <span class="token operator">?</span>React$Component<span class="token operator">&lt;</span>any<span class="token punctuation">,</span> any<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">children</span><span class="token operator">:</span> ReactNodeList<span class="token punctuation">,</span>
  <span class="token literal-property property">container</span><span class="token operator">:</span> DOMContainer<span class="token punctuation">,</span>
  <span class="token literal-property property">forceHydrate</span><span class="token operator">:</span> boolean<span class="token punctuation">,</span>
  <span class="token literal-property property">callback</span><span class="token operator">:</span> <span class="token operator">?</span>Function<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token literal-property property">root</span><span class="token operator">:</span> Root <span class="token operator">=</span> <span class="token punctuation">(</span>container<span class="token punctuation">.</span>_reactRootContainer<span class="token operator">:</span> any<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Initial mount</span>
    root <span class="token operator">=</span> container<span class="token punctuation">.</span>_reactRootContainer <span class="token operator">=</span> <span class="token function">legacyCreateRootFromDOMContainer</span><span class="token punctuation">(</span>
      container<span class="token punctuation">,</span>
      forceHydrate<span class="token punctuation">,</span>
    <span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> originalCallback <span class="token operator">=</span> callback
      <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> instance <span class="token operator">=</span> DOMRenderer<span class="token punctuation">.</span><span class="token function">getPublicRootInstance</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>_internalRoot<span class="token punctuation">)</span>
        <span class="token function">originalCallback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Initial mount should not be batched.</span>
    DOMRenderer<span class="token punctuation">.</span><span class="token function">unbatchedUpdates</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>parentComponent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 一般不会出现</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        root<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 有root的情况</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> DOMRenderer<span class="token punctuation">.</span><span class="token function">getPublicRootInstance</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>_internalRoot<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先会创建<code>ReactRoot</code>对象，然后调用他的<code>render</code>方法</p> <p>创建<code>ReactRoot</code>的时候会调用<code>DOMRenderer.createContainer</code>创建<code>FiberRoot</code>，在后期调度更新的过程中这个节点非常重要</p> <p>这两个数据结构看<a href="https://react.jokcy.me/book/api/react-structure.html" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">legacyCreateRootFromDOMContainer</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">container</span><span class="token operator">:</span> DOMContainer<span class="token punctuation">,</span>
  <span class="token literal-property property">forceHydrate</span><span class="token operator">:</span> boolean<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> Root <span class="token punctuation">{</span>
  <span class="token keyword">const</span> shouldHydrate <span class="token operator">=</span>
    forceHydrate <span class="token operator">||</span> <span class="token function">shouldHydrateDueToLegacyHeuristic</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span>
  <span class="token comment">// First clear any existing content.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldHydrate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> warned <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">let</span> rootSibling
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rootSibling <span class="token operator">=</span> container<span class="token punctuation">.</span>lastChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      container<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>rootSibling<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// Legacy roots are not async by default.</span>
  <span class="token keyword">const</span> isConcurrent <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReactRoot</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> isConcurrent<span class="token punctuation">,</span> shouldHydrate<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">ReactRoot</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">container</span><span class="token operator">:</span> Container<span class="token punctuation">,</span>
  <span class="token literal-property property">isConcurrent</span><span class="token operator">:</span> boolean<span class="token punctuation">,</span>
  <span class="token literal-property property">hydrate</span><span class="token operator">:</span> boolean<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> root <span class="token operator">=</span> DOMRenderer<span class="token punctuation">.</span><span class="token function">createContainer</span><span class="token punctuation">(</span>container<span class="token punctuation">,</span> isConcurrent<span class="token punctuation">,</span> hydrate<span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>_internalRoot <span class="token operator">=</span> root
<span class="token punctuation">}</span>

<span class="token class-name">ReactRoot</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">children</span><span class="token operator">:</span> ReactNodeList<span class="token punctuation">,</span>
  <span class="token literal-property property">callback</span><span class="token operator">:</span> <span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> mixed<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> Work <span class="token punctuation">{</span>
  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_internalRoot
  <span class="token keyword">const</span> work <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReactWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  callback <span class="token operator">=</span> callback <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> callback
  <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warnOnInvalidCallback</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token string">'render'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    work<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  DOMRenderer<span class="token punctuation">.</span><span class="token function">updateContainer</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span> root<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> work<span class="token punctuation">.</span>_onCommit<span class="token punctuation">)</span>
  <span class="token keyword">return</span> work
<span class="token punctuation">}</span>
</code></pre></div><p>其中<code>DOMRenderer</code>是<code>react-reconciler/src/ReactFiberReconciler</code>，他的<code>updateContainer</code>如下在这里计算了一个时间，这个时间叫做<code>expirationTime</code>，顾名思义就是这次更新的 <strong>超时时间</strong>。</p> <p>关于时间是如何计算的<a href="https://react.jokcy.me/book/update/expiration-time.html" target="_blank" rel="noopener noreferrer">看这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>然后调用了<code>updateContainerAtExpirationTime</code>，在这个方法里调用了<code>scheduleRootUpdate</code>就非常重要了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">updateContainer</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">element</span><span class="token operator">:</span> ReactNodeList<span class="token punctuation">,</span>
  <span class="token literal-property property">container</span><span class="token operator">:</span> OpaqueRoot<span class="token punctuation">,</span>
  <span class="token literal-property property">parentComponent</span><span class="token operator">:</span> <span class="token operator">?</span>React$Component<span class="token operator">&lt;</span>any<span class="token punctuation">,</span> any<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">callback</span><span class="token operator">:</span> <span class="token operator">?</span>Function<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> ExpirationTime <span class="token punctuation">{</span>
  <span class="token keyword">const</span> current <span class="token operator">=</span> container<span class="token punctuation">.</span>current
  <span class="token keyword">const</span> currentTime <span class="token operator">=</span> <span class="token function">requestCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> expirationTime <span class="token operator">=</span> <span class="token function">computeExpirationForFiber</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">,</span> current<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token function">updateContainerAtExpirationTime</span><span class="token punctuation">(</span>
    element<span class="token punctuation">,</span>
    container<span class="token punctuation">,</span>
    parentComponent<span class="token punctuation">,</span>
    expirationTime<span class="token punctuation">,</span>
    callback<span class="token punctuation">,</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">updateContainerAtExpirationTime</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">element</span><span class="token operator">:</span> ReactNodeList<span class="token punctuation">,</span>
  <span class="token literal-property property">container</span><span class="token operator">:</span> OpaqueRoot<span class="token punctuation">,</span>
  <span class="token literal-property property">parentComponent</span><span class="token operator">:</span> <span class="token operator">?</span>React$Component<span class="token operator">&lt;</span>any<span class="token punctuation">,</span> any<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>
  <span class="token literal-property property">callback</span><span class="token operator">:</span> <span class="token operator">?</span>Function<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// TODO: If this is a nested container, this won't be the root.</span>
  <span class="token keyword">const</span> current <span class="token operator">=</span> container<span class="token punctuation">.</span>current
  <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token function">getContextForSubtree</span><span class="token punctuation">(</span>parentComponent<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>container<span class="token punctuation">.</span>context <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    container<span class="token punctuation">.</span>context <span class="token operator">=</span> context
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    container<span class="token punctuation">.</span>pendingContext <span class="token operator">=</span> context
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token function">scheduleRootUpdate</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> element<span class="token punctuation">,</span> expirationTime<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="开始调度"><a href="#开始调度" class="header-anchor">#</a> 开始调度</h3> <p>首先要生成一个<code>update</code>，不管你是<code>setState</code>还是<code>ReactDOM.render</code>造成的 React 更新，都会生成一个叫<code>update</code>的对象，并且会赋值给<code>Fiber.updateQueue</code></p> <p>关于<code>update</code>请<a href="https://react.jokcy.me/book/api/react-structure.html" target="_blank" rel="noopener noreferrer">看这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>然后就是调用<code>scheduleWork</code>。注意到这里之前<code>setState</code>和<code>ReactDOM.render</code>是不一样，但进入<code>schedulerWork</code>之后，就是任务调度的事情了，跟之前你是怎么调用的没有任何关系</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">scheduleRootUpdate</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">current</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">element</span><span class="token operator">:</span> ReactNodeList<span class="token punctuation">,</span>
  <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>
  <span class="token literal-property property">callback</span><span class="token operator">:</span> <span class="token operator">?</span>Function<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token function">createUpdate</span><span class="token punctuation">(</span>expirationTime<span class="token punctuation">)</span>

  update<span class="token punctuation">.</span>payload <span class="token operator">=</span> <span class="token punctuation">{</span> element <span class="token punctuation">}</span>

  callback <span class="token operator">=</span> callback <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> callback
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warningWithoutStack</span><span class="token punctuation">(</span>
      <span class="token keyword">typeof</span> callback <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">,</span>
      <span class="token string">'render(...): Expected the last optional `callback` argument to be a '</span> <span class="token operator">+</span>
        <span class="token string">'function. Instead received: %s.'</span><span class="token punctuation">,</span>
      callback<span class="token punctuation">,</span>
    <span class="token punctuation">)</span>
    update<span class="token punctuation">.</span>callback <span class="token operator">=</span> callback
  <span class="token punctuation">}</span>
  <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> update<span class="token punctuation">)</span>

  <span class="token function">scheduleWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span>
  <span class="token keyword">return</span> expirationTime
<span class="token punctuation">}</span>
</code></pre></div><h2 id="setstate"><a href="#setstate" class="header-anchor">#</a> setState</h2> <p><code>setState</code>调用<code>updater.enqueueSetState</code>，我们先不管这个对象什么时候设置进来的，先来看一下代码</p> <div class="language- extra-class"><pre class="language-text"><code>setState`和`forceUpdate`的代码我们可以看到，几乎是一模一样的。唯一的区别是`Update.tag
</code></pre></div><p>关于<code>Update</code>和<code>UpdateQueue</code>的数据结构可以看<a href="https://react.jokcy.me/book/api/react-structure.html" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>在当前节点对应的<code>Fiber</code>对象上创建了<code>Update</code>之后，进就如<code>scheduleWork</code>调度阶段。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> classComponentUpdater <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// isMounted</span>
  <span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token parameter">inst<span class="token punctuation">,</span> payload<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> fiber <span class="token operator">=</span> ReactInstanceMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>inst<span class="token punctuation">)</span>
    <span class="token keyword">const</span> currentTime <span class="token operator">=</span> <span class="token function">requestCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> expirationTime <span class="token operator">=</span> <span class="token function">computeExpirationForFiber</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">,</span> fiber<span class="token punctuation">)</span>

    <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token function">createUpdate</span><span class="token punctuation">(</span>expirationTime<span class="token punctuation">)</span>
    update<span class="token punctuation">.</span>payload <span class="token operator">=</span> payload
    <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      update<span class="token punctuation">.</span>callback <span class="token operator">=</span> callback
    <span class="token punctuation">}</span>

    <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> update<span class="token punctuation">)</span>
    <span class="token function">scheduleWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// replaceState</span>
  <span class="token function">enqueueForceUpdate</span><span class="token punctuation">(</span><span class="token parameter">inst<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> fiber <span class="token operator">=</span> ReactInstanceMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>inst<span class="token punctuation">)</span>
    <span class="token keyword">const</span> currentTime <span class="token operator">=</span> <span class="token function">requestCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> expirationTime <span class="token operator">=</span> <span class="token function">computeExpirationForFiber</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">,</span> fiber<span class="token punctuation">)</span>

    <span class="token keyword">const</span> update <span class="token operator">=</span> <span class="token function">createUpdate</span><span class="token punctuation">(</span>expirationTime<span class="token punctuation">)</span>
    update<span class="token punctuation">.</span>tag <span class="token operator">=</span> ForceUpdate

    <span class="token keyword">if</span> <span class="token punctuation">(</span>callback <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> callback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      update<span class="token punctuation">.</span>callback <span class="token operator">=</span> callback
    <span class="token punctuation">}</span>

    <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> update<span class="token punctuation">)</span>
    <span class="token function">scheduleWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="expirationtime-公式"><a href="#expirationtime-公式" class="header-anchor">#</a> expirationTime 公式</h2> <p>讲公式就有必要把代码亮出来了，毕竟代码量也不多</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">UNIT_SIZE</span> <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">const</span> <span class="token constant">MAGIC_NUMBER_OFFSET</span> <span class="token operator">=</span> <span class="token number">2</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">msToExpirationTime</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">ms</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> ExpirationTime <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ms <span class="token operator">/</span> <span class="token constant">UNIT_SIZE</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">MAGIC_NUMBER_OFFSET</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">expirationTimeToMs</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>expirationTime <span class="token operator">-</span> <span class="token constant">MAGIC_NUMBER_OFFSET</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token constant">UNIT_SIZE</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">ceiling</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">num</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token literal-property property">precision</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">/</span> precision<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> precision
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">computeExpirationBucket</span><span class="token punctuation">(</span>
  <span class="token parameter">currentTime<span class="token punctuation">,</span>
  expirationInMs<span class="token punctuation">,</span>
  bucketSizeMs<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> ExpirationTime <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token constant">MAGIC_NUMBER_OFFSET</span> <span class="token operator">+</span>
    <span class="token function">ceiling</span><span class="token punctuation">(</span>
      currentTime <span class="token operator">-</span> <span class="token constant">MAGIC_NUMBER_OFFSET</span> <span class="token operator">+</span> expirationInMs <span class="token operator">/</span> <span class="token constant">UNIT_SIZE</span><span class="token punctuation">,</span>
      bucketSizeMs <span class="token operator">/</span> <span class="token constant">UNIT_SIZE</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">LOW_PRIORITY_EXPIRATION</span> <span class="token operator">=</span> <span class="token number">5000</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">LOW_PRIORITY_BATCH_SIZE</span> <span class="token operator">=</span> <span class="token number">250</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">computeAsyncExpiration</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">currentTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> ExpirationTime <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">computeExpirationBucket</span><span class="token punctuation">(</span>
    currentTime<span class="token punctuation">,</span>
    <span class="token constant">LOW_PRIORITY_EXPIRATION</span><span class="token punctuation">,</span>
    <span class="token constant">LOW_PRIORITY_BATCH_SIZE</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">HIGH_PRIORITY_EXPIRATION</span> <span class="token operator">=</span> __DEV__ <span class="token operator">?</span> <span class="token number">500</span> <span class="token operator">:</span> <span class="token number">150</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">HIGH_PRIORITY_BATCH_SIZE</span> <span class="token operator">=</span> <span class="token number">100</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">computeInteractiveExpiration</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">currentTime</span><span class="token operator">:</span> ExpirationTime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">computeExpirationBucket</span><span class="token punctuation">(</span>
    currentTime<span class="token punctuation">,</span>
    <span class="token constant">HIGH_PRIORITY_EXPIRATION</span><span class="token punctuation">,</span>
    <span class="token constant">HIGH_PRIORITY_BATCH_SIZE</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>React 中有两种类型的<code>ExpirationTime</code>，一个是<code>Interactive</code>的，另一种是普通的异步。<code>Interactive</code>的比如说是由事件触发的，那么他的响应优先级会比较高因为涉及到交互。</p> <p>在整个计算公式中只有<code>currentTime</code>是变量，也就是当前的时间戳。我们拿<code>computeAsyncExpiration</code>举例，在<code>computeExpirationBucket</code>中接收的就是<code>currentTime</code>、<code>5000</code>和<code>250</code></p> <p>最终的公式就是酱紫的：<code>((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25</code></p> <p>其中<code>25</code>是<code>250 / 10</code>，<code>| 0</code>的作用是取整数</p> <p>翻译一下就是：<strong>当前时间加上<code>498</code>然后处以<code>25</code>取整再加<code>1</code>再乘以 5，需要注意的是这里的<code>currentTime</code>是经过<code>msToExpirationTime</code>处理的，也就是<code>((now / 10) | 0) + 2</code>，所以这里的减去<code>2</code>可以无视，而除以 10 取整应该是要抹平 10 毫秒内的误差，当然最终要用来计算时间差的时候会调用<code>expirationTimeToMs</code>恢复回去，但是被取整去掉的 10 毫秒误差肯定是回不去的。</strong></p> <p>现在应该很明白了吧？再解释一下吧：简单来说在这里，最终结果是以<code>25</code>为单位向上增加的，比如说我们输入<code>10002 - 10026</code>之间，最终得到的结果都是<code>10525</code>，但是到了<code>10027</code>的到的结果就是<code>10550</code>，这就是除以<code>25</code>取整的效果。</p> <p>另外一个要提的就是<code>msToExpirationTime</code>和<code>expirationTimeToMs</code>方法，他们是想换转换的关系。<strong>有一点非常重要，那就是用来计算<code>expirationTime</code>的<code>currentTime</code>是通过<code>msToExpirationTime(now)</code>得到的，也就是预先处理过的，先处以<code>10</code>再加了<code>2</code>，所以后面计算<code>expirationTime</code>要减去<code>2</code>也就不奇怪了</strong></p> <h3 id="小结一下"><a href="#小结一下" class="header-anchor">#</a> 小结一下</h3> <p>React 这么设计抹相当于抹平了<code>25ms</code>内计算过期时间的误差，那他为什么要这么做呢？我思考了很久都没有得到答案，直到有一天我盯着代码发呆，看到<code>LOW_PRIORITY_BATCH_SIZE</code>这个字样，<code>bacth</code>，是不是就对应<code>batchedUpdates</code>？再细想了一下，这么做也许是为了让非常相近的两次更新得到相同的<code>expirationTime</code>，然后在一次更新中完成，相当于一个自动的<code>batchedUpdates</code>。</p> <p>不禁感叹，真的是细啊！</p> <p>以上就是<code>expirationTime</code>的计算方法。</p> <h3 id="currenttime"><a href="#currenttime" class="header-anchor">#</a> currentTime</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">requestCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isRendering<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> currentSchedulerTime
  <span class="token punctuation">}</span>
  <span class="token function">findHighestPriorityRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    nextFlushedExpirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
    nextFlushedExpirationTime <span class="token operator">===</span> Never
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">recomputeCurrentRendererTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    currentSchedulerTime <span class="token operator">=</span> currentRendererTime
    <span class="token keyword">return</span> currentSchedulerTime
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> currentSchedulerTime
<span class="token punctuation">}</span>
</code></pre></div><p>在 React 中我们计算<code>expirationTime</code>要基于当前得<em>时钟时间</em>，一般来说我们只需要获取<code>Date.now</code>或者<code>performance.now</code>就可以了，但是每次获取一下呢比较消耗性能，所以呢 React 设置了<code>currentRendererTime</code>来记录这个值，用于一些不需要重新计算得场景。</p> <p>但是在 React 中呢又提供了<code>currentSchedulerTime</code>这个变量，同样也是记录这个值的，那么为什么要用两个值呢？我们看一下<code>requestCurrentTime</code>方法的实现。</p> <h4 id="首先是"><a href="#首先是" class="header-anchor">#</a> 首先是:</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>isRendering<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> currentSchedulerTime
<span class="token punctuation">}</span>
</code></pre></div><p>这个<code>isRendering</code>只有在<code>performWorkOnRoot</code>的时候才会被设置为<code>true</code>，而其本身是一个同步的方法，不存在他执行到一半没有设置<code>isRendering</code>为<code>false</code>的时候就跳出，那么什么情况下会在这里出现新的<code>requestCurrentTime</code>呢？</p> <ul><li>在生命周期方法中调用了<code>setState</code></li> <li>需要挂起任务的时候</li></ul> <p>也就是说 React 要求<strong>在一次<code>rendering</code>过程中，新产生的<code>update</code>用于计算过期时间的<code>current</code>必须跟目前的<code>renderTime</code>保持一致，同理在这个周期中所有产生的新的更新的过期时间都会保持一致！</strong></p> <h4 id="然后第二个判断"><a href="#然后第二个判断" class="header-anchor">#</a> 然后第二个判断：</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>
  nextFlushedExpirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
  nextFlushedExpirationTime <span class="token operator">===</span> Never
<span class="token punctuation">)</span>
</code></pre></div><p>也就是说在一个<code>batched</code>更新中，只有第一次创建更新才会重新计算时间，后面的所有更新都会复用第一次创建更新的时候的时间，这个也是为了<strong>保证在一个批量更新中产生的同类型的更新只会有相同的过期时间</strong></p> <h3 id="各种不同的-expirationtime"><a href="#各种不同的-expirationtime" class="header-anchor">#</a> 各种不同的 expirationTime</h3> <p>在 React 的调度过程中存在着非常多不同的*<code>expirationTime</code>*变量帮助 React 去实现在单线程环境中调度不同优先级的任务这个需求，这篇文章我们就来一一列举他们的含义以及作用，来帮助我们更好得理解 React 中的整个调度过程。</p> <ul><li><code>root.expirationTime</code></li> <li><code>root.nextExpirationTimeToWorkOn</code></li> <li><code>root.childExpirationTime</code></li> <li><code>root.earliestPendingTime &amp; root.lastestPendingTime</code></li> <li><code>root.earliestSuspendedTime &amp; root.lastestSuspendedTime</code></li> <li><code>root.lastestPingedTime</code></li> <li><code>nextFlushedExpirationTime</code></li> <li><code>nextLatestAbsoluteTimeoutMs</code></li> <li><code>currentRendererTime</code></li> <li><code>currentSchedulerTime</code></li></ul> <p>另外，所有节点都会具有<code>expirationTime</code>和<code>childExpirationTime</code>两个属性</p> <p>以上所有值初始都是<code>NoWork</code>也就是<code>0</code>，以及他们一共会有三种情况：</p> <ul><li><code>NoWork</code>，代表没有更新</li> <li><code>Sync</code>，代表同步执行，不会被调度也不会被打断</li> <li><code>async</code>模式下计算出来的过期时间，一个时间戳</li></ul> <p>接下去的例子我们都会根据下面的例子结构来讲，我们假设有如下结构的一个 React 节点树，他的<code>Fiber</code>结构如下：</p> <p><img src="https://kgfacq.dm.files.1drv.com/y4mdey9O6FJ59ftJnhP1ej6YNMd0z1HWSQsmF42mJjlUiM8fVYKjcyV-0AlUvMdE5SpBHkRl7Wn_WcqaBlhtY-ifm4GLrc_whI9LlUsJyeKOdbmcwCdlqByqYRkCdbjm-6I8d0MuICm3TeAxxyttW3SNKRLWYPeinkDSrH31VLXI4I5M9IJ60x8d6RR1OtOcctUwRNExxMvS6yFQVUEuBulKA?width=721&amp;height=471&amp;cropmode=none" alt="基础结构"></p> <p>后续我们会在这个基础上讲解不同情况下<code>expirationTime</code>的情况</p> <h4 id="childexpirationtime"><a href="#childexpirationtime" class="header-anchor">#</a> childExpirationTime</h4> <p>在之前我们说过，每次一个节点调用<code>setState</code>或者<code>forceUpdate</code>都会产生一个更新并且计算一个<code>expirationTime</code>，那么这个节点的<code>expirationTime</code>就是当时计算出来的值，<strong>因为这个更新本身就是由这个节点产生的</strong></p> <p>最终因为 React 的更新需要从<code>FiberRoot</code>开始，所以会执行一次向上遍历找到<code>FiberRoot</code>，而向上遍历则正好是一步步找到<strong>创建更新的节点的父节点</strong>的过程，这时候 React 就会对每一个该节点的父节点链上的节点设置<code>childExpirationTime</code>，因为这个更新是他们的子孙节点造成的</p> <p><img src="https://h2facq.dm.files.1drv.com/y4mphJBnkRInXVdei2q3h0etKGLWTB5irIH2w23DMcoAKRIl0K7EJPFHjykQ5enpm5lgi_Jp9qTPhBTM64CQF2J_6wxtL1j2raUeLNUm7zXZzclXJQ6iPXjw75oGcdUMdsYCKNm2YawmEsJy2joPddhFLBN4PK51oGM16974Ad3A7azsRa0NunaDYNB1Lvhb3ZMrwKrx-3Yvi90e4vW3A02Iw?width=841&amp;height=571&amp;cropmode=none" alt="img"></p> <p>如上图所示，我们先忽略最左边的<code>child1</code>产生的一次异步更新，如果当前只有<code>child2</code>产生了一个<code>Sync</code>更新，那么<code>App</code>和<code>FiberRoot</code>的<code>childExpirationTime</code>都会更新成<code>Sync</code></p> <p>那么这个值有什么用呢？在我们向下更新整棵<code>Fiber</code>树的时候，每个节点都会执行对应的<code>update</code>方法，在这个方法里面就会使用节点本身的<code>expirationTime</code>和<code>childExpirationTime</code>来判断他是否可以直接跳过，不更新子树。<strong><code>expirationTime</code>代表他本身是否有更新，如果他本身有更新，那么他的更新可能会影响子树；<code>childExpirationTime</code>表示他的子树是否产生了更新；如果两个都没有，那么子树是不需要更新的。</strong></p> <p>对应图中，如果<code>child1</code>，<code>child3</code>，<code>child4</code>还有子树，那么在这次<code>child2</code>的更新中，他们是不需要重新渲染的，在遍历到他们的时候，会直接跳过</p> <p><em>注意：这里只讨论没有其他副作用的情况，比如使用老的<code>context api</code>之类的最终会强制导致没有更新的组件重新渲染的情况我们先不考虑。</em></p> <p>了解了<code>childExpirationTime</code>的作用之后，我们再来讲一下他的特性：</p> <ul><li>同一个节点产生的连续两次更新，最红在父节点上只会体现一次<code>childExpirationTime</code></li> <li>不同子树产生的更新，最终体现在跟节点上的是优先级最高的那个更新</li></ul> <p>第一点很好理解，同一个节点在第一次更新还没有结束的情况下再次产生更新，那么不管他们优先级哪个高，最终都会按照高优先级那个过期时间把所有更新都更新掉了，因为<code>Fiber</code>对象只有一个，<code>updateQueue</code>也只有一个，无法区分同一个对象上连续的不同更新。</p> <p>第二点是因为 React 在创建更新向上寻找<code>root</code>并设置<code>childExpirationTime</code>的时候，会对比之前设置过的和现在的，最终会等于<strong>非<code>NoWork</code>的最小的<code>childExpirationTime</code>，因为<code>expirationTime</code>越小优先级越高，<code>Sync</code>是最高优先级</strong></p> <p>对应到上面的例子中，<code>child1</code>产生的更新是异步的，所以他的<code>expirationTime</code>是计算出来的时间戳，那么肯定比<code>Sync</code>大，所以率先记录到父节点的是<code>child2</code>，同时也是<code>child2</code>的更新先被执行。<strong>即便是<code>child1</code>的更新先产生，如果他在<code>chidl2</code>产生更新的时候他还没更新完，那么也会被打断，先完成<code>child2</code>的渲染，再回头来渲染<code>child1</code></strong></p> <p>以上是<code>childExpirationTime</code>的作用和特性，他在每个节点<code>completeWork</code>的时候会<code>reset</code>父链上的<code>childExpirationTime</code>，也就是说这个节点已经更新完了，那么他的<code>childExpirationTime</code>也就没有意义了。那么这个我们在讲<a href="https://react.jokcy.me/book/update/expiration-time.html" target="_blank" rel="noopener noreferrer">节点更新<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的时候会讲到，到时候大家再对应起来看效果会更好。</p> <h4 id="pendingtime"><a href="#pendingtime" class="header-anchor">#</a> pendingTime</h4> <p>在<code>FiberRoot</code>上有两个值<code>earliestPendingTime</code>和<code>lastestPedingTime</code>，他们是一对值，<strong>用来记录所有子树中需要进行渲染的更新的<code>expirationTime</code>的区间</strong></p> <p><img src="https://hmfacq.dm.files.1drv.com/y4mTm9k8wciS1LTgRpOidtojQQIgCWVhDtXluYnvYIqbK0Z6NUXFqzm76SlooXVfTHb9sAU2pE7du3AbbR23JlZU0vJ1FghvT6X5HXcoguLi4Mp4PdE25AGFt_1w2NJ1K7o3UiqV3mH-kWnlEuWd5xPlkueCdm2FfYDWvCT40ynsrbziTCoE7QMxIbpHyAg6fYkKPHh0qRDY5vrK8ssy8jzuQ?width=841&amp;height=586&amp;cropmode=none" alt="pendingTime demo"></p> <p>在这个例子里，我们同时在<code>child1</code>、<code>child2</code>、<code>child3</code>产生里更新，并且根据优先级计算出了不同的更新时间（<strong>再次重申，请忽略细节，现实中不太会出现同时产生的情况</strong>）。</p> <p>每个更新创建的时候，React 会通过<code>markPendingPriorityLevel</code>标记<code>root</code>节点的<code>earliestPendingTime</code>和<code>lastestPedingTime</code>。他们只记录区间，也就是说现在我们产生了三个不同的过期时间，但是这里只记录最大和最小的。</p> <p>那么他的作用就很明显了，<strong>通过追踪最大和最小值，React 可以判断在当前更新之后是否还具有优先级更低的任务需要执行（当前过期时间处理这两个值之间）。</strong></p> <h4 id="suspendedtime"><a href="#suspendedtime" class="header-anchor">#</a> suspendedTime</h4> <p>同样的在<code>ReactFiber</code>上有两个值<code>earliestSuspendedTime</code>和<code>lastestSuspendedTime</code>，<strong>这两个值是用来记录被挂起的任务的过期时间的</strong></p> <p>首先我们定义一下什么情况下任务是被挂起的：</p> <ul><li>出现可捕获的错误并且还有优先级更低的任务的情况下</li> <li>当捕获到<code>thenable</code>，并且需要设置<code>onTimeout</code>的时候</li></ul> <p>我们称这个任务被<code>suspended</code>(挂起)了。记录这个时间主要是在<code>resolve</code>了<code>promise</code>之后，判断被挂起的组件更新是否依然处于目前已有的<code>suspenedTime</code>中间，如果不是的话是需要重新计算一个新的过期时间，然后从新加入队列进行调度更新的。</p> <p>另外就是在确定目前需要执行的任务的过期时间，也就是<code>root.expirationTime</code>和<code>root.nextExpirationTimeToWorkOn</code>的时候也是一个考虑因素。我们接下去会讲到</p> <h4 id="lastestpingedtime"><a href="#lastestpingedtime" class="header-anchor">#</a> lastestPingedTime</h4> <p>这个值是用来记录最新的一次<code>suspended</code>组件<code>resolve</code>之后，如果挂起之前的<code>expirationTime</code>依然在<code>earliestSuspendedTime</code>和<code>lastestSuspendedTime</code>之间，则会标志这个时间为<code>pingedTime</code></p> <p><code>pingedTime</code>目前看来没有什么别的作用，唯一跟<code>suspendedTime</code>的区别是他的优先级比<code>suspendedTime</code>高一些，会优先选择为渲染目标。</p> <h4 id="root-expirationtime-和-root-nextexpirationtimetoworkon"><a href="#root-expirationtime-和-root-nextexpirationtimetoworkon" class="header-anchor">#</a> root.expirationTime 和 root.nextExpirationTimeToWorkOn</h4> <p><code>root.expirationTime</code>是用来标志当前渲染的过期时间的，请注意他只管本渲染周期，他并不管你现在的渲染目标是哪个，渲染目标是由<code>root.nextExpirationTimeToWorkOn</code>来决定的。</p> <p>那么他们有什么区别呢？主要区别在于发挥作用的阶段</p> <p><code>expirationTime</code>作用于调度阶段，主要指责是：</p> <ul><li>决定是异步执行渲染还是同步执行渲染</li> <li>作为<code>react-scheduler</code>的<code>timeout</code>标准，决定是否要优先渲染</li></ul> <p><code>nextExpirationTimeToWorkOn</code>主要作用于渲染阶段：</p> <ul><li>决定那些更新要在当前周期中被执行</li> <li>通过跟每个节点的<code>expirationTime</code>比较决定该节点是否可以直接<code>bailout</code>（跳过）</li></ul> <p>他们都是通过<code>pendingTime</code>、<code>suspenededTime</code>和<code>pingedTime</code>中删选出来的，唯一的不同是，<code>nextExpirationTimeToWorkOn</code>在没有<code>pending</code>或者<code>pinged</code>的任务的时候会选择最晚的<code>suspendedTime</code>，而<code>expirationTime</code>会选择最早的</p> <p><code>expirationTime</code>的变化：</p> <ul><li>在<code>scheduleWork</code>的时候通过<code>markPendingExpirationTime</code>设置</li> <li>在<code>beginWork</code>的时候被设置为<code>NoWork</code></li> <li>在<code>onUncaughtError</code>的时候设置为<code>NoWork</code></li> <li><code>onSuspend</code>的时候又会设置回当次更新的<code>expirationTime</code></li></ul> <p><strong>这里的不同选择我到目前也没有非常清晰的理解，尝试跟*dan*沟通了解没得到什么反馈，跟*司徒正美*大大聊起过，他觉得这部分功能目前其实还不是特别稳定，有些代码还是比较临时性的，所以现在可以不必要太深究，所以目前来说大家只要知道代码逻辑就可以</strong></p> <p>展示一下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">findNextExpirationTimeToWorkOn</span><span class="token punctuation">(</span><span class="token parameter">completedExpirationTime<span class="token punctuation">,</span> root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> earliestSuspendedTime <span class="token operator">=</span> root<span class="token punctuation">.</span>earliestSuspendedTime
  <span class="token keyword">const</span> latestSuspendedTime <span class="token operator">=</span> root<span class="token punctuation">.</span>latestSuspendedTime
  <span class="token keyword">const</span> earliestPendingTime <span class="token operator">=</span> root<span class="token punctuation">.</span>earliestPendingTime
  <span class="token keyword">const</span> latestPingedTime <span class="token operator">=</span> root<span class="token punctuation">.</span>latestPingedTime

  <span class="token keyword">let</span> nextExpirationTimeToWorkOn <span class="token operator">=</span>
    earliestPendingTime <span class="token operator">!==</span> NoWork <span class="token operator">?</span> earliestPendingTime <span class="token operator">:</span> latestPingedTime

  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    nextExpirationTimeToWorkOn <span class="token operator">===</span> NoWork <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span>completedExpirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
      latestSuspendedTime <span class="token operator">&gt;</span> completedExpirationTime<span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    nextExpirationTimeToWorkOn <span class="token operator">=</span> latestSuspendedTime
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> expirationTime <span class="token operator">=</span> nextExpirationTimeToWorkOn
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    expirationTime <span class="token operator">!==</span> NoWork <span class="token operator">&amp;&amp;</span>
    earliestSuspendedTime <span class="token operator">!==</span> NoWork <span class="token operator">&amp;&amp;</span>
    earliestSuspendedTime <span class="token operator">&lt;</span> expirationTime
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    expirationTime <span class="token operator">=</span> earliestSuspendedTime
  <span class="token punctuation">}</span>

  root<span class="token punctuation">.</span>nextExpirationTimeToWorkOn <span class="token operator">=</span> nextExpirationTimeToWorkOn
  root<span class="token punctuation">.</span>expirationTime <span class="token operator">=</span> expirationTime
<span class="token punctuation">}</span>
</code></pre></div><p>每次开始调度任务，或者设置<code>pendingTime</code>、<code>suspendedTime</code>、<code>pingedTime</code>都会调用这个方法重新删选接下去执行的任务。</p> <p>需要注意一点，并不是所有情况都是从这个方法删选出这两个值的，比如在<code>renderRoot</code>出现错误捕获，并且没有更低优先级的任务的时候，强制以同步的方式把当前<code>expirationTime</code>的任务再重新执行了一遍</p> <div class="language-js extra-class"><pre class="language-js"><code>root<span class="token punctuation">.</span>didError <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token keyword">const</span> suspendedExpirationTime <span class="token operator">=</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>nextExpirationTimeToWorkOn <span class="token operator">=</span> expirationTime<span class="token punctuation">)</span>
<span class="token keyword">const</span> rootExpirationTime <span class="token operator">=</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>expirationTime <span class="token operator">=</span> Sync<span class="token punctuation">)</span>
<span class="token comment">// 什么事情都不做，回到主线程</span>
<span class="token function">onSuspend</span><span class="token punctuation">(</span>
  root<span class="token punctuation">,</span>
  rootWorkInProgress<span class="token punctuation">,</span>
  suspendedExpirationTime<span class="token punctuation">,</span>
  rootExpirationTime<span class="token punctuation">,</span>
  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// Indicates no timeout</span>
<span class="token punctuation">)</span>
<span class="token keyword">return</span>
</code></pre></div><p>这里直接把<code>root.expirationTime</code>设置为<code>Sync</code>，然后直接<code>return</code>，这样回到<code>performWork</code>的时候调用<code>findHighestPriorityRoot</code>会直接设置当前<code>root</code>为下一个渲染的目标，然后再次进行渲染。<code>performWork</code>的循环我们在<a href="https://react.jokcy.me/book/update/expiration-time.html" target="_blank" rel="noopener noreferrer"><code>fiber-scheduler</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中有详细讲解</p> <h4 id="nextflushedexpirationtime"><a href="#nextflushedexpirationtime" class="header-anchor">#</a> nextFlushedExpirationTime</h4> <p>这个是在<code>fiber-scheduler</code>中的一个全局变量，用来记录下一个需要渲染的<code>FiberRoot</code>的过期时间。注意他删选的时候整个应用中所有<code>FiberRoot</code>的优先级（是的，你没看错，应该 React 应用是可以有多个<code>FiberRoot</code>，比如你执行两次<code>ReactDOM.render</code>），并不关心每个<code>FiberRoot</code>子树的优先级。</p> <p>他是在<code>findHighestPriorityRoot</code>中被赋值的，会遍历<code>firstScheduleRoot -&gt; lastScheduledRoot</code>链表中所有<code>root</code>，并找到优先级最高（也就是<code>expirationTime</code>最小）的那个<code>root</code>进行赋值，并安排渲染</p> <h4 id="nextlatestabsolutetimeoutms"><a href="#nextlatestabsolutetimeoutms" class="header-anchor">#</a> nextLatestAbsoluteTimeoutMs</h4> <p>他的作用是在<code>Suspense</code>组件捕获到挂起之后，增加一个<code>timeout</code>来强制重新渲染一次的，不过目前看不出这个<code>timeout</code>有什么用</p> <p>这个跟<code>Suspense</code>组件的<code>maxDuration</code>有关，但是官方没公布用法，从源码中也看不出有什么用处，原以为是<strong>多少毫秒内不显示<code>fallback</code>的内容</strong>，结果测试了一下发现没用。等有空再研究一下，或者等官方正式发布吧，<em>毕竟现在就算研究出来了，可能分分钟就被改了，16.5 的时候还叫<code>delayMs</code>，16.6 就改成<code>maxDuration</code>了</em>。</p> <h4 id="currentschedulertime-currentrenderertime"><a href="#currentschedulertime-currentrenderertime" class="header-anchor">#</a> currentSchedulerTime &amp; currentRendererTime</h4> <p>这两个时间是用来是用来记录当前时间的，在<strong>计算过期时间</strong>和<strong>比较任务是否过期</strong>的时候都会用到<code>currentRendererTime</code>，<code>currentSchedulerTime</code>大部分时候都是等于<code>currentRendererTime</code>的，那为什么要设置两个时间呢？</p> <p>这就是因为<code>batchedUpdates</code>了，在这种情况下如果同时创建了多个更新是会为每次更新计算过期时间的，而计算是要花时间的，如果每次都是请求当前时间，那么同一个<code>batch</code>中的不同更新得到的过期时间就会是不一样的，所以在一个<code>batch</code>中获取的当前时间应该是一样的，所以就设置了这么一个值，在我们请求当前时间的方法中有这么一段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">findHighestPriorityRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>
  nextFlushedExpirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
  nextFlushedExpirationTime <span class="token operator">===</span> Never
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">recomputeCurrentRendererTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  currentSchedulerTime <span class="token operator">=</span> currentRendererTime
  <span class="token keyword">return</span> currentSchedulerTime
<span class="token punctuation">}</span>
</code></pre></div><p><code>findHighestPriorityRoot</code>会设置<code>nextFlushedExpirationTime</code>，也就是只有在当前没有等待中的更新的情况下，才会重新计算当前时间。</p> <h1 id="任务调度"><a href="#任务调度" class="header-anchor">#</a> 任务调度</h1> <h2 id="全局变量"><a href="#全局变量" class="header-anchor">#</a> 全局变量</h2> <h3 id="在-fiberscheduler-中的全局变量"><a href="#在-fiberscheduler-中的全局变量" class="header-anchor">#</a> 在 FiberScheduler 中的全局变量</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Used to ensure computeUniqueAsyncExpiration is monotonically increasing.</span>
<span class="token keyword">let</span> <span class="token literal-property property">lastUniqueAsyncExpiration</span><span class="token operator">:</span> number <span class="token operator">=</span> <span class="token number">0</span>

<span class="token comment">// Represents the expiration time that incoming updates should use. (If this</span>
<span class="token comment">// is NoWork, use the default strategy: async updates in async mode, sync</span>
<span class="token comment">// updates in sync mode.)</span>
<span class="token keyword">let</span> <span class="token literal-property property">expirationContext</span><span class="token operator">:</span> ExpirationTime <span class="token operator">=</span> NoWork

<span class="token keyword">let</span> <span class="token literal-property property">isWorking</span><span class="token operator">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token comment">// The next work in progress fiber that we're currently working on.</span>
<span class="token keyword">let</span> <span class="token literal-property property">nextUnitOfWork</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">let</span> <span class="token literal-property property">nextRoot</span><span class="token operator">:</span> FiberRoot <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token comment">// The time at which we're currently rendering work.</span>
<span class="token keyword">let</span> <span class="token literal-property property">nextRenderExpirationTime</span><span class="token operator">:</span> ExpirationTime <span class="token operator">=</span> NoWork
<span class="token keyword">let</span> <span class="token literal-property property">nextLatestAbsoluteTimeoutMs</span><span class="token operator">:</span> number <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">let</span> <span class="token literal-property property">nextRenderDidError</span><span class="token operator">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token comment">// The next fiber with an effect that we're currently committing.</span>
<span class="token keyword">let</span> <span class="token literal-property property">nextEffect</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token keyword">let</span> <span class="token literal-property property">isCommitting</span><span class="token operator">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token keyword">let</span> <span class="token literal-property property">legacyErrorBoundariesThatAlreadyFailed</span><span class="token operator">:</span> Set<span class="token operator">&lt;</span>mixed<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token comment">// Used for performance tracking.</span>
<span class="token keyword">let</span> <span class="token literal-property property">interruptedBy</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre></div><h4 id="lastuniqueasyncexpiration"><a href="#lastuniqueasyncexpiration" class="header-anchor">#</a> lastUniqueAsyncExpiration</h4> <p>在<code>createBatch</code>中有调用，但是没发现<code>createBatch</code>在哪里被调用，所以，目前没发现什么作用。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">computeUniqueAsyncExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ExpirationTime <span class="token punctuation">{</span>
  <span class="token keyword">const</span> currentTime <span class="token operator">=</span> <span class="token function">requestCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">computeAsyncExpiration</span><span class="token punctuation">(</span>currentTime<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;=</span> lastUniqueAsyncExpiration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> lastUniqueAsyncExpiration <span class="token operator">+</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
  lastUniqueAsyncExpiration <span class="token operator">=</span> result
  <span class="token keyword">return</span> lastUniqueAsyncExpiration
<span class="token punctuation">}</span>
</code></pre></div><h4 id="expirationcontext"><a href="#expirationcontext" class="header-anchor">#</a> expirationContext</h4> <p>保存创建<code>expirationTime</code>的上下文，在<code>syncUpdates</code>和<code>deferredUpdates</code>中分别被设置为<code>Sync</code>和<code>AsyncExpirationTime</code>，在有这个上下文的时候任何更新计算出来的过期时间都等于<code>expirationContext</code>。</p> <p>比如调用<code>ReactDOM.flushSync</code>的时候，他接受的回调中的<code>setState</code></p> <h4 id="isworking"><a href="#isworking" class="header-anchor">#</a> isWorking</h4> <div class="language- extra-class"><pre class="language-text"><code>commitRoot`和`renderRoot`开始都会设置为`true`，然后在他们各自阶段结束的时候都重置为`false
</code></pre></div><p><strong>用来标志是否当前有更新正在进行，不区分阶段</strong></p> <h4 id="iscommitting"><a href="#iscommitting" class="header-anchor">#</a> isCommitting</h4> <div class="language- extra-class"><pre class="language-text"><code>commitRoot`开头设置为`true`，结束之后设置为`false
</code></pre></div><p><strong>用来标志是否处于<code>commit</code>阶段</strong></p> <h4 id="nextunitofwork"><a href="#nextunitofwork" class="header-anchor">#</a> nextUnitOfWork</h4> <p>用于记录<code>render</code>阶段<code>Fiber</code>树遍历过程中下一个需要执行的节点。</p> <p>在<code>resetStack</code>中分别被重置</p> <p>他只会指向<code>workInProgress</code></p> <h4 id="nextroot-nextrenderexpirationtime"><a href="#nextroot-nextrenderexpirationtime" class="header-anchor">#</a> nextRoot &amp; nextRenderExpirationTime</h4> <p>用于记录<strong>下一个将要渲染的<code>root</code>节点</strong>和<strong>下一个要渲染的任务的</strong></p> <p>在<code>renderRoot</code>开始的时候赋值，需要符合如下条件才会重新赋值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>
  expirationTime <span class="token operator">!==</span> nextRenderExpirationTime <span class="token operator">||</span>
  root <span class="token operator">!==</span> nextRoot <span class="token operator">||</span>
  nextUnitOfWork <span class="token operator">===</span> <span class="token keyword">null</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">resetStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  nextRoot <span class="token operator">=</span> root
  nextRenderExpirationTime <span class="token operator">=</span> expirationTime
  nextUnitOfWork <span class="token operator">=</span> <span class="token function">createWorkInProgress</span><span class="token punctuation">(</span>
    nextRoot<span class="token punctuation">.</span>current<span class="token punctuation">,</span>
    <span class="token keyword">null</span><span class="token punctuation">,</span>
    nextRenderExpirationTime<span class="token punctuation">,</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>解释一下就是说，只有这一次调用<code>renderRoot</code>的时候，有</p> <ul><li>新的<code>root</code>要渲染</li> <li>相同的<code>root</code>但是任务有不同优先级的任务要渲染</li> <li>或者在老的任务上没有下一个节点需要渲染了</li></ul> <h4 id="nextlatestabsolutetimeoutms-2"><a href="#nextlatestabsolutetimeoutms-2" class="header-anchor">#</a> nextLatestAbsoluteTimeoutMs</h4> <p>用来记录<code>Suspense</code>组件何时重新尝试渲染，涉及复杂的公式，这里就不详细说了。</p> <p>可以看<a href="https://react.jokcy.me/book/flow/render-root.html" target="_blank" rel="noopener noreferrer"><code>renderRoot</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="nextrenderdiderror"><a href="#nextrenderdiderror" class="header-anchor">#</a> nextRenderDidError</h4> <p>用于记录当前<code>render</code>流程是否有错误产生</p> <div class="language- extra-class"><pre class="language-text"><code>resetStack`重置为`false
</code></pre></div><p>在<code>throwException</code>中如果发现了不能直接处理的错误（除了 Promise 之外），那么就调用<code>renderDidError</code>设置为<code>true</code></p> <h4 id="nexteffect"><a href="#nexteffect" class="header-anchor">#</a> nextEffect</h4> <p>用于<code>commit</code>阶段记录<code>firstEffect -&gt; lastEffect</code>链遍历过程中的每一个<code>Fiber</code></p> <h4 id="interruptedby"><a href="#interruptedby" class="header-anchor">#</a> interruptedBy</h4> <p>给开发工具用的，用来展示被哪个节点打断了异步任务</p> <h3 id="跟调度有关的全局变量"><a href="#跟调度有关的全局变量" class="header-anchor">#</a> 跟调度有关的全局变量</h3> <blockquote><p>ReactFiberScheduler.js 1797-1826</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Linked-list of roots</span>
<span class="token keyword">let</span> <span class="token literal-property property">firstScheduledRoot</span><span class="token operator">:</span> FiberRoot <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">let</span> <span class="token literal-property property">lastScheduledRoot</span><span class="token operator">:</span> FiberRoot <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token keyword">let</span> <span class="token literal-property property">callbackExpirationTime</span><span class="token operator">:</span> ExpirationTime <span class="token operator">=</span> NoWork
<span class="token keyword">let</span> <span class="token literal-property property">callbackID</span><span class="token operator">:</span> <span class="token operator">*</span>
<span class="token keyword">let</span> <span class="token literal-property property">isRendering</span><span class="token operator">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token keyword">let</span> <span class="token literal-property property">nextFlushedRoot</span><span class="token operator">:</span> FiberRoot <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">let</span> <span class="token literal-property property">nextFlushedExpirationTime</span><span class="token operator">:</span> ExpirationTime <span class="token operator">=</span> NoWork
<span class="token keyword">let</span> <span class="token literal-property property">lowestPriorityPendingInteractiveExpirationTime</span><span class="token operator">:</span> ExpirationTime <span class="token operator">=</span> NoWork
<span class="token keyword">let</span> <span class="token literal-property property">deadlineDidExpire</span><span class="token operator">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token keyword">let</span> <span class="token literal-property property">hasUnhandledError</span><span class="token operator">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token keyword">let</span> <span class="token literal-property property">unhandledError</span><span class="token operator">:</span> mixed <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">let</span> <span class="token literal-property property">deadline</span><span class="token operator">:</span> Deadline <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token keyword">let</span> <span class="token literal-property property">isBatchingUpdates</span><span class="token operator">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token keyword">let</span> <span class="token literal-property property">isUnbatchingUpdates</span><span class="token operator">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token keyword">let</span> <span class="token literal-property property">isBatchingInteractiveUpdates</span><span class="token operator">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token keyword">let</span> <span class="token literal-property property">completedBatches</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>Batch<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token keyword">let</span> <span class="token literal-property property">originalStartTimeMs</span><span class="token operator">:</span> number <span class="token operator">=</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> <span class="token literal-property property">currentRendererTime</span><span class="token operator">:</span> ExpirationTime <span class="token operator">=</span> <span class="token function">msToExpirationTime</span><span class="token punctuation">(</span>
  originalStartTimeMs<span class="token punctuation">,</span>
<span class="token punctuation">)</span>
<span class="token keyword">let</span> <span class="token literal-property property">currentSchedulerTime</span><span class="token operator">:</span> ExpirationTime <span class="token operator">=</span> currentRendererTime

<span class="token comment">// Use these to prevent an infinite loop of nested updates</span>
<span class="token keyword">const</span> <span class="token constant">NESTED_UPDATE_LIMIT</span> <span class="token operator">=</span> <span class="token number">50</span>
<span class="token keyword">let</span> <span class="token literal-property property">nestedUpdateCount</span><span class="token operator">:</span> number <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">let</span> <span class="token literal-property property">lastCommittedRootDuringThisBatch</span><span class="token operator">:</span> FiberRoot <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre></div><h4 id="firstscheduledroot-lastscheduledroot"><a href="#firstscheduledroot-lastscheduledroot" class="header-anchor">#</a> firstScheduledRoot &amp; lastScheduledRoot</h4> <p>用于存放有任务的所有<code>root</code>的单列表结构</p> <ul><li>在<code>findHighestPriorityRoot</code>用来检索优先级最高的<code>root</code></li> <li>在<code>addRootToSchedule</code>中会修改</li></ul> <p>在<code>findHighestPriorityRoot</code>中会判断<code>root</code>的<code>expirationTime</code>，并不会直接删除<code>root</code></p> <h4 id="callbackexpirationtime-callbackid"><a href="#callbackexpirationtime-callbackid" class="header-anchor">#</a> callbackExpirationTime &amp; callbackID</h4> <p>记录请求<code>ReactScheduler</code>的时候用的过期时间，如果在一次调度期间有新的调度请求进来了，而且优先级更高，那么需要取消上一次请求，如果更低则无需再次请求调度。</p> <p><code>callbackID</code>是<code>ReactScheduler</code>返回的用于取消调度的 ID</p> <h4 id="isrendering"><a href="#isrendering" class="header-anchor">#</a> isRendering</h4> <p><code>performWorkOnRoot</code>开始设置为<code>true</code>，结束的时候设置为<code>false</code>，表示进入渲染阶段，这是包含<code>render</code>和<code>commit</code>阶段的。</p> <h4 id="nextflushedroot-nextflushedexpirationtime"><a href="#nextflushedroot-nextflushedexpirationtime" class="header-anchor">#</a> nextFlushedRoot &amp; nextFlushedExpirationTime</h4> <p>用来标志下一个需要渲染的<code>root</code>和对应的<code>expirtaionTime</code>，注意：</p> <ul><li>通过<code>findHighestPriorityRoot</code>找到最高优先级的</li> <li>通过<code>flushRoot</code>会直接设置指定的，不进行筛选</li></ul> <h4 id="lowestprioritypendinginteractiveexpirationtime"><a href="#lowestprioritypendinginteractiveexpirationtime" class="header-anchor">#</a> lowestPriorityPendingInteractiveExpirationTime</h4> <p>类似<code>expirationContext</code>，用来存储<code>interactiveUpdates</code>产生的最小的<code>expirationTime</code>，在下一次外部指定的<code>interactiveUpdates</code>情况下会强制输出上一次的<code>interactiveUpdates</code>，<strong>因为<code>interactiveUpdates</code>主要是用户输入之类的操作，如果不及时输出会给用户造成断层感</strong></p> <p>可以通过调用<code>ReactDOM.unstable_interactiveUpdates</code>来实现以上目的</p> <h4 id="deadline-deadlinedidexpire"><a href="#deadline-deadlinedidexpire" class="header-anchor">#</a> deadline &amp; deadlineDidExpire</h4> <p><code>deadline</code>是<code>ReactScheduler</code>中返回的时间片调度信息对象</p> <p>用于记录是否时间片调度是否过期，在<code>shouldYield</code>根据<code>deadline</code>是否过期来设置</p> <h4 id="hasunhandlederror-unhandlederror"><a href="#hasunhandlederror-unhandlederror" class="header-anchor">#</a> hasUnhandledError &amp; unhandledError</h4> <p><code>Profiler</code>调试相关</p> <h4 id="isbatchingupdates-isunbatchingupdates-isbatchinginteractiveupdates"><a href="#isbatchingupdates-isunbatchingupdates-isbatchinginteractiveupdates" class="header-anchor">#</a> isBatchingUpdates &amp; isUnbatchingUpdates &amp; isBatchingInteractiveUpdates</h4> <p><code>batchedUpdates</code>、<code>unBatchedUpdates</code>，<code>deferredUpdates</code>、<code>interactiveUpdates</code>等这些方法用来存储更新产生的上下文的变量</p> <h4 id="originalstarttimems"><a href="#originalstarttimems" class="header-anchor">#</a> originalStartTimeMs</h4> <p>固定值，js 加载完一开始计算的结果</p> <h4 id="currentrenderertime-currentschedulertime"><a href="#currentrenderertime-currentschedulertime" class="header-anchor">#</a> currentRendererTime &amp; currentSchedulerTime</h4> <p>计算从页面加载到现在为止的毫秒数，后者会在<code>isRendering === true</code>的时候用作固定值返回，不然每次<code>requestCurrentTime</code>都会重新计算新的时间。</p> <h4 id="nestedupdatecount-lastcommittedrootduringthisbatch"><a href="#nestedupdatecount-lastcommittedrootduringthisbatch" class="header-anchor">#</a> nestedUpdateCount &amp; lastCommittedRootDuringThisBatch</h4> <p>用来记录是否有嵌套得再生命周期方法中产生更新导致应用无限循环更新得计数器，用于提醒用户书写的不正确的代码。</p> <h2 id="schedulework"><a href="#schedulework" class="header-anchor">#</a> scheduleWork</h2> <p>这里先<code>scheduleWorkToRoot</code>，这一步非常重要，他主要做了一下几个任务</p> <ul><li>找到当前<code>Fiber</code>的 root</li> <li>给更新节点的父节点链上的每个节点的<code>expirationTime</code>设置为这个<code>update</code>的<code>expirationTime</code>，除非他本身时间要小于<code>expirationTime</code></li> <li>给更新节点的父节点链上的每个节点的<code>childExpirationTime</code>设置为这个<code>update</code>的<code>expirationTime</code>，除非他本身时间要小于<code>expirationTime</code></li></ul> <p>最终返回 root 节点的<code>Fiber</code>对象</p> <p>然后进入一个判断：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>
  <span class="token operator">!</span>isWorking <span class="token operator">&amp;&amp;</span>
  nextRenderExpirationTime <span class="token operator">!==</span> NoWork <span class="token operator">&amp;&amp;</span>
  expirationTime <span class="token operator">&lt;</span> nextRenderExpirationTime
<span class="token punctuation">)</span>
</code></pre></div><p>我们来解释一下这几个变量的意思</p> <ol><li><code>isWorking</code>代表是否正在工作，在开始<code>renderRoot</code>和<code>commitRoot</code>的时候会设置为 true，也就是在<code>render</code>和<code>commit</code>两个阶段都会为<code>true</code></li> <li><code>nextRenderExpirationTime</code>在是新的<code>renderRoot</code>的时候会被设置为当前任务的<code>expirationTime</code>，而且一旦他被，只有当下次任务是<code>NoWork</code>的时候他才会被再次设置为<code>NoWork</code>，当然最开始也是<code>NoWork</code></li></ol> <p>那么这个条件就很明显了：<strong>目前没有任何任务在执行，并且之前有执行过任务，同时当前的任务比之前执行的任务过期时间要早（也就是优先级要高）</strong></p> <p>那么这种情况会出现在什么时候呢？答案就是：<strong>上一个任务是异步任务（优先级很低，超时时间是 502ms），并且在上一个时间片（初始是 33ms）任务没有执行完，而且等待下一次<code>requestIdleCallback</code>的时候新的任务进来了，并且超时时间很短（52ms 或者 22ms 甚至是 Sync），那么优先级就变成了先执行当前任务，也就意味着上一个任务被打断了（interrupted）</strong></p> <p>被打断的任务会从当前节点开始往上推出<code>context</code>，因为在 React 只有一个<code>stack</code>，而下一个任务会从头开始的，所以在开始之前需要清空之前任务的的<code>stack</code>。</p> <p><a href="https://react.jokcy.me/book/flow/context.md" target="_blank" rel="noopener noreferrer"><code>context</code>请看这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://react.jokcy.me/book/flow/unwindWork.md" target="_blank" rel="noopener noreferrer"><code>unwindWork</code>请看这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>然后重置所有的公共变量：</p> <div class="language-js extra-class"><pre class="language-js"><code>nextRoot <span class="token operator">=</span> <span class="token keyword">null</span>
nextRenderExpirationTime <span class="token operator">=</span> NoWork
nextLatestAbsoluteTimeoutMs <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
nextRenderDidError <span class="token operator">=</span> <span class="token boolean">false</span>
nextUnitOfWork <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre></div><h5 id="markpendingprioritylevel"><a href="#markpendingprioritylevel" class="header-anchor">#</a> markPendingPriorityLevel</h5> <p>这个方法会记录当前的<code>expirationTime</code>到<code>pendingTime</code>，让<code>expirationTime</code>处于<code>earliestPendingTime</code>和<code>latestPendingTime</code>之间</p> <p>并且会设置<code>root.nextExpirationTimeToWorkOn</code>和<code>root.expirationTime = expirationTime</code>分别是：</p> <ul><li>最早的<code>pendingTime</code>或者<code>pingedTime</code>，如果都没有则是<code>lastestSuspendTime</code></li> <li><code>suspendedTime</code>和<code>nextExpirationTimeToWorkOn</code>中较早的一个</li></ul> <h5 id="调用-requestwork"><a href="#调用-requestwork" class="header-anchor">#</a> 调用 requestWork</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>
  <span class="token operator">!</span>isWorking <span class="token operator">||</span>
  isCommitting <span class="token operator">||</span>
  nextRoot <span class="token operator">!==</span> root
<span class="token punctuation">)</span>
</code></pre></div><p>这个判断条件就比较简单了，<code>!isWorking || isCommitting</code>简单来说就是要么处于没有 work 的状态，要么只能在 render 阶段，不能处于 commit 阶段（比较好奇什么时候会在 commit 阶段有新的任务进来，commit 都是同步的无法打断）。还有一个选项<code>nextRoot !== root</code>，这个的意思就是你的 APP 如果有两个不同的 root，这时候也符合条件。</p> <p>在符合条件之后就<code>requestWork</code>了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">scheduleWork</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">fiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span> <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">scheduleWorkToRoot</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>enableSchedulerTracing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">storeInteractionsForExpirationTime</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> expirationTime<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    <span class="token operator">!</span>isWorking <span class="token operator">&amp;&amp;</span>
    nextRenderExpirationTime <span class="token operator">!==</span> NoWork <span class="token operator">&amp;&amp;</span>
    expirationTime <span class="token operator">&lt;</span> nextRenderExpirationTime
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// This is an interruption. (Used for performance tracking.)</span>
    interruptedBy <span class="token operator">=</span> fiber
    <span class="token function">resetStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">markPendingPriorityLevel</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    <span class="token comment">// If we're in the render phase, we don't need to schedule this root</span>
    <span class="token comment">// for an update, because we'll do it before we exit...</span>
    <span class="token operator">!</span>isWorking <span class="token operator">||</span>
    isCommitting <span class="token operator">||</span>
    <span class="token comment">// ...unless this is a different root than the one we're rendering.</span>
    nextRoot <span class="token operator">!==</span> root
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> rootExpirationTime <span class="token operator">=</span> root<span class="token punctuation">.</span>expirationTime
    <span class="token function">requestWork</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> rootExpirationTime<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">scheduleWorkToRoot</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">fiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span> expirationTime</span><span class="token punctuation">)</span><span class="token operator">:</span> FiberRoot <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>
  <span class="token comment">// Update the source fiber's expiration time</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    fiber<span class="token punctuation">.</span>expirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
    fiber<span class="token punctuation">.</span>expirationTime <span class="token operator">&gt;</span> expirationTime
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fiber<span class="token punctuation">.</span>expirationTime <span class="token operator">=</span> expirationTime
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> alternate <span class="token operator">=</span> fiber<span class="token punctuation">.</span>alternate
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    alternate <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span>alternate<span class="token punctuation">.</span>expirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
      alternate<span class="token punctuation">.</span>expirationTime <span class="token operator">&gt;</span> expirationTime<span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    alternate<span class="token punctuation">.</span>expirationTime <span class="token operator">=</span> expirationTime
  <span class="token punctuation">}</span>
  <span class="token comment">// Walk the parent path to the root and update the child expiration time.</span>
  <span class="token keyword">let</span> node <span class="token operator">=</span> fiber<span class="token punctuation">.</span>return
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fiber<span class="token punctuation">.</span>tag <span class="token operator">===</span> HostRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> fiber<span class="token punctuation">.</span>stateNode
  <span class="token punctuation">}</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    alternate <span class="token operator">=</span> node<span class="token punctuation">.</span>alternate
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      node<span class="token punctuation">.</span>childExpirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
      node<span class="token punctuation">.</span>childExpirationTime <span class="token operator">&gt;</span> expirationTime
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node<span class="token punctuation">.</span>childExpirationTime <span class="token operator">=</span> expirationTime
      <span class="token keyword">if</span> <span class="token punctuation">(</span>
        alternate <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>alternate<span class="token punctuation">.</span>childExpirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
          alternate<span class="token punctuation">.</span>childExpirationTime <span class="token operator">&gt;</span> expirationTime<span class="token punctuation">)</span>
      <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        alternate<span class="token punctuation">.</span>childExpirationTime <span class="token operator">=</span> expirationTime
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>
      alternate <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
      <span class="token punctuation">(</span>alternate<span class="token punctuation">.</span>childExpirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
        alternate<span class="token punctuation">.</span>childExpirationTime <span class="token operator">&gt;</span> expirationTime<span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      alternate<span class="token punctuation">.</span>childExpirationTime <span class="token operator">=</span> expirationTime
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>return <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>tag <span class="token operator">===</span> HostRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> node<span class="token punctuation">.</span>stateNode
    <span class="token punctuation">}</span>
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>return
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">resetStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextUnitOfWork <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> interruptedWork <span class="token operator">=</span> nextUnitOfWork<span class="token punctuation">.</span>return
    <span class="token keyword">while</span> <span class="token punctuation">(</span>interruptedWork <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">unwindInterruptedWork</span><span class="token punctuation">(</span>interruptedWork<span class="token punctuation">)</span>
      interruptedWork <span class="token operator">=</span> interruptedWork<span class="token punctuation">.</span>return
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  nextRoot <span class="token operator">=</span> <span class="token keyword">null</span>
  nextRenderExpirationTime <span class="token operator">=</span> NoWork
  nextLatestAbsoluteTimeoutMs <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
  nextRenderDidError <span class="token operator">=</span> <span class="token boolean">false</span>
  nextUnitOfWork <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="requestwork"><a href="#requestwork" class="header-anchor">#</a> requestWork</h3> <p><code>addRootToSchedule</code>把 root 加入到调度队列，但是要注意一点，不会存在两个相同的 root 前后出现在队列中</p> <p>可以看出来，如果第一次调用<code>addRootToSchedule</code>的时候，<code>nextScheduledRoot</code>是<code>null</code>，这时候公共变量<code>firstScheduledRoot</code>和<code>lastScheduledRoot</code>也是<code>null</code>，所以会把他们都赋值成<code>root</code>，同时<code>root.nextScheduledRoot = root</code>。然后第二次进来的时候，如果前后<code>root</code>是同一个，那么之前的<code>firstScheduledRoot</code>和<code>lastScheduledRoot</code>都是 root，所以<code>lastScheduledRoot.nextScheduledRoot = root</code>就等于<code>root.nextScheduledRoot = root</code></p> <p>这么做是因为同一个<code>root</code>不需要存在两个，因为前一次调度如果中途被打断，下一次调度进入还是从同一个<code>root</code>开始，就会把新的任务一起执行了。</p> <p>之后根据<code>expirationTime</code>调用<code>performSyncWork</code>还是<code>scheduleCallbackWithExpirationTime</code></p> <p><code>scheduleCallbackWithExpirationTime</code>是根据时间片来执行任务的，会涉及到<code>requestIdleCallback</code>，详细解析看<a href="https://react.jokcy.me/book/flow/react-scheduler.md" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><code>isBatchingUpdates</code>和<code>isUnbatchingUpdates</code>涉及到事件系统，看<a href="https://react.jokcy.me/book/event-system/README.md" target="_blank" rel="noopener noreferrer">React 事件系统<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>他们最终都要调用<code>performWork</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">requestWork</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">addRootToSchedule</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isRendering<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Prevent reentrancy. Remaining work will be scheduled at the end of</span>
    <span class="token comment">// the currently rendering batch.</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>isBatchingUpdates<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Flush work at the end of the batch.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isUnbatchingUpdates<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nextFlushedRoot <span class="token operator">=</span> root
      nextFlushedExpirationTime <span class="token operator">=</span> Sync
      <span class="token function">performWorkOnRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> Sync<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>expirationTime <span class="token operator">===</span> Sync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performSyncWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">scheduleCallbackWithExpirationTime</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">addRootToSchedule</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Add the root to the schedule.</span>
  <span class="token comment">// Check if this root is already part of the schedule.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>nextScheduledRoot <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// This root is not already scheduled. Add it.</span>
    root<span class="token punctuation">.</span>expirationTime <span class="token operator">=</span> expirationTime
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastScheduledRoot <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      firstScheduledRoot <span class="token operator">=</span> lastScheduledRoot <span class="token operator">=</span> root
      root<span class="token punctuation">.</span>nextScheduledRoot <span class="token operator">=</span> root
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      lastScheduledRoot<span class="token punctuation">.</span>nextScheduledRoot <span class="token operator">=</span> root
      lastScheduledRoot <span class="token operator">=</span> root
      lastScheduledRoot<span class="token punctuation">.</span>nextScheduledRoot <span class="token operator">=</span> firstScheduledRoot
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// This root is already scheduled, but its priority may have increased.</span>
    <span class="token keyword">const</span> remainingExpirationTime <span class="token operator">=</span> root<span class="token punctuation">.</span>expirationTime
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      remainingExpirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
      expirationTime <span class="token operator">&lt;</span> remainingExpirationTime
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Update the priority.</span>
      root<span class="token punctuation">.</span>expirationTime <span class="token operator">=</span> expirationTime
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>关于<code>scheduleCallbackWithExpirationTime</code>的看<a href="https://react.jokcy.me/book/flow/scheduler-pkg.html" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>接下去就进入了<a href="https://react.jokcy.me/book/flow/perform-work.html" target="_blank" rel="noopener noreferrer"><code>performWork</code>阶段<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="scheduler"><a href="#scheduler" class="header-anchor">#</a> scheduler</h2> <blockquote><p>React16.5 之后把<code>scheduler</code>单独发一个包了，就叫<code>scheduler</code></p></blockquote> <h3 id="schedulecallbackwithexpirationtime"><a href="#schedulecallbackwithexpirationtime" class="header-anchor">#</a> scheduleCallbackWithExpirationTime</h3> <p>异步进行<code>root</code>任务调度就是通过这个方法来做的，这里最主要的就是调用了<code>scheduler</code>的<code>scheduleDeferredCallback</code>方法（在<code>scheduler</code>包中是<code>scheduleWork</code>）</p> <p>传入的的是回调函数<code>performAsyncWork</code>，以及一个包含<code>timeout</code>超时事件的对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">scheduleCallbackWithExpirationTime</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span>
  <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callbackExpirationTime <span class="token operator">!==</span> NoWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// A callback is already scheduled. Check its expiration time (timeout).</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>expirationTime <span class="token operator">&gt;</span> callbackExpirationTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Existing callback has sufficient timeout. Exit.</span>
      <span class="token keyword">return</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>callbackID <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Existing callback has insufficient timeout. Cancel and schedule a</span>
        <span class="token comment">// new one.</span>
        <span class="token function">cancelDeferredCallback</span><span class="token punctuation">(</span>callbackID<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// The request callback timer is already running. Don't start a new one.</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">startRequestCallbackTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  callbackExpirationTime <span class="token operator">=</span> expirationTime
  <span class="token keyword">const</span> currentMs <span class="token operator">=</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> originalStartTimeMs
  <span class="token keyword">const</span> expirationTimeMs <span class="token operator">=</span> <span class="token function">expirationTimeToMs</span><span class="token punctuation">(</span>expirationTime<span class="token punctuation">)</span>
  <span class="token keyword">const</span> timeout <span class="token operator">=</span> expirationTimeMs <span class="token operator">-</span> currentMs
  callbackID <span class="token operator">=</span> <span class="token function">scheduleDeferredCallback</span><span class="token punctuation">(</span>performAsyncWork<span class="token punctuation">,</span> <span class="token punctuation">{</span> timeout <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="scheduler-schedulework"><a href="#scheduler-schedulework" class="header-anchor">#</a> scheduler.scheduleWork</h3> <p>创建一个调度节点<code>newNode</code>，并按照<code>timoutAt</code>的顺序加入到<code>CallbackNode</code>链表，调用<code>ensureHostCallbackIsScheduled</code></p> <p>这里面的<code>expirationTime</code>是调用时传入的<code>timeoutAt</code>加上当前时间形成的过期时间。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">unstable_scheduleCallback</span><span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> deprecated_options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> startTime <span class="token operator">=</span>
    currentEventStartTime <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> currentEventStartTime <span class="token operator">:</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">var</span> expirationTime
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> deprecated_options <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span>
    deprecated_options <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
    <span class="token keyword">typeof</span> deprecated_options<span class="token punctuation">.</span>timeout <span class="token operator">===</span> <span class="token string">'number'</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// FIXME: Remove this branch once we lift expiration times out of React.</span>
    expirationTime <span class="token operator">=</span> startTime <span class="token operator">+</span> deprecated_options<span class="token punctuation">.</span>timeout
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里是以后把`expirationTime`从React中抽离出来之后的逻辑</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">var</span> newNode <span class="token operator">=</span> <span class="token punctuation">{</span>
    callback<span class="token punctuation">,</span>
    <span class="token literal-property property">priorityLevel</span><span class="token operator">:</span> currentPriorityLevel<span class="token punctuation">,</span>
    expirationTime<span class="token punctuation">,</span>
    <span class="token literal-property property">next</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token literal-property property">previous</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Insert the new callback into the list, ordered first by expiration, then</span>
  <span class="token comment">// by insertion. So the new callback is inserted any other callback with</span>
  <span class="token comment">// equal expiration.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>firstCallbackNode <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// This is the first callback in the list.</span>
    firstCallbackNode <span class="token operator">=</span> newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">.</span>previous <span class="token operator">=</span> newNode
    <span class="token function">ensureHostCallbackIsScheduled</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> next <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">var</span> node <span class="token operator">=</span> firstCallbackNode
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>expirationTime <span class="token operator">&gt;</span> expirationTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// The new callback expires before this one.</span>
        next <span class="token operator">=</span> node
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
      node <span class="token operator">=</span> node<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!==</span> firstCallbackNode<span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// No callback with a later expiration was found, which means the new</span>
      <span class="token comment">// callback has the latest expiration in the list.</span>
      next <span class="token operator">=</span> firstCallbackNode
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">===</span> firstCallbackNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// The new callback has the earliest expiration in the entire list.</span>
      firstCallbackNode <span class="token operator">=</span> newNode
      <span class="token function">ensureHostCallbackIsScheduled</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> previous <span class="token operator">=</span> next<span class="token punctuation">.</span>previous
    previous<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">.</span>previous <span class="token operator">=</span> newNode
    newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> next
    newNode<span class="token punctuation">.</span>previous <span class="token operator">=</span> previous
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> newNode
<span class="token punctuation">}</span>
</code></pre></div><h3 id="ensurehostcallbackisscheduled"><a href="#ensurehostcallbackisscheduled" class="header-anchor">#</a> ensureHostCallbackIsScheduled</h3> <p>如果已经在调用回调了，就 return，因为本来就会继续调用下去，<code>isExecutingCallback</code>在<code>flushWork</code>的时候会被修改为<code>true</code></p> <p>如果<code>isHostCallbackScheduled</code>为<code>false</code>，也就是还没开始调度，那么设为<code>true</code>，如果已经开始了，就直接取消，因为顺序可能变了。</p> <p>调用<code>requestHostCallback</code>开始调度</p> <p>这里</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">ensureHostCallbackIsScheduled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isExecutingCallback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Don't schedule work yet; wait until the next time we yield.</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// Schedule the host callback using the earliest expiration in the list.</span>
  <span class="token keyword">var</span> expirationTime <span class="token operator">=</span> firstCallbackNode<span class="token punctuation">.</span>expirationTime
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isHostCallbackScheduled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isHostCallbackScheduled <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Cancel the existing host callback.</span>
    <span class="token function">cancelHostCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">requestHostCallback</span><span class="token punctuation">(</span>flushWork<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function-variable function">cancelHostCallback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  scheduledHostCallback <span class="token operator">=</span> <span class="token keyword">null</span>
  isMessageEventScheduled <span class="token operator">=</span> <span class="token boolean">false</span>
  timeoutTime <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="requesthostcallback"><a href="#requesthostcallback" class="header-anchor">#</a> requestHostCallback</h3> <p>开始进入调度，设置调度的内容，用<code>scheduledHostCallback</code>和<code>timeoutTime</code>这两个全局变量记录回调函数和对应的过期时间</p> <p>调用<code>requestAnimationFrameWithTimeout</code>，其实就是调用<code>requestAnimationFrame</code>在加上设置了一个<code>100ms</code>的定时器，防止<code>requestAnimationFrame</code>太久不触发。</p> <p>调用回调<code>animtionTick</code>并设置<code>isAnimationFrameScheduled</code>全局变量为<code>true</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">requestHostCallback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> absoluteTimeout</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  scheduledHostCallback <span class="token operator">=</span> callback
  timeoutTime <span class="token operator">=</span> absoluteTimeout
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isFlushingHostCallback <span class="token operator">||</span> absoluteTimeout <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Don't wait for the next frame. Continue working ASAP, in a new event.</span>
    window<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>messageKey<span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isAnimationFrameScheduled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isAnimationFrameScheduled <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token function">requestAnimationFrameWithTimeout</span><span class="token punctuation">(</span>animationTick<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="模拟-requestidlecallback"><a href="#模拟-requestidlecallback" class="header-anchor">#</a> 模拟 requestIdleCallback</h3> <p>因为<code>requestIdleCallback</code>这个 API 目前还处于草案阶段，所以浏览器实现率还不高，所以在这里 React 直接使用了<code>polyfill</code>的方案。</p> <p>这个方案简单来说是通过<code>requestAnimationFrame</code>在浏览器渲染一帧之前做一些处理，然后通过<code>postMessage</code>在<code>macro task</code>（类似 setTimeout）中加入一个回调，在因为接下去会进入浏览器渲染阶段，所以主线程是被 block 住的，等到渲染完了然后回来清空<code>macro task</code>。</p> <p>总体上跟<code>requestIdleCallback</code>差不多，<strong>等到主线程有空的时候回来调用</strong></p> <h3 id="animationtick"><a href="#animationtick" class="header-anchor">#</a> animationTick</h3> <p>只要<code>scheduledHostCallback</code>还在就继续调要<code>requestAnimationFrameWithTimeout</code>因为这一帧渲染完了可能队列还没情况，本身也是要进入再次调用的，这边就省去了<code>requestHostCallback</code>在次调用的必要性</p> <p>接下去一段代码是用来计算相隔的<code>requestAnimationFrame</code>的时差的，这个时差如果连续两次都小鱼当前的<code>activeFrameTime</code>，说明平台的帧率是很高的，这种情况下会动态得缩小帧时间。</p> <p>最后更新<code>frameDeadline</code>，然后如果没有触发<code>idleTick</code>则发送消息</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">animationTick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">rafTime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduledHostCallback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">requestAnimationFrameWithTimeout</span><span class="token punctuation">(</span>animationTick<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    isAnimationFrameScheduled <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">var</span> nextFrameTime <span class="token operator">=</span> rafTime <span class="token operator">-</span> frameDeadline <span class="token operator">+</span> activeFrameTime
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFrameTime <span class="token operator">&lt;</span> activeFrameTime <span class="token operator">&amp;&amp;</span> previousFrameTime <span class="token operator">&lt;</span> activeFrameTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFrameTime <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nextFrameTime <span class="token operator">=</span> <span class="token number">8</span>
    <span class="token punctuation">}</span>
    activeFrameTime <span class="token operator">=</span>
      nextFrameTime <span class="token operator">&lt;</span> previousFrameTime <span class="token operator">?</span> previousFrameTime <span class="token operator">:</span> nextFrameTime
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    previousFrameTime <span class="token operator">=</span> nextFrameTime
  <span class="token punctuation">}</span>
  frameDeadline <span class="token operator">=</span> rafTime <span class="token operator">+</span> activeFrameTime
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isMessageEventScheduled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isMessageEventScheduled <span class="token operator">=</span> <span class="token boolean">true</span>
    window<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>messageKey<span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="idletick"><a href="#idletick" class="header-anchor">#</a> idleTick</h3> <p>首先判断<code>postMessage</code>是不是自己的，不是直接返回</p> <p>清空<code>scheduledHostCallback</code>和<code>timeoutTime</code></p> <p>获取当前时间，对比<code>frameDeadline</code>，查看是否已经超时了，如果超时了，判断一下任务<code>callback</code>的过期时间有没有到，如果没有到，则重新对这个<code>callback</code>进行一次调度，然后返回。如果到了，则设置<code>didTimeout</code>为<code>true</code></p> <p>接下去就是调用<code>callback</code>了，这里设置<code>isFlushingHostCallback</code>全局变量为<code>true</code>代表正在执行。并且调用<code>callback</code>也就是<code>flushWork</code>并传入<code>didTimeout</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">idleTick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>source <span class="token operator">!==</span> window <span class="token operator">||</span> event<span class="token punctuation">.</span>data <span class="token operator">!==</span> messageKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  isMessageEventScheduled <span class="token operator">=</span> <span class="token boolean">false</span>

  <span class="token keyword">var</span> prevScheduledCallback <span class="token operator">=</span> scheduledHostCallback
  <span class="token keyword">var</span> prevTimeoutTime <span class="token operator">=</span> timeoutTime
  scheduledHostCallback <span class="token operator">=</span> <span class="token keyword">null</span>
  timeoutTime <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>

  <span class="token keyword">var</span> currentTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">var</span> didTimeout <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>frameDeadline <span class="token operator">-</span> currentTime <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevTimeoutTime <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> prevTimeoutTime <span class="token operator">&lt;=</span> currentTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      didTimeout <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isAnimationFrameScheduled<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        isAnimationFrameScheduled <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token function">requestAnimationFrameWithTimeout</span><span class="token punctuation">(</span>animationTick<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      scheduledHostCallback <span class="token operator">=</span> prevScheduledCallback
      timeoutTime <span class="token operator">=</span> prevTimeoutTime
      <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>prevScheduledCallback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isFlushingHostCallback <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token function">prevScheduledCallback</span><span class="token punctuation">(</span>didTimeout<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
      isFlushingHostCallback <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="flushwork"><a href="#flushwork" class="header-anchor">#</a> flushWork</h3> <p>先设置<code>isExecutingCallback</code>为<code>true</code>，代表正在调用<code>callback</code></p> <p>设置<code>deadlineObject.didTimeout</code>，在 React 业务中可以用来判断任务是否超时</p> <p>如果<code>didTimeout</code>，会一次从<code>firstCallbackNode</code>向后一直执行，知道第一个没过期的任务</p> <p>如果没有超时，则依此执行第一个<code>callback</code>，知道帧时间结束为止</p> <p>最后清理变量，如果任务没有执行完，则再次调用<code>ensureHostCallbackIsScheduled</code>进入调度</p> <p>顺便把<code>Immedia</code>优先级的任务都调用一遍。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">flushWork</span><span class="token punctuation">(</span><span class="token parameter">didTimeout</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  isExecutingCallback <span class="token operator">=</span> <span class="token boolean">true</span>
  deadlineObject<span class="token punctuation">.</span>didTimeout <span class="token operator">=</span> didTimeout
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>didTimeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>firstCallbackNode <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> currentTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstCallbackNode<span class="token punctuation">.</span>expirationTime <span class="token operator">&lt;=</span> currentTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">do</span> <span class="token punctuation">{</span>
            <span class="token function">flushFirstCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>
            firstCallbackNode <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
            firstCallbackNode<span class="token punctuation">.</span>expirationTime <span class="token operator">&lt;=</span> currentTime
          <span class="token punctuation">)</span>
          <span class="token keyword">continue</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>firstCallbackNode <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
          <span class="token function">flushFirstCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>
          firstCallbackNode <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
          <span class="token function">getFrameDeadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span>
        <span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    isExecutingCallback <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstCallbackNode <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">ensureHostCallbackIsScheduled</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      isHostCallbackScheduled <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token function">flushImmediateWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="flushfirstcallback"><a href="#flushfirstcallback" class="header-anchor">#</a> flushFirstCallback</h3> <p>代码太长不放了，他做的事情很简单</p> <ul><li>如果当前队列中只有一个回调，清空队列</li> <li>调用回调并传入<code>deadline</code>对象，里面有<code>timeRemaining</code>方法通过<code>frameDeadline - now()</code>来判断是否帧时间已经到了</li> <li>如果回调有返回内容，把这个返回加入到回调队列</li></ul> <h3 id="全局变量参考"><a href="#全局变量参考" class="header-anchor">#</a> 全局变量参考</h3> <h4 id="ishostcallbackscheduled"><a href="#ishostcallbackscheduled" class="header-anchor">#</a> isHostCallbackScheduled</h4> <p>是否已经开始调度了，在<code>ensureHostCallbackIsScheduled</code>设置为<code>true</code>，在结束执行<code>callback</code>之后设置为<code>false</code></p> <h4 id="scheduledhostcallback"><a href="#scheduledhostcallback" class="header-anchor">#</a> scheduledHostCallback</h4> <p>在<code>requestHostCallback</code>设置，值一般为<code>flushWork</code>，代表下一个调度要做的事情</p> <h4 id="ismessageeventscheduled"><a href="#ismessageeventscheduled" class="header-anchor">#</a> isMessageEventScheduled</h4> <p>是否已经发送调用<code>idleTick</code>的消息，在<code>animationTick</code>中设置为<code>true</code></p> <h4 id="timeouttime"><a href="#timeouttime" class="header-anchor">#</a> timeoutTime</h4> <p>表示过期任务的时间，在<code>idleTick</code>中发现第一个任务的时间已经过期的时候设置</p> <h4 id="isanimationframescheduled"><a href="#isanimationframescheduled" class="header-anchor">#</a> isAnimationFrameScheduled</h4> <p>是否已经开始调用<code>requestAnimationFrame</code></p> <h4 id="activeframetime"><a href="#activeframetime" class="header-anchor">#</a> activeFrameTime</h4> <p>给一帧渲染用的时间，默认是 33，也就是 1 秒 30 帧</p> <h4 id="framedeadline"><a href="#framedeadline" class="header-anchor">#</a> frameDeadline</h4> <p>记录当前帧的到期时间，他等于<code>currentTime + activeFraeTime</code>，也就是<code>requestAnimationFrame</code>回调传入的时间，加上一帧的时间。</p> <h4 id="isflushinghostcallback"><a href="#isflushinghostcallback" class="header-anchor">#</a> isFlushingHostCallback</h4> <p>是否正在执行<code>callback</code></p> <p><a href="https://react.jokcy.me/book/flow/perform-work.html#" target="_blank" rel="noopener noreferrer">JavaScript<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="performwork"><a href="#performwork" class="header-anchor">#</a> performWork</h2> <p><code>performWork</code>通过两种方式调用</p> <h5 id="performasyncwork-异步方式"><a href="#performasyncwork-异步方式" class="header-anchor">#</a> performAsyncWork 异步方式</h5> <p>异步情况给<code>performWork</code>设置的<code>minExpirationTime</code>是<code>NoWork</code>，并且会判断<code>dl.didTimeout</code>，这个值是指任务的<code>expirationTime</code>是否已经超时，如果超时了，则直接设置<code>newExpirationTimeToWorkOn</code>为当前时间，表示这个任务直接执行就行了，不需要判断是否超过了帧时间</p> <h5 id="performsyncwork-同步方式"><a href="#performsyncwork-同步方式" class="header-anchor">#</a> performSyncWork 同步方式</h5> <p>同步方式久比较简单了，设置<code>minExpirationTime</code>为<code>Sync</code>也就是<code>1</code></p> <h5 id="具体-performwork"><a href="#具体-performwork" class="header-anchor">#</a> 具体 performWork</h5> <p>首先要通过<code>findHighestPriorityRoot</code>找到下一个需要操作的<code>root</code>，会设置两个全局变量</p> <p>这里判断是否有<code>deadline</code>来分成两种渲染方式，但最大的差距其实是<code>while</code>循环的判断条件，有<code>deadline</code>的多了一个条件<code>(!deadlineDidExpire || currentRendererTime &gt;= nextFlushedExpirationTime)</code></p> <p>我们先来看相同的部分</p> <div class="language-js extra-class"><pre class="language-js"><code>nextFlushedRoot <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
  nextFlushedExpirationTime <span class="token operator">!==</span> NoWork <span class="token operator">&amp;&amp;</span>
  <span class="token punctuation">(</span>minExpirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
    minExpirationTime <span class="token operator">&gt;=</span> nextFlushedExpirationTime<span class="token punctuation">)</span>
</code></pre></div><p>下一个输出节点不是<code>null</code>，并且过期时间不是<code>NoWork</code>，同时<em>超时时间是<code>NoWork</code>，或者超时时间大于下个节点的超时时间</em>，一般来说<code>minExpirationTime</code>应该就等于<code>nextFlushedExpirationTime</code>因为他们来自同一个 root，<code>nextFlushedExpirationTime</code>是在<code>findHighestPriorityRoot</code>阶段读取出来的<code>root.expirationTime</code></p> <p>在非异步的情况下，接下去就是循环执行<code>performWorkOnRoot</code>然后再找下一个优先级的<code>root</code>执行</p> <p>而在异步的情况下多了一个判断<code>(!deadlineDidExpire || currentRendererTime &gt;= nextFlushedExpirationTime)</code>，什么意思呢？<code>deadlineDidExpire</code>是用来判断时间片是否到期的，也就是<code>deadline</code>中设置的，而第二个条件是<em>当前渲染时间是否大于<code>nextFlushedExpirationTime</code></em>，也就是判断任务是否已经超时了了，如果超时了，根据下面调用<code>performWorkOnRoot</code>的参数中有一个<code>currentRendererTime &gt;= nextFlushedExpirationTime</code>，也就是这种情况下为<code>true</code>，代表的意思是同步执行任务不再判断是否时间片到期。</p> <h5 id="收尾"><a href="#收尾" class="header-anchor">#</a> 收尾</h5> <p>最后如果跳出循环，有两种可能，一是任务已经完成，一是时间片用完了并且任务没过期。对于第二种情况会重新发起一次异步调度，等<code>requestIdleCallback</code>有空了再回来继续执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">performAsyncWork</span><span class="token punctuation">(</span><span class="token parameter">dl</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>dl<span class="token punctuation">.</span>didTimeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstScheduledRoot <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">recomputeCurrentRendererTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">let</span> <span class="token literal-property property">root</span><span class="token operator">:</span> FiberRoot <span class="token operator">=</span> firstScheduledRoot
      <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token function">didExpireAtExpirationTime</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> currentRendererTime<span class="token punctuation">)</span>
        <span class="token comment">// The root schedule is circular, so this is never null.</span>
        root <span class="token operator">=</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>nextScheduledRoot<span class="token operator">:</span> any<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!==</span> firstScheduledRoot<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">performWork</span><span class="token punctuation">(</span>NoWork<span class="token punctuation">,</span> dl<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">performSyncWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">performWork</span><span class="token punctuation">(</span>Sync<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">performWork</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">minExpirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span> <span class="token literal-property property">dl</span><span class="token operator">:</span> Deadline <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  deadline <span class="token operator">=</span> dl

  <span class="token comment">// Keep working on roots until there's no more work, or until we reach</span>
  <span class="token comment">// the deadline.</span>
  <span class="token function">findHighestPriorityRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>deadline <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">recomputeCurrentRendererTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    currentSchedulerTime <span class="token operator">=</span> currentRendererTime

    <span class="token keyword">if</span> <span class="token punctuation">(</span>enableUserTimingAPI<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> didExpire <span class="token operator">=</span> nextFlushedExpirationTime <span class="token operator">&lt;</span> currentRendererTime
      <span class="token keyword">const</span> timeout <span class="token operator">=</span> <span class="token function">expirationTimeToMs</span><span class="token punctuation">(</span>nextFlushedExpirationTime<span class="token punctuation">)</span>
      <span class="token function">stopRequestCallbackTimer</span><span class="token punctuation">(</span>didExpire<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>
      nextFlushedRoot <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
      nextFlushedExpirationTime <span class="token operator">!==</span> NoWork <span class="token operator">&amp;&amp;</span>
      <span class="token punctuation">(</span>minExpirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
        minExpirationTime <span class="token operator">&gt;=</span> nextFlushedExpirationTime<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
      <span class="token punctuation">(</span><span class="token operator">!</span>deadlineDidExpire <span class="token operator">||</span> currentRendererTime <span class="token operator">&gt;=</span> nextFlushedExpirationTime<span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">performWorkOnRoot</span><span class="token punctuation">(</span>
        nextFlushedRoot<span class="token punctuation">,</span>
        nextFlushedExpirationTime<span class="token punctuation">,</span>
        currentRendererTime <span class="token operator">&gt;=</span> nextFlushedExpirationTime<span class="token punctuation">,</span>
      <span class="token punctuation">)</span>
      <span class="token function">findHighestPriorityRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token function">recomputeCurrentRendererTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      currentSchedulerTime <span class="token operator">=</span> currentRendererTime
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>
      nextFlushedRoot <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
      nextFlushedExpirationTime <span class="token operator">!==</span> NoWork <span class="token operator">&amp;&amp;</span>
      <span class="token punctuation">(</span>minExpirationTime <span class="token operator">===</span> NoWork <span class="token operator">||</span>
        minExpirationTime <span class="token operator">&gt;=</span> nextFlushedExpirationTime<span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">performWorkOnRoot</span><span class="token punctuation">(</span>nextFlushedRoot<span class="token punctuation">,</span> nextFlushedExpirationTime<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
      <span class="token function">findHighestPriorityRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// We're done flushing work. Either we ran out of time in this callback,</span>
  <span class="token comment">// or there's no more work left with sufficient priority.</span>

  <span class="token comment">// If we're inside a callback, set this to false since we just completed it.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>deadline <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    callbackExpirationTime <span class="token operator">=</span> NoWork
    callbackID <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// If there's work left over, schedule a new callback.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlushedExpirationTime <span class="token operator">!==</span> NoWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">scheduleCallbackWithExpirationTime</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token punctuation">(</span>nextFlushedRoot<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> FiberRoot<span class="token punctuation">)</span><span class="token punctuation">,</span>
      nextFlushedExpirationTime<span class="token punctuation">,</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Clean-up.</span>
  deadline <span class="token operator">=</span> <span class="token keyword">null</span>
  deadlineDidExpire <span class="token operator">=</span> <span class="token boolean">false</span>

  <span class="token function">finishRendering</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="performworkonroot"><a href="#performworkonroot" class="header-anchor">#</a> performWorkOnRoot</h3> <p>这里也分为同步和异步两种情况，但是这两种情况的区别其实非常小。</p> <p>首先是一个参数的区别，<code>isYieldy</code>在同步的情况下是<code>false</code>，而在异步情况下是<code>true</code>。这个参数顾名思义就是<em>是否可以中断</em>，那么这个区别也就很好理解了。</p> <p>第二个区别就是在<code>renderRoot</code>之后判断一下<code>shouldYeild</code>，如果时间片已经用完，则不直接<code>completeRoot</code>，而是等到一下次<code>requestIdleCallback</code>之后再执行。</p> <p><code>renderRoot</code>和<code>completeRoot</code>分别对应两个阶段：</p> <ul><li>渲染阶段</li> <li>提交阶段</li></ul> <p>渲染阶段可以被打断，而提交阶段不能</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">performWorkOnRoot</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span>
  <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>
  <span class="token literal-property property">isExpired</span><span class="token operator">:</span> boolean<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  isRendering <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>deadline <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> isExpired<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> finishedWork <span class="token operator">=</span> root<span class="token punctuation">.</span>finishedWork
    <span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// This root is already complete. We can commit it.</span>
      <span class="token function">completeRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> finishedWork<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      root<span class="token punctuation">.</span>finishedWork <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token keyword">const</span> timeoutHandle <span class="token operator">=</span> root<span class="token punctuation">.</span>timeoutHandle
      <span class="token keyword">if</span> <span class="token punctuation">(</span>enableSuspense <span class="token operator">&amp;&amp;</span> timeoutHandle <span class="token operator">!==</span> noTimeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        root<span class="token punctuation">.</span>timeoutHandle <span class="token operator">=</span> noTimeout
        <span class="token function">cancelTimeout</span><span class="token punctuation">(</span>timeoutHandle<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">const</span> isYieldy <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token function">renderRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> isYieldy<span class="token punctuation">,</span> isExpired<span class="token punctuation">)</span>
      finishedWork <span class="token operator">=</span> root<span class="token punctuation">.</span>finishedWork
      <span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// We've completed the root. Commit it.</span>
        <span class="token function">completeRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> finishedWork<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Flush async work.</span>
    <span class="token keyword">let</span> finishedWork <span class="token operator">=</span> root<span class="token punctuation">.</span>finishedWork
    <span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// This root is already complete. We can commit it.</span>
      <span class="token function">completeRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> finishedWork<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      root<span class="token punctuation">.</span>finishedWork <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token comment">// If this root previously suspended, clear its existing timeout, since</span>
      <span class="token comment">// we're about to try rendering again.</span>
      <span class="token keyword">const</span> timeoutHandle <span class="token operator">=</span> root<span class="token punctuation">.</span>timeoutHandle
      <span class="token keyword">if</span> <span class="token punctuation">(</span>enableSuspense <span class="token operator">&amp;&amp;</span> timeoutHandle <span class="token operator">!==</span> noTimeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        root<span class="token punctuation">.</span>timeoutHandle <span class="token operator">=</span> noTimeout
        <span class="token comment">// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above</span>
        <span class="token function">cancelTimeout</span><span class="token punctuation">(</span>timeoutHandle<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">const</span> isYieldy <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token function">renderRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> isYieldy<span class="token punctuation">,</span> isExpired<span class="token punctuation">)</span>
      finishedWork <span class="token operator">=</span> root<span class="token punctuation">.</span>finishedWork
      <span class="token keyword">if</span> <span class="token punctuation">(</span>finishedWork <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// Still time left. Commit the root.</span>
          <span class="token function">completeRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> finishedWork<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          root<span class="token punctuation">.</span>finishedWork <span class="token operator">=</span> finishedWork
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  isRendering <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="findhighestpriorityroot"><a href="#findhighestpriorityroot" class="header-anchor">#</a> findHighestPriorityRoot</h3> <p>一般情况下我们的 React 应用只会有一个<code>root</code>，所以这里的大部分逻辑其实都不是常见情况</p> <p>循环<code>firstScheduledRoot =&gt; lastScheduledRoot</code>，<code>remainingExpirationTime</code>是<code>root.expirationTime</code>，也就是最早的过期时间。</p> <p>如果他是<code>NoWork</code>说明他已经没有任务了，从链表中删除。</p> <p>从剩下的中找到<code>expirationTime</code>最小的也就是优先级最高的<code>root</code>然后把他赋值给<code>nextFlushedRoot</code>并把他的<code>expirationTime</code>赋值给<code>nextFlushedExpirationTime</code>这两个公共变量。</p> <p>一般来说会直接执行下面这个逻辑</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> root<span class="token punctuation">.</span>nextScheduledRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// This is the only root in the list.</span>
  root<span class="token punctuation">.</span>nextScheduledRoot <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  firstScheduledRoot <span class="token operator">=</span> lastScheduledRoot <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">findHighestPriorityRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> highestPriorityWork <span class="token operator">=</span> NoWork
  <span class="token keyword">let</span> highestPriorityRoot <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lastScheduledRoot <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> previousScheduledRoot <span class="token operator">=</span> lastScheduledRoot
    <span class="token keyword">let</span> root <span class="token operator">=</span> firstScheduledRoot
    <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> remainingExpirationTime <span class="token operator">=</span> root<span class="token punctuation">.</span>expirationTime
      <span class="token keyword">if</span> <span class="token punctuation">(</span>remainingExpirationTime <span class="token operator">===</span> NoWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// This root no longer has work. Remove it from the scheduler.</span>

        <span class="token comment">// TODO: This check is redudant, but Flow is confused by the branch</span>
        <span class="token comment">// below where we set lastScheduledRoot to null, even though we break</span>
        <span class="token comment">// from the loop right after.</span>
        <span class="token function">invariant</span><span class="token punctuation">(</span>
          previousScheduledRoot <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> lastScheduledRoot <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
          <span class="token string">'Should have a previous and last root. This error is likely '</span> <span class="token operator">+</span>
            <span class="token string">'caused by a bug in React. Please file an issue.'</span><span class="token punctuation">,</span>
        <span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> root<span class="token punctuation">.</span>nextScheduledRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// This is the only root in the list.</span>
          root<span class="token punctuation">.</span>nextScheduledRoot <span class="token operator">=</span> <span class="token keyword">null</span>
          firstScheduledRoot <span class="token operator">=</span> lastScheduledRoot <span class="token operator">=</span> <span class="token keyword">null</span>
          <span class="token keyword">break</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> firstScheduledRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// This is the first root in the list.</span>
          <span class="token keyword">const</span> next <span class="token operator">=</span> root<span class="token punctuation">.</span>nextScheduledRoot
          firstScheduledRoot <span class="token operator">=</span> next
          lastScheduledRoot<span class="token punctuation">.</span>nextScheduledRoot <span class="token operator">=</span> next
          root<span class="token punctuation">.</span>nextScheduledRoot <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> lastScheduledRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// This is the last root in the list.</span>
          lastScheduledRoot <span class="token operator">=</span> previousScheduledRoot
          lastScheduledRoot<span class="token punctuation">.</span>nextScheduledRoot <span class="token operator">=</span> firstScheduledRoot
          root<span class="token punctuation">.</span>nextScheduledRoot <span class="token operator">=</span> <span class="token keyword">null</span>
          <span class="token keyword">break</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          previousScheduledRoot<span class="token punctuation">.</span>nextScheduledRoot <span class="token operator">=</span> root<span class="token punctuation">.</span>nextScheduledRoot
          root<span class="token punctuation">.</span>nextScheduledRoot <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
        root <span class="token operator">=</span> previousScheduledRoot<span class="token punctuation">.</span>nextScheduledRoot
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>
          highestPriorityWork <span class="token operator">===</span> NoWork <span class="token operator">||</span>
          remainingExpirationTime <span class="token operator">&lt;</span> highestPriorityWork
        <span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// Update the priority, if it's higher</span>
          highestPriorityWork <span class="token operator">=</span> remainingExpirationTime
          highestPriorityRoot <span class="token operator">=</span> root
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> lastScheduledRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>highestPriorityWork <span class="token operator">===</span> Sync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// Sync is highest priority by definition so</span>
          <span class="token comment">// we can stop searching.</span>
          <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
        previousScheduledRoot <span class="token operator">=</span> root
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>nextScheduledRoot
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  nextFlushedRoot <span class="token operator">=</span> highestPriorityRoot
  nextFlushedExpirationTime <span class="token operator">=</span> highestPriorityWork
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/source-code/生命周期.html" class="prev">
        生命周期
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.27287fd6.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/149.e24c9de5.js" defer></script>
  </body>
</html>
