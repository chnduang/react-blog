<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一文吃透react事件原理 | duangdong的react</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="react相关知识归纳总结">
    <meta name="keywords" content="react,react进阶,react性能优化,react-hooks,react源码">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.27287fd6.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/67.aa46c62c.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/100.27126660.js"><link rel="prefetch" href="/assets/js/101.09cf74ec.js"><link rel="prefetch" href="/assets/js/102.8cd6b4eb.js"><link rel="prefetch" href="/assets/js/103.c4f25168.js"><link rel="prefetch" href="/assets/js/104.4f1b4569.js"><link rel="prefetch" href="/assets/js/105.bc4fc023.js"><link rel="prefetch" href="/assets/js/106.b9d5be0c.js"><link rel="prefetch" href="/assets/js/107.f9a44dd7.js"><link rel="prefetch" href="/assets/js/108.0424a7b7.js"><link rel="prefetch" href="/assets/js/109.086a89ae.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/110.1e4c2c77.js"><link rel="prefetch" href="/assets/js/111.16e80560.js"><link rel="prefetch" href="/assets/js/112.441e61a6.js"><link rel="prefetch" href="/assets/js/113.41a44465.js"><link rel="prefetch" href="/assets/js/114.9efb5469.js"><link rel="prefetch" href="/assets/js/115.d095bf75.js"><link rel="prefetch" href="/assets/js/116.b368a7c1.js"><link rel="prefetch" href="/assets/js/117.3a319a71.js"><link rel="prefetch" href="/assets/js/118.7ea17677.js"><link rel="prefetch" href="/assets/js/119.df1f998f.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/120.935f9aea.js"><link rel="prefetch" href="/assets/js/121.c09de772.js"><link rel="prefetch" href="/assets/js/122.32443376.js"><link rel="prefetch" href="/assets/js/123.d0f8ea63.js"><link rel="prefetch" href="/assets/js/124.fdbcd92d.js"><link rel="prefetch" href="/assets/js/125.0de5eb94.js"><link rel="prefetch" href="/assets/js/126.fb5e629b.js"><link rel="prefetch" href="/assets/js/127.866d8d58.js"><link rel="prefetch" href="/assets/js/128.1aad073e.js"><link rel="prefetch" href="/assets/js/129.328f52fd.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/130.ac9676d9.js"><link rel="prefetch" href="/assets/js/131.9852c015.js"><link rel="prefetch" href="/assets/js/132.806bcfe3.js"><link rel="prefetch" href="/assets/js/133.073ecd1e.js"><link rel="prefetch" href="/assets/js/134.e2683d73.js"><link rel="prefetch" href="/assets/js/135.d16cdb0b.js"><link rel="prefetch" href="/assets/js/136.c3b47da6.js"><link rel="prefetch" href="/assets/js/137.f7fec328.js"><link rel="prefetch" href="/assets/js/138.ec6ab500.js"><link rel="prefetch" href="/assets/js/139.18b97522.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/140.c7df1047.js"><link rel="prefetch" href="/assets/js/141.484c6ca5.js"><link rel="prefetch" href="/assets/js/142.8eff7a66.js"><link rel="prefetch" href="/assets/js/143.60569694.js"><link rel="prefetch" href="/assets/js/144.01883b7c.js"><link rel="prefetch" href="/assets/js/145.a9241012.js"><link rel="prefetch" href="/assets/js/146.4b6f364c.js"><link rel="prefetch" href="/assets/js/147.9ed57153.js"><link rel="prefetch" href="/assets/js/148.e18d806a.js"><link rel="prefetch" href="/assets/js/149.e24c9de5.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.f1afbc9c.js"><link rel="prefetch" href="/assets/js/24.7f3fc444.js"><link rel="prefetch" href="/assets/js/25.5a945cd4.js"><link rel="prefetch" href="/assets/js/26.7ef56339.js"><link rel="prefetch" href="/assets/js/27.74941107.js"><link rel="prefetch" href="/assets/js/28.20a36928.js"><link rel="prefetch" href="/assets/js/29.7cda6a44.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.97f5cf7e.js"><link rel="prefetch" href="/assets/js/31.eeee5c14.js"><link rel="prefetch" href="/assets/js/32.a2125816.js"><link rel="prefetch" href="/assets/js/33.b3fdf3bc.js"><link rel="prefetch" href="/assets/js/34.908ac5fb.js"><link rel="prefetch" href="/assets/js/35.9459a7c7.js"><link rel="prefetch" href="/assets/js/36.dc8e2582.js"><link rel="prefetch" href="/assets/js/37.27c69606.js"><link rel="prefetch" href="/assets/js/38.10b82911.js"><link rel="prefetch" href="/assets/js/39.fdc5aecb.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.901c96dc.js"><link rel="prefetch" href="/assets/js/41.4cbb9c4b.js"><link rel="prefetch" href="/assets/js/42.da47ce58.js"><link rel="prefetch" href="/assets/js/43.a7669073.js"><link rel="prefetch" href="/assets/js/44.08cc8605.js"><link rel="prefetch" href="/assets/js/45.5461c987.js"><link rel="prefetch" href="/assets/js/46.4c5ed7f9.js"><link rel="prefetch" href="/assets/js/47.450abe13.js"><link rel="prefetch" href="/assets/js/48.d0a778f3.js"><link rel="prefetch" href="/assets/js/49.611d9085.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.2563fd92.js"><link rel="prefetch" href="/assets/js/51.ff64258c.js"><link rel="prefetch" href="/assets/js/52.d47acb9b.js"><link rel="prefetch" href="/assets/js/53.09fd35d1.js"><link rel="prefetch" href="/assets/js/54.5e523072.js"><link rel="prefetch" href="/assets/js/55.8278650d.js"><link rel="prefetch" href="/assets/js/56.425f7e44.js"><link rel="prefetch" href="/assets/js/57.44699db6.js"><link rel="prefetch" href="/assets/js/58.25067fcf.js"><link rel="prefetch" href="/assets/js/59.3814ee9e.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/60.82621500.js"><link rel="prefetch" href="/assets/js/61.9880375b.js"><link rel="prefetch" href="/assets/js/62.3924c2b9.js"><link rel="prefetch" href="/assets/js/63.ff3650b8.js"><link rel="prefetch" href="/assets/js/64.0d46b236.js"><link rel="prefetch" href="/assets/js/65.f255f222.js"><link rel="prefetch" href="/assets/js/66.d797120d.js"><link rel="prefetch" href="/assets/js/68.0dbf39cf.js"><link rel="prefetch" href="/assets/js/69.116b53df.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/70.a05986f2.js"><link rel="prefetch" href="/assets/js/71.562a4365.js"><link rel="prefetch" href="/assets/js/72.c10c6194.js"><link rel="prefetch" href="/assets/js/73.d85c71e5.js"><link rel="prefetch" href="/assets/js/74.73f72e00.js"><link rel="prefetch" href="/assets/js/75.62c76a28.js"><link rel="prefetch" href="/assets/js/76.8d0d9036.js"><link rel="prefetch" href="/assets/js/77.4ede6642.js"><link rel="prefetch" href="/assets/js/78.7d4d4152.js"><link rel="prefetch" href="/assets/js/79.720e767d.js"><link rel="prefetch" href="/assets/js/80.e9d86233.js"><link rel="prefetch" href="/assets/js/81.40ea5e9f.js"><link rel="prefetch" href="/assets/js/82.78074ee1.js"><link rel="prefetch" href="/assets/js/83.72133cbf.js"><link rel="prefetch" href="/assets/js/84.52c5ea65.js"><link rel="prefetch" href="/assets/js/85.afce36a7.js"><link rel="prefetch" href="/assets/js/86.bdc638dd.js"><link rel="prefetch" href="/assets/js/87.11e34480.js"><link rel="prefetch" href="/assets/js/88.5fd9f0ef.js"><link rel="prefetch" href="/assets/js/89.718ec134.js"><link rel="prefetch" href="/assets/js/90.11f956de.js"><link rel="prefetch" href="/assets/js/91.985d80f2.js"><link rel="prefetch" href="/assets/js/92.9c876df3.js"><link rel="prefetch" href="/assets/js/93.da92c068.js"><link rel="prefetch" href="/assets/js/94.cf4ee959.js"><link rel="prefetch" href="/assets/js/95.665f55e6.js"><link rel="prefetch" href="/assets/js/96.2e80356d.js"><link rel="prefetch" href="/assets/js/97.d7d8ba2d.js"><link rel="prefetch" href="/assets/js/98.70eab878.js"><link rel="prefetch" href="/assets/js/99.60ddb42d.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的react</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/events/" class="nav-link router-link-active">
  事件机制
</a></div><div class="nav-item"><a href="/fiber/" class="nav-link">
  Fiber
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  进阶
</a></div><div class="nav-item"><a href="/hooks/" class="nav-link">
  Hooks
</a></div><div class="nav-item"><a href="/source-code/" class="nav-link">
  源码解读
</a></div><div class="nav-item"><a href="/performance/" class="nav-link">
  性能优化
</a></div><div class="nav-item"><a href="/base/" class="nav-link">
  基础
</a></div><div class="nav-item"><a href="/jest/" class="nav-link">
  单元测试
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/events/" class="nav-link router-link-active">
  事件机制
</a></div><div class="nav-item"><a href="/fiber/" class="nav-link">
  Fiber
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  进阶
</a></div><div class="nav-item"><a href="/hooks/" class="nav-link">
  Hooks
</a></div><div class="nav-item"><a href="/source-code/" class="nav-link">
  源码解读
</a></div><div class="nav-item"><a href="/performance/" class="nav-link">
  性能优化
</a></div><div class="nav-item"><a href="/base/" class="nav-link">
  基础
</a></div><div class="nav-item"><a href="/jest/" class="nav-link">
  单元测试
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/events/" aria-current="page" class="sidebar-link">进阶</a></li><li><a href="/events/React事件机制.html" class="sidebar-link">React 事件机制</a></li><li><a href="/events/Render如何强制它.html" class="sidebar-link">什么是 React 中的 Render 以及如何强制它？</a></li><li><a href="/events/react-事件机制.html" class="sidebar-link">React事件机制的理解？</a></li><li><a href="/events/react事件系统原理.html" class="sidebar-link">React 事件系统原理</a></li><li><a href="/events/一文吃透react事件原理.html" class="active sidebar-link">一文吃透react事件原理</a></li><li><a href="/events/一文读懂React组件渲染核心原理.html" class="sidebar-link">一文读懂 React 组件渲染核心原理</a></li><li><a href="/events/从源码深入探究React 运行时优化方案的演进.html" class="sidebar-link">从源码深入探究React 运行时优化方案的演进</a></li><li><a href="/events/搞懂React调度器原理.html" class="sidebar-link">不用一行代码，搞懂React调度器原理</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="一文吃透react事件原理"><a href="#一文吃透react事件原理" class="header-anchor">#</a> 一文吃透react事件原理</h1> <blockquote><p><a href="https://mp.weixin.qq.com/s/LvzC74rlYZr4tSkFkxGAoA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/LvzC74rlYZr4tSkFkxGAoA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h1 id="一-前言"><a href="#一-前言" class="header-anchor">#</a> 一 前言</h1> <p>今天我们来一起探讨一下<code>React</code>事件原理，这篇文章，我尽量用通俗简洁的方式，把<code>React</code>事件系统讲的明明白白。</p> <p>我们讲的<code>react</code>版本是<code>16.13.1</code> , <code>v17</code>之后<code>react</code>对于事件系统会有相关的改版，文章后半部分会提及。</p> <p>老规矩，在正式讲解<code>react</code>之前，我们先想想这几个问题(<strong>如果我是面试官，你会怎么回答?</strong>)：</p> <ul><li>1 我们写的事件是绑定在<code>dom</code>上么，如果不是绑定在哪里？</li> <li>2 为什么我们的事件不能绑定给组件？</li> <li>3 为什么我们的事件手动绑定<code>this</code>(不是箭头函数的情况)</li> <li>4 为什么不能用 <code>return false</code>来阻止事件的默认行为？</li> <li>5 <code>react</code>怎么通过<code>dom</code>元素，找到与之对应的 <code>fiber</code>对象的？</li> <li>6 <code>onClick</code>是在冒泡阶段绑定的？那么<code>onClickCapture</code>就是在事件捕获阶段绑定的吗？</li></ul> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJvIa01mAsTNF4mZMy2fsSWicp4VEsdj7xeRuScjTEQHibLayphqpySHcA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">B7836791-2C40-48BA-83BF-835E0BD87B55.jpg</p> <h2 id="必要的知识概念"><a href="#必要的知识概念" class="header-anchor">#</a> 必要的知识概念</h2> <p>在弄清楚<code>react</code>事件之前，有几个概念我们必须弄清楚，因为只有弄明白这几个概念，在事件触发阶段，我们才能更好的理解<code>react</code>处理事件本质。</p> <h3 id="我们写在jsx事件终将变成什么"><a href="#我们写在jsx事件终将变成什么" class="header-anchor">#</a> 我们写在JSX事件终将变成什么？</h3> <p>我们先写一段含有点击事件的<code>react JSX</code>语法，看一下它最终会变成什么样子？</p> <div class="language- extra-class"><pre class="language-text"><code>class Index extends React.Component{
    handerClick= (value) =&gt; console.log(value) 
    render(){
        return &lt;div&gt;
            &lt;button onClick={ this.handerClick } &gt; 按钮点击 &lt;/button&gt;
        &lt;/div&gt;
    }
}
</code></pre></div><p>经过<code>babel</code>转换成<code>React.createElement</code>形式，如下：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJJahUR1Z33lpxmZbZib4mK2DRicjlHgbOKsyK3bLUkFrWENflaAlEYYMw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">babel.jpg</p> <p>最终转成<code>fiber</code>对象形式如下：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJJcMr48au9dvwHUoH3ffJoOafWib1iccEYTia9ACgl4oicV5nymeElxSlIw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">fiber.jpg</p> <p><code>fiber</code>对象上的<code>memoizedProps</code> 和 <code>pendingProps</code>保存了我们的事件。</p> <h3 id="什么是合成事件"><a href="#什么是合成事件" class="header-anchor">#</a> 什么是合成事件？</h3> <p>通过上一步我们看到了，我们声明事件保存的位置。但是事件有没有被真正的注册呢？我们接下来看一下：</p> <p>我们看一下当前这个元素<code>&lt;button&gt;</code>上有没有绑定这个事件监听器呢？</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJQMsySfXz8S6wKO34YK5wklp5RDib95E2u3eWX1ujVqzwD8x0ZWicsZpw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">button_event.jpg</p> <p><strong>button上绑定的事件</strong></p> <p>我们可以看到 ，<code>button</code>上绑定了两个事件，一个是<code>document</code>上的事件监听器，另外一个是<code>button</code>，但是事件处理函数<code>handle</code>，并不是我们的<code>handerClick</code>事件，而是<code>noop</code>。</p> <p><code>noop</code>是什么呢？我们接着来看。</p> <p>原来<code>noop</code>就指向一个空函数。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJfRAX3qRK8pNpjxOVC6uib66tzOEulItlCSKFicPkBlTyE0d2iauJViaKsQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">noop.jpg</p> <p><strong>然后我们看<code>document</code>绑定的事件</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJgEhMwxlpKicjWlgJRuxaK5xzHCsbP90Mhl3yNuQewwJpKdGbicZjyPqQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">document.jpg</p> <p>可以看到<code>click</code>事件被绑定在<code>document</code>上了。</p> <p>接下来我们再搞搞事情😂😂😂，在<code>demo</code>项目中加上一个<code>input</code>输入框，并绑定一个<code>onChange</code>事件。睁大眼睛看看接下来会发生什么？</p> <div class="language- extra-class"><pre class="language-text"><code>class Index extends React.Component{
    componentDidMount(){
        console.log(this)
    }
    handerClick= (value) =&gt; console.log(value) 
    handerChange=(value) =&gt; console.log(value)
    render(){
        return &lt;div style={{ marginTop:'50px' }} &gt;
            &lt;button onClick={ this.handerClick } &gt; 按钮点击 &lt;/button&gt;
            &lt;input  placeholder=&quot;请输入内容&quot; onChange={ this.handerChange }  /&gt;
        &lt;/div&gt;
    }
}
</code></pre></div><p><strong>我们先看一下<code>input dom</code>元素上绑定的事件</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJIe7R63IoYxJr2nfeMOuP1aia8DMEjCcGpVQ1rAw4GO3VJ3qNsQ33s8A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">22BEC470-233A-4C50-9C47-D21D343C055D.jpg</p> <p><strong>然后我们看一下<code>document</code>上绑定的事件</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJRaNQ4e0F8quv0u0UzSGOfokg9X9wKr0hsDfr3Q8qNgFnGwnXWBmcgA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">8E1D3BDB-ACFB-4E49-A5FF-CF990C47A60E.jpg</p> <p>我们发现，我们给<code>&lt;input&gt;</code>绑定的<code>onChange</code>，并没有直接绑定在<code>input</code>上，而是统一绑定在了<code>document</code>上，然后我们<code>onChange</code>被处理成很多事件监听器，比如<code>blur</code> , <code>change</code> , <code>input</code> , <code>keydown</code> , <code>keyup</code> 等。</p> <p>综上我们可以得出结论：</p> <ul><li>①<strong>我们在 <code>jsx</code> 中绑定的事件(demo中的<code>handerClick</code>，<code>handerChange</code>),根本就没有注册到真实的<code>dom</code>上。是绑定在<code>document</code>上统一管理的。</strong></li> <li>②<strong>真实的<code>dom</code>上的<code>click</code>事件被单独处理,已经被<code>react</code>底层替换成空函数。</strong></li> <li>③<strong>我们在<code>react</code>绑定的事件,比如<code>onChange</code>，在<code>document</code>上，可能有多个事件与之对应。</strong></li> <li>④ <strong><code>react</code>并不是一开始，把所有的事件都绑定在<code>document</code>上，而是采取了一种按需绑定，比如发现了<code>onClick</code>事件,再去绑定<code>document click</code>事件。</strong></li></ul> <p>那么什么是<code>react</code>事件合成呢？</p> <p><strong>在<code>react</code>中，我们绑定的事件<code>onClick</code>等，并不是原生事件，而是由原生事件合成的<code>React</code>事件，比如 <code>click</code>事件合成为<code>onClick</code>事件。比如<code>blur</code> , <code>change</code> , <code>input</code> , <code>keydown</code> , <code>keyup</code>等 , 合成为<code>onChange</code>。</strong></p> <p>那么<code>react</code>采取这种事件合成的模式呢？</p> <p>一方面，将事件绑定在<code>document</code>统一管理，防止很多事件直接绑定在原生的<code>dom</code>元素上。造成一些不可控的情况</p> <p>另一方面， <code>React</code> 想实现一个全浏览器的框架， 为了实现这种目标就需要提供全浏览器一致性的事件系统，以此抹平不同浏览器的差异。</p> <p>接下来的文章中，会介绍<code>react</code>是怎么做事件合成的。</p> <h3 id="dom元素对应的fiber-tag对象"><a href="#dom元素对应的fiber-tag对象" class="header-anchor">#</a> dom元素对应的fiber Tag对象</h3> <p>我们知道了<code>react</code>怎么储存了我们的事件函数和事件合成因果。接下来我想让大家记住一种类型的 <code>fiber</code> 对象,因为后面会用到，这对后续的理解很有帮助。</p> <p>我们先来看一个代码片段：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div&gt; 
  &lt;div&gt; hello , my name is alien &lt;/div&gt;
&lt;/div&gt;
</code></pre></div><p>看<code>&lt;div&gt; hello , my name is alien &lt;/div&gt;</code> 对应的 <code>fiber</code>类型。tag = 5</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJsTicvBiajJ0ESuicj1fB0S7UX7C1librMXJiaU5Bwk8g7qLF52MdHujsRmw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">然后我们去<code>react</code>源码中找到这种类的<code>fiber</code>类型。</p> <blockquote><p>/react-reconciler/src/ReactWorkTagsq.js</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>export const HostComponent = 5; // 元素节点
</code></pre></div><p>好的 ，我们暂且把 <code>HostComponent</code> 和 <code>HostText</code>记录📝下来。接下来回归正题，我们先来看看<code>react</code>事件合成机制。</p> <h1 id="二-事件初始化-事件合成-插件机制"><a href="#二-事件初始化-事件合成-插件机制" class="header-anchor">#</a> 二 事件初始化-事件合成，插件机制</h1> <p>接下来，我们来看一看<code>react</code>这么处理事件合成的。首先我们从上面我们知道，<code>react</code>并不是一次性把所有事件都<strong>绑定进去</strong>，而是如果发现项目中有<code>onClick</code>，才绑定<code>click</code>事件，发现有<code>onChange</code>事件，才绑定<code>blur</code> , <code>change</code> , <code>input</code> , <code>keydown</code> , <code>keyup</code>等。所以为了把原理搞的清清楚楚，笔者把事件原理分成三部分来搞定：</p> <ul><li>1 <code>react</code>对事件是如何合成的。</li> <li>2 <code>react</code>事件是怎么绑定的。</li> <li>3 <code>react</code>事件触发流程。</li></ul> <h2 id="事件合成-事件插件"><a href="#事件合成-事件插件" class="header-anchor">#</a> 事件合成-事件插件</h2> <h3 id="_1-必要概念"><a href="#_1-必要概念" class="header-anchor">#</a> 1 必要概念</h3> <p>我们先来看来几个常量关系，这对于我们吃透<code>react</code>事件原理很有帮助。在解析来的讲解中，我也会讲到这几个对象如何来的，具体有什么作用。</p> <h4 id="_1namestoplugins"><a href="#_1namestoplugins" class="header-anchor">#</a> ①namesToPlugins</h4> <p>第一个概念：<strong>namesToPlugins</strong> 装事件名 -&gt; 事件模块插件的映射,<code>namesToPlugins</code>最终的样子如下：</p> <div class="language- extra-class"><pre class="language-text"><code>const namesToPlugins = {
    SimpleEventPlugin,
    EnterLeaveEventPlugin,
    ChangeEventPlugin,
    SelectEventPlugin,
    BeforeInputEventPlugin,
}
</code></pre></div><p><code>SimpleEventPlugin</code>等是处理各个事件函数的插件，比如一次点击事件，就会找到<code>SimpleEventPlugin</code>对应的处理函数。我们先记录下它，至于具体有什么作用，接下来会讲到。</p> <h4 id="_2plugins"><a href="#_2plugins" class="header-anchor">#</a> ②plugins</h4> <p><code>plugins</code>，这个对象就是上面注册的所有插件列表,初始化为空。</p> <div class="language- extra-class"><pre class="language-text"><code>const  plugins = [LegacySimpleEventPlugin, LegacyEnterLeaveEventPlugin, ...];
</code></pre></div><h4 id="_3registrationnamemodules"><a href="#_3registrationnamemodules" class="header-anchor">#</a> ③registrationNameModules</h4> <p><code>registrationNameModules</code>记录了React合成的事件-对应的事件插件的关系，在<code>React</code>中，处理<code>props</code>中事件的时候，会根据不同的事件名称，找到对应的事件插件，然后统一绑定在<code>document</code>上。对于没有出现过的事件，就不会绑定，我们接下来会讲到。<code>registrationNameModules</code>大致的样子如下所示。</p> <div class="language- extra-class"><pre class="language-text"><code>{
    onBlur: SimpleEventPlugin,
    onClick: SimpleEventPlugin,
    onClickCapture: SimpleEventPlugin,
    onChange: ChangeEventPlugin,
    onChangeCapture: ChangeEventPlugin,
    onMouseEnter: EnterLeaveEventPlugin,
    onMouseLeave: EnterLeaveEventPlugin,
    ...
}
</code></pre></div><h4 id="_4事件插件"><a href="#_4事件插件" class="header-anchor">#</a> ④事件插件</h4> <p>那么我们首先就要搞清楚，<code>SimpleEventPlugin</code>,<code>EnterLeaveEventPlugin</code>每个插件都是什么？我们拿<code>SimpleEventPlugin</code>为例，看一下它究竟是什么样子？</p> <div class="language- extra-class"><pre class="language-text"><code>const SimpleEventPlugin = {
    eventTypes:{ 
        'click':{ /* 处理点击事件  */
            phasedRegistrationNames:{
                bubbled: 'onClick',       // 对应的事件冒泡 - onClick 
                captured:'onClickCapture' //对应事件捕获阶段 - onClickCapture
            },
            dependencies: ['click'], //事件依赖
            ...
        },
        'blur':{ /* 处理失去焦点事件 */ },
        ...
    }
    extractEvents:function(topLevelType,targetInst,){ /* eventTypes 里面的事件对应的统一事件处理函数，接下来会重点讲到 */ }
}
</code></pre></div><p>首先事件插件是一个对象，有两个属性，第一个<code>extractEvents</code>作为事件统一处理函数，第二个<code>eventTypes</code>是一个对象，对象保存了原生事件名和对应的配置项<code>dispatchConfig</code>的映射关系。由于v16React的事件是统一绑定在<code>document</code>上的，React用独特的事件名称比如<code>onClick</code>和<code>onClickCapture</code>，来说明我们给绑定的函数到底是在冒泡事件阶段，还是捕获事件阶段执行。</p> <h4 id="_5-registrationnamedependencies"><a href="#_5-registrationnamedependencies" class="header-anchor">#</a> ⑤ registrationNameDependencies</h4> <p><code>registrationNameDependencies</code>用来记录，合成事件比如 <code>onClick</code> 和原生事件 <code>click</code>对应关系。比如 <code>onChange</code> 对应 <code>change</code> , <code>input</code> , <code>keydown</code> , <code>keyup</code>事件。</p> <div class="language- extra-class"><pre class="language-text"><code>{
    onBlur: ['blur'],
    onClick: ['click'],
    onClickCapture: ['click'],
    onChange: ['blur', 'change', 'click', 'focus', 'input', 'keydown', 'keyup', 'selectionchange'],
    onMouseEnter: ['mouseout', 'mouseover'],
    onMouseLeave: ['mouseout', 'mouseover'],
    ...
}
</code></pre></div><h3 id="_2-事件初始化"><a href="#_2-事件初始化" class="header-anchor">#</a> 2 事件初始化</h3> <p>对于事件合成，<code>v16.13.1</code>版本<code>react</code>采用了初始化注册方式。</p> <blockquote><p>react-dom/src/client/ReactDOMClientInjection.js</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>/* 第一步：注册事件：  */
injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin,
});
</code></pre></div><p><code>injectEventPluginsByName</code> 这个函数具体有什么用呢，它在<code>react</code>底层是默认执行的。我们来简化这个函数,看它到底是干什么的。</p> <blockquote><p>legacy-event/EventPluginRegistry.js</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>/* 注册事件插件 */
export function injectEventPluginsByName(injectedNamesToPlugins){
     for (const pluginName in injectedNamesToPlugins) {
         namesToPlugins[pluginName] = injectedNamesToPlugins[pluginName]
     }
     recomputePluginOrdering()
}
</code></pre></div><p><code>injectEventPluginsByName</code>做的事情很简单，形成上述的<code>namesToPlugins</code>，然后执行<code>recomputePluginOrdering</code>，我们接下来看一下<code>recomputePluginOrdering</code>做了写什么？</p> <div class="language- extra-class"><pre class="language-text"><code>const eventPluginOrder = [ 'SimpleEventPlugin' , 'EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin' , 'BeforeInputEventPlugin' ]

function recomputePluginOrdering(){
    for (const pluginName in namesToPlugins) {
        /* 找到对应的事件处理插件，比如 SimpleEventPlugin  */
        const pluginModule = namesToPlugins[pluginName];
        const pluginIndex = eventPluginOrder.indexOf(pluginName);
        /* 填充 plugins 数组  */
        plugins[pluginIndex] = pluginModule;
    }

    const publishedEvents = pluginModule.eventTypes;
    for (const eventName in publishedEvents) {
       // publishedEvents[eventName] -&gt; eventConfig , pluginModule -&gt; 事件插件 ， eventName -&gt; 事件名称
        publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName,)
    } 
}
】
</code></pre></div><p><strong>recomputePluginOrdering</strong>,作用很明确了，形成上面说的那个<code>plugins</code>,数组。然后就是<strong>重点的函数<code>publishEventForPlugin</code></strong>。</p> <div class="language- extra-class"><pre class="language-text"><code>/*
  dispatchConfig -&gt; 原生事件对应配置项 { phasedRegistrationNames :{  冒泡 捕获  } ，   }
  pluginModule -&gt; 事件插件 比如SimpleEventPlugin  
  eventName -&gt; 原生事件名称。
*/
function publishEventForPlugin (dispatchConfig,pluginModule,eventName){
    eventNameDispatchConfigs[eventName] = dispatchConfig;
    /* 事件 */
    const phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
    if (phasedRegistrationNames) {
    for (const phaseName in phasedRegistrationNames) {
        if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            // phasedRegistrationName React事件名 比如 onClick / onClickCapture
            const phasedRegistrationName = phasedRegistrationNames[phaseName];
            // 填充形成 registrationNameModules React 合成事件 -&gt; React 处理事件插件映射关系
            registrationNameModules[phasedRegistrationName] = pluginModule;
            // 填充形成 registrationNameDependencies React 合成事件 -&gt; 原生事件 映射关系
            registrationNameDependencies[phasedRegistrationName] = pluginModule.eventTypes[eventName].dependencies;
        }
    }
    return true;
    }
}
</code></pre></div><p><code>publishEventForPlugin</code> 作用形成上述的 <strong><code>registrationNameModules</code></strong> 和 <strong><code>registrationNameDependencies</code></strong> 对象中的映射关系。</p> <h3 id="_3-事件合成总结"><a href="#_3-事件合成总结" class="header-anchor">#</a> 3 事件合成总结</h3> <p>到这里整个初始化阶段已经完事了，我来总结一下初始化事件合成都做了些什么。这个阶段主要形成了上述的几个重要对象，构建初始化React合成事件和原生事件的对应关系，合成事件和对应的事件处理插件关系。接下来就是事件绑定阶段。</p> <h1 id="三-事件绑定-从一次点击事件开始"><a href="#三-事件绑定-从一次点击事件开始" class="header-anchor">#</a> 三 事件绑定-从一次点击事件开始</h1> <h2 id="事件绑定流程"><a href="#事件绑定流程" class="header-anchor">#</a> 事件绑定流程</h2> <p>如果我们在一个组件中这么写一个点击事件，<code>React</code>会一步步如何处理。</p> <h3 id="_1-diffproperties-处理react合成事件"><a href="#_1-diffproperties-处理react合成事件" class="header-anchor">#</a> 1 diffProperties 处理React合成事件</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;div&gt;
  &lt;button onClick={ this.handerClick }  className=&quot;button&quot; &gt;点击&lt;/button&gt;
&lt;/div&gt;
</code></pre></div><p>第一步，首先通过上面的讲解，我们绑定给hostComponent种类的fiber(如上的button元素)，会 <code>button</code> 对应的fiber上，以<code>memoizedProps</code> 和 <code>pendingProps</code>形成保存。</p> <div class="language- extra-class"><pre class="language-text"><code>button 对应 fiber
memoizedProps = {
   onClick:function handerClick(){},
   className:'button'
}
</code></pre></div><p>结构图如下所示：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">58E6A4AF-1902-42BC-9D11-B47234037E01.jpg</p> <p>第二步，React在调合子节点后，进入diff阶段，如果判断是<code>HostComponent</code>(dom元素)类型的fiber，会用diff props函数<code>diffProperties</code>单独处理。</p> <blockquote><p>react-dom/src/client/ReactDOMComponent.js</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function diffProperties(){
    /* 判断当前的 propKey 是不是 React合成事件 */
    if(registrationNameModules.hasOwnProperty(propKey)){
         /* 这里多个函数简化了，如果是合成事件， 传入成事件名称 onClick ，向document注册事件  */
         legacyListenToEvent(registrationName, document）;
    }
}
</code></pre></div><p><code>diffProperties</code>函数在 <code>diff props</code> 如果发现是合成事件(<code>onClick</code>) 就会调用<code>legacyListenToEvent</code>函数。注册事件监听器。</p> <h3 id="_2-legacylistentoevent-注册事件监听器"><a href="#_2-legacylistentoevent-注册事件监听器" class="header-anchor">#</a> 2 legacyListenToEvent 注册事件监听器</h3> <blockquote><p>react-dom/src/events/DOMLegacyEventPluginSystem.js</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>//  registrationName -&gt; onClick 事件
//  mountAt -&gt; document or container
function legacyListenToEvent(registrationName，mountAt){
   const dependencies = registrationNameDependencies[registrationName]; // 根据 onClick 获取  onClick 依赖的事件数组 [ 'click' ]。
    for (let i = 0; i &lt; dependencies.length; i++) {
    const dependency = dependencies[i];
    //这个经过多个函数简化，如果是 click 基础事件，会走 legacyTrapBubbledEvent ,而且都是按照冒泡处理
     legacyTrapBubbledEvent(dependency, mountAt);
  }
}
</code></pre></div><p>legacyTrapBubbledEvent 就是执行将绑定真正的dom事件的函数 legacyTrapBubbledEvent(冒泡处理)。</p> <div class="language- extra-class"><pre class="language-text"><code>function legacyTrapBubbledEvent(topLevelType,element){
   addTrappedEventListener(element,topLevelType,PLUGIN_EVENT_SYSTEM,false)
}
</code></pre></div><p>第三步：在<code>legacyListenToEvent</code>函数中，先找到 <code>React</code> 合成事件对应的原生事件集合，比如 onClick -&gt; ['click'] , onChange -&gt; [<code>blur</code> , <code>change</code> , <code>input</code> , <code>keydown</code> , <code>keyup</code>]，然后遍历依赖项的数组，绑定事件，<strong>这就解释了，为什么我们在刚开始的demo中，只给元素绑定了一个<code>onChange</code>事件，结果在<code>document</code>上出现很多事件监听器的原因，就是在这个函数上处理的。</strong></p> <p>我们上面已经透露了React是采用事件绑定，<code>React</code> 对于 <code>click</code> 等基础事件，会默认按照事件冒泡阶段的事件处理，<strong>不过这也不绝对的，比如一些事件的处理，有些特殊的事件是按照事件捕获处理的。</strong></p> <div class="language- extra-class"><pre class="language-text"><code>case TOP_SCROLL: {                                // scroll 事件
    legacyTrapCapturedEvent(TOP_SCROLL, mountAt); // legacyTrapCapturedEvent 事件捕获处理。
    break;
}
case TOP_FOCUS: // focus 事件
case TOP_BLUR:  // blur 事件
legacyTrapCapturedEvent(TOP_FOCUS, mountAt);
legacyTrapCapturedEvent(TOP_BLUR, mountAt);
break;
</code></pre></div><h3 id="_3-绑定-dispatchevent-进行事件监听"><a href="#_3-绑定-dispatchevent-进行事件监听" class="header-anchor">#</a> 3 绑定 dispatchEvent，进行事件监听</h3> <p>如上述的<code>scroll</code>事件，<code>focus</code> 事件 ，<code>blur</code>事件等，是默认按照事件捕获逻辑处理。接下来就是最重要关键的一步。React是如何绑定事件到<code>document</code>？事件处理函数函数又是什么？问题都指向了上述的<code>addTrappedEventListener</code>，让我们来揭开它的面纱。</p> <div class="language- extra-class"><pre class="language-text"><code>/*
  targetContainer -&gt; document
  topLevelType -&gt;  click
  capture = false
*/
function addTrappedEventListener(targetContainer,topLevelType,eventSystemFlags,capture){
   const listener = dispatchEvent.bind(null,topLevelType,eventSystemFlags,targetContainer) 
   if(capture){
       // 事件捕获阶段处理函数。
   }else{
       /* TODO: 重要, 这里进行真正的事件绑定。*/
      targetContainer.addEventListener(topLevelType,listener,false) // document.addEventListener('click',listener,false)
   }
}
</code></pre></div><p>第四步：这个函数内容虽然不多，但是却非常重要,首先绑定我们的事件统一处理函数 <code>dispatchEvent</code>，绑定几个默认参数，事件类型 <code>topLevelType</code> demo中的<code>click</code> ，还有绑定的容器<code>doucment</code>。<strong>然后真正的事件绑定,添加事件监听器<code>addEventListener</code>。</strong> 事件绑定阶段完毕。</p> <h3 id="_4-事件绑定过程总结"><a href="#_4-事件绑定过程总结" class="header-anchor">#</a> 4 事件绑定过程总结</h3> <p>我们来做一下事件绑定阶段的总结。</p> <ul><li>① 在React，diff DOM元素类型的fiber的props的时候， 如果发现是React合成事件，比如<code>onClick</code>，会按照事件系统逻辑单独处理。</li> <li>② 根据React合成事件类型，找到对应的原生事件的类型，然后调用判断原生事件类型，大部分事件都按照冒泡逻辑处理，少数事件会按照捕获逻辑处理（比如<code>scroll</code>事件）。</li> <li>③ 调用 addTrappedEventListener 进行真正的事件绑定，绑定在<code>document</code>上，<code>dispatchEvent</code> 为统一的事件处理函数。</li> <li>④ <strong>有一点值得注意: 只有上述那几个特殊事件比如 <code>scorll</code>,<code>focus</code>,<code>blur</code>等是在事件捕获阶段发生的，其他的都是在事件冒泡阶段发生的，无论是<code>onClick</code>还是<code>onClickCapture</code>都是发生在冒泡阶段</strong>，至于 React 本身怎么处理捕获逻辑的。我们接下来会讲到。</li></ul> <h1 id="四-事件触发-一次点击事件-在react底层系统会发生什么"><a href="#四-事件触发-一次点击事件-在react底层系统会发生什么" class="header-anchor">#</a> 四 事件触发-一次点击事件，在<code>react</code>底层系统会发生什么？</h1> <div class="language- extra-class"><pre class="language-text"><code>&lt;div&gt;
  &lt;button onClick={ this.handerClick }  className=&quot;button&quot; &gt;点击&lt;/button&gt;
&lt;/div&gt;
</code></pre></div><p>还是上面这段代码片段，当点击一下按钮，在 <code>React</code> 底层会发生什么呢？接下来，让我共同探索事件触发的奥秘。</p> <h2 id="事件触发处理函数-dispatchevent"><a href="#事件触发处理函数-dispatchevent" class="header-anchor">#</a> 事件触发处理函数 dispatchEvent</h2> <p>我们在事件绑定阶段讲过，React事件注册时候，统一的监听器<code>dispatchEvent</code>，也就是当我们<strong>点击按钮之后，首先执行的是<code>dispatchEvent</code>函数</strong>，因为<code>dispatchEvent</code>前三个参数已经被bind了进去，所以真正的事件源对象<code>event</code>，被默认绑定成第四个参数。</p> <blockquote><p>react-dom/src/events/ReactDOMEventListener.js</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function dispatchEvent(topLevelType,eventSystemFlags,targetContainer,nativeEvent){
    /* 尝试调度事件 */
    const blockedOn = attemptToDispatchEvent( topLevelType,eventSystemFlags, targetContainer, nativeEvent);
}
/*
topLevelType -&gt; click
eventSystemFlags -&gt; 1
targetContainer -&gt; document
nativeEvent -&gt; 原生事件的 event 对象
*/
function attemptToDispatchEvent(topLevelType,eventSystemFlags,targetContainer,nativeEvent){
    /* 获取原生事件 e.target */
    const nativeEventTarget = getEventTarget(nativeEvent)
    /* 获取当前事件，最近的dom类型fiber ，我们 demo中 button 按钮对应的 fiber */
    let targetInst = getClosestInstanceFromNode(nativeEventTarget); 
    /* 重要：进入legacy模式的事件处理系统 */
    dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,targetInst,);
    return null;
}
</code></pre></div><p>在这个阶段主要做了这几件事：</p> <ul><li>① 首先根据真实的事件源对象，找到 <code>e.target</code> 真实的 <code>dom</code> 元素。</li> <li>② 然后根据<code>dom</code>元素，找到与它对应的 <code>fiber</code> 对象<code>targetInst</code>，在我们 <code>demo</code> 中，找到 <code>button</code> 按钮对应的 <code>fiber</code>。</li> <li>③ 然后正式进去<code>legacy</code>模式的事件处理系统，也就是我们目前用的React模式都是<code>legacy</code>模式下的，在这个模式下，批量更新原理，即将拉开帷幕。</li></ul> <p>这里有一点问题，<strong><code>React</code>怎么样通过原生的<code>dom</code>元素，找到对应的<code>fiber</code>的呢？</strong> ，也就是说 <code>getClosestInstanceFromNode</code> 原理是什么？</p> <p>答案是首先 <code>getClosestInstanceFromNode</code> 可以找到当前传入的 <code>dom</code> 对应的最近的元素类型的 <code>fiber</code> 对象。<code>React</code> 在初始化真实 <code>dom</code> 的时候，用一个随机的 <code>key internalInstanceKey</code> 指针指向了当前<code>dom</code>对应的<code>fiber</code>对象，<code>fiber</code>对象用<code>stateNode</code>指向了当前的<code>dom</code>元素。</p> <div class="language- extra-class"><pre class="language-text"><code>// 声明随机key
var internalInstanceKey = '__reactInternalInstance$' + randomKey;

// 使用随机key 
function getClosestInstanceFromNode(targetNode){
  // targetNode -dom  targetInst -&gt; 与之对应的fiber对象
  var targetInst = targetNode[internalInstanceKey];
}
</code></pre></div><p><strong>在谷歌调试器上看</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">fiber_dom.jpg</p> <p><strong>两者关系图</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">dom_fiber.jpg</p> <h2 id="legacy-事件处理系统与批量更新"><a href="#legacy-事件处理系统与批量更新" class="header-anchor">#</a> legacy 事件处理系统与批量更新</h2> <blockquote><p>react-dom/src/events/DOMLegacyEventPluginSystem.js</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>/* topLevelType - click事件 ｜ eventSystemFlags = 1 ｜ nativeEvent = 事件源对象  ｜ targetInst = 元素对应的fiber对象  */
function dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,targetInst){
    /* 从React 事件池中取出一个，将 topLevelType ，targetInst 等属性赋予给事件  */
    const bookKeeping = getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst,eventSystemFlags);
    try { /* 执行批量更新 handleTopLevel 为事件处理的主要函数 */
    batchedEventUpdates(handleTopLevel, bookKeeping);
  } finally {
    /* 释放事件池 */  
    releaseTopLevelCallbackBookKeeping(bookKeeping);
  }
}
</code></pre></div><p>对于v16事件池，我们接下来会讲到，首先 <code>batchedEventUpdates</code>为批量更新的主要函数。我们先来看看<code>batchedEventUpdates</code></p> <blockquote><p>react-dom/src/events/ReactDOMUpdateBatching.js</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>export function batchedEventUpdates(fn,a){
    isBatchingEventUpdates = true;
    try{
       fn(a) // handleTopLevel(bookKeeping)
    }finally{
        isBatchingEventUpdates = false
    }
}
</code></pre></div><p>批量更新简化成如上的样子，从上面我们可以看到，React通过开关<code>isBatchingEventUpdates</code>来控制是否启用批量更新。<code>fn(a)</code>，事件上调用的是 <code>handleTopLevel(bookKeeping)</code>，由于js是单线程的，我们真正在组件中写的事件处理函数，比如demo 的 <code>handerClick</code>实际执行是在<code>handleTopLevel(bookKeeping)</code>中执行的。所以如果我们在<code>handerClick</code>里面触发<code>setState</code>，那么就能读取到<code>isBatchingEventUpdates = true</code>这就是React的合成事件为什么具有批量更新的功能了。比如我们这么写</p> <div class="language- extra-class"><pre class="language-text"><code>state={number:0}
handerClick = () =&gt;{
    this.setState({number: this.state.number + 1   })
    console.log(this.state.number) //0
    this.setState({number: this.state.number + 1   })
    console.log(this.state.number) //0
    setTimeout(()=&gt;{
        this.setState({number: this.state.number + 1   })
        console.log(this.state.number) //2
        this.setState({number: this.state.number + 1   })
        console.log(this.state.number)// 3
    })
}
</code></pre></div><p>如上述所示，第一个<code>setState</code>和第二个<code>setState</code>在批量更新条件之内执行，所以打印不会是最新的值，但是如果是发生在<code>setTimeout</code>中,由于eventLoop 放在了下一次事件循环中执行，此时 batchedEventUpdates 中已经执行完<code>isBatchingEventUpdates = false</code>，所以批量更新被打破，我们就可以直接访问到最新变化的值了。</p> <p>接下来我们有两点没有梳理：</p> <ul><li>一是React事件池概念</li> <li>二是最后的线索是执行<code>handleTopLevel(bookKeeping)</code>，那么<code>handleTopLevel</code>到底做了写什么。</li></ul> <h2 id="执行事件插件函数"><a href="#执行事件插件函数" class="header-anchor">#</a> 执行事件插件函数</h2> <p>上面说到整个事件系统，最后指向函数 <code>handleTopLevel(bookKeeping)</code> 那么 <code>handleTopLevel</code> 到底做了什么事情？</p> <div class="language- extra-class"><pre class="language-text"><code>// 流程简化后
// topLevelType - click  
// targetInst - button Fiber
// nativeEvent
function handleTopLevel(bookKeeping){
    const { topLevelType,targetInst,nativeEvent,eventTarget, eventSystemFlags} = bookKeeping
    for(let i=0; i &lt; plugins.length;i++ ){
        const possiblePlugin = plugins[i];
        /* 找到对应的事件插件，形成对应的合成event，形成事件执行队列  */
        const  extractedEvents = possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,eventTarget,eventSystemFlags)  
    }
    if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
    }
    /* 执行事件处理函数 */
    runEventsInBatch(events);
}
</code></pre></div><p>我把整个流程简化，只保留了核心的流程，<code>handleTopLevel</code>最后的处理逻辑就是执行我们说的事件处理插件(SimpleEventPlugin)中的处理函数<code>extractEvents</code>，比如我们demo中的点击事件 onClick 最终走的就是 <code>SimpleEventPlugin</code> 中的 <code>extractEvents</code> 函数，那么React为什么这么做呢? 我们知道我们React是采取事件合成，事件统一绑定，并且我们写在组件中的事件处理函数( handerClick )，也不是真正的执行函数<code>dispatchAciton</code>，那么我们在<code>handerClick</code>的事件对象 <code>event</code>,也是React单独合成处理的，里面单独封装了比如 <code>stopPropagation</code>和<code>preventDefault</code>等方法，<strong>这样的好处是，我们不需要跨浏览器单独处理兼容问题，交给React底层统一处理。</strong></p> <h2 id="extractevents-形成事件对象event-和-事件处理函数队列"><a href="#extractevents-形成事件对象event-和-事件处理函数队列" class="header-anchor">#</a> extractEvents 形成事件对象event 和 事件处理函数队列</h2> <p><strong>重点来了！重点来了！重点来了！</strong>，extractEvents 可以作为整个事件系统核心函数，我们先回到最初的<code>demo</code>，如果我们这么写,那么四个回调函数，那么点击按钮，四个事件是如何处理的呢。首先如果点击按钮，最终走的就是<code>extractEvents</code>函数，一探究竟这个函数。</p> <blockquote><p>legacy-events/SyntheticEvent.js</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const  SimpleEventPlugin = {
    extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){
        const dispatchConfig = topLevelEventsToDispatchConfig.get(topLevelType);
        if (!dispatchConfig) {
            return null;
        }
        switch(topLevelType){
            default:
            EventConstructor = SyntheticEvent;
            break;
        }
        /* 产生事件源对象 */
        const event = EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget)
        const phasedRegistrationNames = event.dispatchConfig.phasedRegistrationNames;
        const dispatchListeners = [];
        const {bubbled, captured} = phasedRegistrationNames; /* onClick / onClickCapture */
        const dispatchInstances = [];
        /* 从事件源开始逐渐向上，查找dom元素类型HostComponent对应的fiber ，收集上面的React合成事件，onClick / onClickCapture  */
         while (instance !== null) {
              const {stateNode, tag} = instance;
              if (tag === HostComponent &amp;&amp; stateNode !== null) { /* DOM 元素 */
                   const currentTarget = stateNode;
                   if (captured !== null) { /* 事件捕获 */
                        /* 在事件捕获阶段,真正的事件处理函数 */
                        const captureListener = getListener(instance, captured);
                        if (captureListener != null) {
                        /* 对应发生在事件捕获阶段的处理函数，逻辑是将执行函数unshift添加到队列的最前面 */
                            dispatchListeners.unshift(captureListener);
                            dispatchInstances.unshift(instance);
                            dispatchCurrentTargets.unshift(currentTarget);
                        }
                    }
                    if (bubbled !== null) { /* 事件冒泡 */
                        /* 事件冒泡阶段，真正的事件处理函数，逻辑是将执行函数push到执行队列的最后面 */
                        const bubbleListener = getListener(instance, bubbled);
                        if (bubbleListener != null) {
                            dispatchListeners.push(bubbleListener);
                            dispatchInstances.push(instance);
                            dispatchCurrentTargets.push(currentTarget);
                        }
                    }
              }
              instance = instance.return;
         }
          if (dispatchListeners.length &gt; 0) {
              /* 将函数执行队列，挂到事件对象event上 */
            event._dispatchListeners = dispatchListeners;
            event._dispatchInstances = dispatchInstances;
            event._dispatchCurrentTargets = dispatchCurrentTargets;
         }
        return event
    }
}
</code></pre></div><p>事件插件系统的核心<code>extractEvents</code>主要做的事是:</p> <ul><li>① 首先形成<code>React</code>事件独有的合成事件源对象，这个对象，保存了整个事件的信息。将作为参数传递给真正的事件处理函数(handerClick)。</li> <li>② 然后声明事件执行队列 ，按照<code>冒泡</code>和<code>捕获</code>逻辑，从事件源开始逐渐向上，查找dom元素类型HostComponent对应的fiber ，收集上面的 <code>React</code> 合成事件，例如 <code>onClick</code> / <code>onClickCapture</code> ，对于冒泡阶段的事件(<code>onClick</code>)，将 <code>push</code> 到执行队列后面 ， 对于捕获阶段的事件(<code>onClickCapture</code>)，将 <code>unShift</code>到执行队列的前面。</li> <li>③ 最后将事件执行队列，保存到React事件源对象上。等待执行。</li></ul> <p>举个例子比如如下</p> <div class="language- extra-class"><pre class="language-text"><code>handerClick = () =&gt; console.log(1)
handerClick1 = () =&gt; console.log(2)
handerClick2 = () =&gt; console.log(3) 
handerClick3= () =&gt; console.log(4)
render(){
    return &lt;div onClick={ this.handerClick2 } onClickCapture={this.handerClick3}  &gt; 
        &lt;button onClick={ this.handerClick }  onClickCapture={ this.handerClick1  }  className=&quot;button&quot; &gt;点击&lt;/button&gt;
    &lt;/div&gt;
}
</code></pre></div><p>打印 // 4  2  1  3</p> <p>看到这里我们应该知道上述函数打印顺序为什么了吧，首先遍历 <code>button</code> 对应的fiber，首先遇到了 <code>onClickCapture</code> ,将 <code>handerClick1</code> 放到了数组最前面，然后又把<code>onClick</code>对应<code>handerClick</code>的放到数组的最后面，形成的结构是<code>[ handerClick1 , handerClick ]</code>， 然后向上遍历，遇到了<code>div</code>对应fiber,将<code>onClickCapture</code>对应的<code>handerClick3</code>放在了数组前面，将<code>onClick</code>对应的 <code>handerClick2</code> 放在了数组后面，形成的结构 <code>[ handerClick3,handerClick1 , handerClick,handerClick2 ]</code> ,所以执行的顺序 // 4  2  1  3，就是这么简单，完美！</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">FDEBA681-2E03-420B-A838-5907439837A9.jpg</p> <h2 id="事件触发"><a href="#事件触发" class="header-anchor">#</a> 事件触发</h2> <p>有的同学可能好奇React的事件源对象是什么样的，以上面代码中<code>SyntheticEvent</code>为例子我们一起来看看：</p> <blockquote><p>legacy-events/SyntheticEvent.js/</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function SyntheticEvent( dispatchConfig,targetInst,nativeEvent,nativeEventTarget){
  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;
  this._dispatchListeners = null;
  this._dispatchInstances = null;
  this._dispatchCurrentTargets = null;
  this.isPropagationStopped = () =&gt; false; /* 初始化，返回为false  */

}
SyntheticEvent.prototype={
    stopPropagation(){ this.isPropagationStopped = () =&gt; true;  }, /* React单独处理，阻止事件冒泡函数 */
    preventDefault(){ },  /* React单独处理，阻止事件捕获函数  */
    ...
}
</code></pre></div><p>在 <code>handerClick</code> 中打印 <code>e</code> :</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">B9180401-93FF-4EF0-A2FB-C2FA43B29550.jpg</p> <p>既然事件执行队列和事件源对象都形成了，接下来就是最后一步<strong>事件触发</strong>了。上面大家有没有注意到一个函数<code>runEventsInBatch</code>，所有事件绑定函数，就是在这里触发的。让我们一起看看。</p> <blockquote><p>legacy-events/EventBatching.js</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function runEventsInBatch(){
    const dispatchListeners = event._dispatchListeners;
    const dispatchInstances = event._dispatchInstances;
    if (Array.isArray(dispatchListeners)) {
    for (let i = 0; i &lt; dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) { /* 判断是否已经阻止事件冒泡 */
        break;
      }
      
      dispatchListeners[i](event)
    }
  }
  /* 执行完函数，置空两字段 */
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}
</code></pre></div><p><code>dispatchListeners[i](event)</code>就是执行我们的事件处理函数比如<code>handerClick</code>,从这里我们知道，<strong>我们在事件处理函数中，返回 false ，并不会阻止浏览器默认行为</strong>。</p> <div class="language- extra-class"><pre class="language-text"><code>handerClick(){ //并不能阻止浏览器默认行为。
    return false
}
</code></pre></div><p>应该改成这样：</p> <div class="language- extra-class"><pre class="language-text"><code>handerClick(e){
    e.preventDefault()
}
</code></pre></div><p>另一方面React对于阻止冒泡，就是通过isPropagationStopped，判断是否已经阻止事件冒泡。如果我们在事件函数执行队列中，某一会函数中，调用<code>e.stopPropagation()</code>，就会赋值给<code>isPropagationStopped=()=&gt;true</code>，当再执行 <code>e.isPropagationStopped()</code>就会返回 <code>true</code> ,接下来事件处理函数，就不会执行了。</p> <h2 id="其他概念-事件池"><a href="#其他概念-事件池" class="header-anchor">#</a> 其他概念-事件池</h2> <div class="language- extra-class"><pre class="language-text"><code> handerClick = (e) =&gt; {
    console.log(e.target) // button 
    setTimeout(()=&gt;{
        console.log(e.target) // null
    },0)
}
</code></pre></div><p>对于一次点击事件的处理函数，在正常的函数执行上下文中打印<code>e.target</code>就指向了<code>dom</code>元素，但是在<code>setTimeout</code>中打印却是<code>null</code>，如果这不是React事件系统，两次打印的应该是一样的，但是为什么两次打印不一样呢？<strong>因为在React采取了一个事件池的概念，每次我们用的事件源对象，在事件函数执行之后，可以通过<code>releaseTopLevelCallbackBookKeeping</code>等方法将事件源对象释放到事件池中，这样的好处每次我们不必再创建事件源对象，可以从事件池中取出一个事件源对象进行复用，在事件处理函数执行完毕后,会释放事件源到事件池中，清空属性，这就是<code>setTimeout</code>中打印为什么是<code>null</code>的原因了。</strong></p> <h2 id="事件触发总结"><a href="#事件触发总结" class="header-anchor">#</a> 事件触发总结</h2> <p>我把事件触发阶段做的事总结一下：</p> <ul><li><strong>①首先通过统一的事件处理函数 <code>dispatchEvent</code>,进行批量更新batchUpdate。</strong></li> <li><strong>②然后执行事件对应的处理插件中的<code>extractEvents</code>，合成事件源对象,每次React会从事件源开始，从上遍历类型为 hostComponent即 dom类型的fiber,判断props中是否有当前事件比如onClick,最终形成一个事件执行队列，React就是用这个队列，来模拟事件捕获-&gt;事件源-&gt;事件冒泡这一过程。</strong></li> <li><strong>③最后通过<code>runEventsInBatch</code>执行事件队列，如果发现阻止冒泡，那么break跳出循环，最后重置事件源，放回到事件池中，完成整个流程。</strong></li></ul> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">evnent_click.jpg</p> <h1 id="五-关于react-v17版本的事件系统"><a href="#五-关于react-v17版本的事件系统" class="header-anchor">#</a> 五 关于react v17版本的事件系统</h1> <p>React v17 整体改动不是很大，但是事件系统的改动却不小，首先上述的很多执行函数，在v17版本不复存在了。我来简单描述一下v17事件系统的改版。</p> <p><strong>1 事件统一绑定container上，ReactDOM.render(app， container);而不是document上，这样好处是有利于微前端的，微前端一个前端系统中可能有多个应用，如果继续采取全部绑定在<code>document</code>上，那么可能多应用下会出现问题。</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">react_17_delegation.png</p> <p><strong>2 对齐原生浏览器事件</strong></p> <p><code>React 17</code>中终于支持了原生捕获事件的支持， 对齐了浏览器原生标准。同时 <code>onScroll</code> 事件不再进行事件冒泡。<code>onFocus</code> 和 <code>onBlur</code> 使用原生 <code>focusin</code>， <code>focusout</code> 合成。</p> <p><strong>3 取消事件池</strong><code>React 17</code>取消事件池复用，也就解决了上述在<code>setTimeout</code>打印，找不到<code>e.target</code>的问题。</p> <h1 id="六-总结"><a href="#六-总结" class="header-anchor">#</a> 六 总结</h1> <p>本文从<strong>事件合成</strong>，<strong>事件绑定</strong>，<strong>事件触发</strong>三个方面详细介绍了React事件系统原理，希望大家能通过这篇文章更加深入了解v16 React 事件系统，如果有疑问和不足之处，也希望大家能在评论区指出。</p> <p>最后, 送人玫瑰，手留余香，觉得有收获的朋友可以给笔者<strong>点赞，关注</strong>一波 ，陆续更新前端超硬核文章。</p> <p>提前透漏：接下来会出一部揭秘<code>react</code>调度系统的文章。感兴趣的同学请关注公众号 <strong>前端Sharing</strong> 第一时间更新前端硬文。</p> <h2 id="往期react文章"><a href="#往期react文章" class="header-anchor">#</a> 往期react文章</h2> <p><strong>React进阶系列</strong></p> <p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MjMxMzY5Mw==&amp;mid=2247484812&amp;idx=1&amp;sn=d38f85074461912dfd53d5afb2a73646&amp;chksm=cfc14cbef8b6c5a81095205f9f82c4b308455f36d261743807b3361e1d1fd5c612a25aaeca68&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">「React进阶」 React全部api解读+基础实践大全(夯实基础万字总结)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MjMxMzY5Mw==&amp;mid=2247484634&amp;idx=1&amp;sn=618673960ee73b55df82efe886fd6cdd&amp;chksm=cfc14de8f8b6c4fed909929339dd7ed4092af462de88150767173baea4a7fcb3e3ed501daefd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">「react进阶」一文吃透react-hooks原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MjMxMzY5Mw==&amp;mid=2247484613&amp;idx=1&amp;sn=c97b435638d9b21c8869d4e51e3a295a&amp;chksm=cfc14df7f8b6c4e19707a17691c16f43282ad10abc0fb046d4bdf5e4a83e0057e6ab72510e1e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">「react进阶」一文吃透React高阶组件(HOC)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5MjMxMzY5Mw==&amp;mid=2247484275&amp;idx=1&amp;sn=d0a2f61cfaf0004d9683c7b940ce704e&amp;chksm=cfc14a41f8b6c35772077397e778060c7849ff8a73faf2a38c570215b2d3c924d1d6e87a28b2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">「react进阶」年终送给react开发者的八条优化建议<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="参考文档"><a href="#参考文档" class="header-anchor">#</a> 参考文档</h2> <ul><li>react源码</li> <li>React 事件系统工作原理</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/events/react事件系统原理.html" class="prev">
        React 事件系统原理
      </a></span> <span class="next"><a href="/events/一文读懂React组件渲染核心原理.html">
        一文读懂 React 组件渲染核心原理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.27287fd6.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/67.aa46c62c.js" defer></script>
  </body>
</html>
