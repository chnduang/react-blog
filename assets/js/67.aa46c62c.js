(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{358:function(e,t,n){"use strict";n.r(t);var a=n(4),v=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"一文吃透react事件原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一文吃透react事件原理"}},[e._v("#")]),e._v(" 一文吃透react事件原理")]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/LvzC74rlYZr4tSkFkxGAoA",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/LvzC74rlYZr4tSkFkxGAoA"),t("OutboundLink")],1)])]),e._v(" "),t("h1",{attrs:{id:"一-前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-前言"}},[e._v("#")]),e._v(" 一 前言")]),e._v(" "),t("p",[e._v("今天我们来一起探讨一下"),t("code",[e._v("React")]),e._v("事件原理，这篇文章，我尽量用通俗简洁的方式，把"),t("code",[e._v("React")]),e._v("事件系统讲的明明白白。")]),e._v(" "),t("p",[e._v("我们讲的"),t("code",[e._v("react")]),e._v("版本是"),t("code",[e._v("16.13.1")]),e._v(" , "),t("code",[e._v("v17")]),e._v("之后"),t("code",[e._v("react")]),e._v("对于事件系统会有相关的改版，文章后半部分会提及。")]),e._v(" "),t("p",[e._v("老规矩，在正式讲解"),t("code",[e._v("react")]),e._v("之前，我们先想想这几个问题("),t("strong",[e._v("如果我是面试官，你会怎么回答?")]),e._v(")：")]),e._v(" "),t("ul",[t("li",[e._v("1 我们写的事件是绑定在"),t("code",[e._v("dom")]),e._v("上么，如果不是绑定在哪里？")]),e._v(" "),t("li",[e._v("2 为什么我们的事件不能绑定给组件？")]),e._v(" "),t("li",[e._v("3 为什么我们的事件手动绑定"),t("code",[e._v("this")]),e._v("(不是箭头函数的情况)")]),e._v(" "),t("li",[e._v("4 为什么不能用 "),t("code",[e._v("return false")]),e._v("来阻止事件的默认行为？")]),e._v(" "),t("li",[e._v("5 "),t("code",[e._v("react")]),e._v("怎么通过"),t("code",[e._v("dom")]),e._v("元素，找到与之对应的 "),t("code",[e._v("fiber")]),e._v("对象的？")]),e._v(" "),t("li",[e._v("6 "),t("code",[e._v("onClick")]),e._v("是在冒泡阶段绑定的？那么"),t("code",[e._v("onClickCapture")]),e._v("就是在事件捕获阶段绑定的吗？")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJvIa01mAsTNF4mZMy2fsSWicp4VEsdj7xeRuScjTEQHibLayphqpySHcA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("B7836791-2C40-48BA-83BF-835E0BD87B55.jpg")]),e._v(" "),t("h2",{attrs:{id:"必要的知识概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#必要的知识概念"}},[e._v("#")]),e._v(" 必要的知识概念")]),e._v(" "),t("p",[e._v("在弄清楚"),t("code",[e._v("react")]),e._v("事件之前，有几个概念我们必须弄清楚，因为只有弄明白这几个概念，在事件触发阶段，我们才能更好的理解"),t("code",[e._v("react")]),e._v("处理事件本质。")]),e._v(" "),t("h3",{attrs:{id:"我们写在jsx事件终将变成什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#我们写在jsx事件终将变成什么"}},[e._v("#")]),e._v(" 我们写在JSX事件终将变成什么？")]),e._v(" "),t("p",[e._v("我们先写一段含有点击事件的"),t("code",[e._v("react JSX")]),e._v("语法，看一下它最终会变成什么样子？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Index extends React.Component{\n    handerClick= (value) => console.log(value) \n    render(){\n        return <div>\n            <button onClick={ this.handerClick } > 按钮点击 </button>\n        </div>\n    }\n}\n")])])]),t("p",[e._v("经过"),t("code",[e._v("babel")]),e._v("转换成"),t("code",[e._v("React.createElement")]),e._v("形式，如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJJahUR1Z33lpxmZbZib4mK2DRicjlHgbOKsyK3bLUkFrWENflaAlEYYMw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("babel.jpg")]),e._v(" "),t("p",[e._v("最终转成"),t("code",[e._v("fiber")]),e._v("对象形式如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJJcMr48au9dvwHUoH3ffJoOafWib1iccEYTia9ACgl4oicV5nymeElxSlIw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("fiber.jpg")]),e._v(" "),t("p",[t("code",[e._v("fiber")]),e._v("对象上的"),t("code",[e._v("memoizedProps")]),e._v(" 和 "),t("code",[e._v("pendingProps")]),e._v("保存了我们的事件。")]),e._v(" "),t("h3",{attrs:{id:"什么是合成事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是合成事件"}},[e._v("#")]),e._v(" 什么是合成事件？")]),e._v(" "),t("p",[e._v("通过上一步我们看到了，我们声明事件保存的位置。但是事件有没有被真正的注册呢？我们接下来看一下：")]),e._v(" "),t("p",[e._v("我们看一下当前这个元素"),t("code",[e._v("<button>")]),e._v("上有没有绑定这个事件监听器呢？")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJQMsySfXz8S6wKO34YK5wklp5RDib95E2u3eWX1ujVqzwD8x0ZWicsZpw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("button_event.jpg")]),e._v(" "),t("p",[t("strong",[e._v("button上绑定的事件")])]),e._v(" "),t("p",[e._v("我们可以看到 ，"),t("code",[e._v("button")]),e._v("上绑定了两个事件，一个是"),t("code",[e._v("document")]),e._v("上的事件监听器，另外一个是"),t("code",[e._v("button")]),e._v("，但是事件处理函数"),t("code",[e._v("handle")]),e._v("，并不是我们的"),t("code",[e._v("handerClick")]),e._v("事件，而是"),t("code",[e._v("noop")]),e._v("。")]),e._v(" "),t("p",[t("code",[e._v("noop")]),e._v("是什么呢？我们接着来看。")]),e._v(" "),t("p",[e._v("原来"),t("code",[e._v("noop")]),e._v("就指向一个空函数。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJfRAX3qRK8pNpjxOVC6uib66tzOEulItlCSKFicPkBlTyE0d2iauJViaKsQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("noop.jpg")]),e._v(" "),t("p",[t("strong",[e._v("然后我们看"),t("code",[e._v("document")]),e._v("绑定的事件")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJgEhMwxlpKicjWlgJRuxaK5xzHCsbP90Mhl3yNuQewwJpKdGbicZjyPqQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("document.jpg")]),e._v(" "),t("p",[e._v("可以看到"),t("code",[e._v("click")]),e._v("事件被绑定在"),t("code",[e._v("document")]),e._v("上了。")]),e._v(" "),t("p",[e._v("接下来我们再搞搞事情😂😂😂，在"),t("code",[e._v("demo")]),e._v("项目中加上一个"),t("code",[e._v("input")]),e._v("输入框，并绑定一个"),t("code",[e._v("onChange")]),e._v("事件。睁大眼睛看看接下来会发生什么？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Index extends React.Component{\n    componentDidMount(){\n        console.log(this)\n    }\n    handerClick= (value) => console.log(value) \n    handerChange=(value) => console.log(value)\n    render(){\n        return <div style={{ marginTop:'50px' }} >\n            <button onClick={ this.handerClick } > 按钮点击 </button>\n            <input  placeholder=\"请输入内容\" onChange={ this.handerChange }  />\n        </div>\n    }\n}\n")])])]),t("p",[t("strong",[e._v("我们先看一下"),t("code",[e._v("input dom")]),e._v("元素上绑定的事件")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJIe7R63IoYxJr2nfeMOuP1aia8DMEjCcGpVQ1rAw4GO3VJ3qNsQ33s8A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("22BEC470-233A-4C50-9C47-D21D343C055D.jpg")]),e._v(" "),t("p",[t("strong",[e._v("然后我们看一下"),t("code",[e._v("document")]),e._v("上绑定的事件")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJRaNQ4e0F8quv0u0UzSGOfokg9X9wKr0hsDfr3Q8qNgFnGwnXWBmcgA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("8E1D3BDB-ACFB-4E49-A5FF-CF990C47A60E.jpg")]),e._v(" "),t("p",[e._v("我们发现，我们给"),t("code",[e._v("<input>")]),e._v("绑定的"),t("code",[e._v("onChange")]),e._v("，并没有直接绑定在"),t("code",[e._v("input")]),e._v("上，而是统一绑定在了"),t("code",[e._v("document")]),e._v("上，然后我们"),t("code",[e._v("onChange")]),e._v("被处理成很多事件监听器，比如"),t("code",[e._v("blur")]),e._v(" , "),t("code",[e._v("change")]),e._v(" , "),t("code",[e._v("input")]),e._v(" , "),t("code",[e._v("keydown")]),e._v(" , "),t("code",[e._v("keyup")]),e._v(" 等。")]),e._v(" "),t("p",[e._v("综上我们可以得出结论：")]),e._v(" "),t("ul",[t("li",[e._v("①"),t("strong",[e._v("我们在 "),t("code",[e._v("jsx")]),e._v(" 中绑定的事件(demo中的"),t("code",[e._v("handerClick")]),e._v("，"),t("code",[e._v("handerChange")]),e._v("),根本就没有注册到真实的"),t("code",[e._v("dom")]),e._v("上。是绑定在"),t("code",[e._v("document")]),e._v("上统一管理的。")])]),e._v(" "),t("li",[e._v("②"),t("strong",[e._v("真实的"),t("code",[e._v("dom")]),e._v("上的"),t("code",[e._v("click")]),e._v("事件被单独处理,已经被"),t("code",[e._v("react")]),e._v("底层替换成空函数。")])]),e._v(" "),t("li",[e._v("③"),t("strong",[e._v("我们在"),t("code",[e._v("react")]),e._v("绑定的事件,比如"),t("code",[e._v("onChange")]),e._v("，在"),t("code",[e._v("document")]),e._v("上，可能有多个事件与之对应。")])]),e._v(" "),t("li",[e._v("④ "),t("strong",[t("code",[e._v("react")]),e._v("并不是一开始，把所有的事件都绑定在"),t("code",[e._v("document")]),e._v("上，而是采取了一种按需绑定，比如发现了"),t("code",[e._v("onClick")]),e._v("事件,再去绑定"),t("code",[e._v("document click")]),e._v("事件。")])])]),e._v(" "),t("p",[e._v("那么什么是"),t("code",[e._v("react")]),e._v("事件合成呢？")]),e._v(" "),t("p",[t("strong",[e._v("在"),t("code",[e._v("react")]),e._v("中，我们绑定的事件"),t("code",[e._v("onClick")]),e._v("等，并不是原生事件，而是由原生事件合成的"),t("code",[e._v("React")]),e._v("事件，比如 "),t("code",[e._v("click")]),e._v("事件合成为"),t("code",[e._v("onClick")]),e._v("事件。比如"),t("code",[e._v("blur")]),e._v(" , "),t("code",[e._v("change")]),e._v(" , "),t("code",[e._v("input")]),e._v(" , "),t("code",[e._v("keydown")]),e._v(" , "),t("code",[e._v("keyup")]),e._v("等 , 合成为"),t("code",[e._v("onChange")]),e._v("。")])]),e._v(" "),t("p",[e._v("那么"),t("code",[e._v("react")]),e._v("采取这种事件合成的模式呢？")]),e._v(" "),t("p",[e._v("一方面，将事件绑定在"),t("code",[e._v("document")]),e._v("统一管理，防止很多事件直接绑定在原生的"),t("code",[e._v("dom")]),e._v("元素上。造成一些不可控的情况")]),e._v(" "),t("p",[e._v("另一方面， "),t("code",[e._v("React")]),e._v(" 想实现一个全浏览器的框架， 为了实现这种目标就需要提供全浏览器一致性的事件系统，以此抹平不同浏览器的差异。")]),e._v(" "),t("p",[e._v("接下来的文章中，会介绍"),t("code",[e._v("react")]),e._v("是怎么做事件合成的。")]),e._v(" "),t("h3",{attrs:{id:"dom元素对应的fiber-tag对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dom元素对应的fiber-tag对象"}},[e._v("#")]),e._v(" dom元素对应的fiber Tag对象")]),e._v(" "),t("p",[e._v("我们知道了"),t("code",[e._v("react")]),e._v("怎么储存了我们的事件函数和事件合成因果。接下来我想让大家记住一种类型的 "),t("code",[e._v("fiber")]),e._v(" 对象,因为后面会用到，这对后续的理解很有帮助。")]),e._v(" "),t("p",[e._v("我们先来看一个代码片段：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<div> \n  <div> hello , my name is alien </div>\n</div>\n")])])]),t("p",[e._v("看"),t("code",[e._v("<div> hello , my name is alien </div>")]),e._v(" 对应的 "),t("code",[e._v("fiber")]),e._v("类型。tag = 5")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzYHmxW0oy7mdIaqtmicIXNJsTicvBiajJ0ESuicj1fB0S7UX7C1librMXJiaU5Bwk8g7qLF52MdHujsRmw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("然后我们去"),t("code",[e._v("react")]),e._v("源码中找到这种类的"),t("code",[e._v("fiber")]),e._v("类型。")]),e._v(" "),t("blockquote",[t("p",[e._v("/react-reconciler/src/ReactWorkTagsq.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export const HostComponent = 5; // 元素节点\n")])])]),t("p",[e._v("好的 ，我们暂且把 "),t("code",[e._v("HostComponent")]),e._v(" 和 "),t("code",[e._v("HostText")]),e._v("记录📝下来。接下来回归正题，我们先来看看"),t("code",[e._v("react")]),e._v("事件合成机制。")]),e._v(" "),t("h1",{attrs:{id:"二-事件初始化-事件合成-插件机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-事件初始化-事件合成-插件机制"}},[e._v("#")]),e._v(" 二 事件初始化-事件合成，插件机制")]),e._v(" "),t("p",[e._v("接下来，我们来看一看"),t("code",[e._v("react")]),e._v("这么处理事件合成的。首先我们从上面我们知道，"),t("code",[e._v("react")]),e._v("并不是一次性把所有事件都"),t("strong",[e._v("绑定进去")]),e._v("，而是如果发现项目中有"),t("code",[e._v("onClick")]),e._v("，才绑定"),t("code",[e._v("click")]),e._v("事件，发现有"),t("code",[e._v("onChange")]),e._v("事件，才绑定"),t("code",[e._v("blur")]),e._v(" , "),t("code",[e._v("change")]),e._v(" , "),t("code",[e._v("input")]),e._v(" , "),t("code",[e._v("keydown")]),e._v(" , "),t("code",[e._v("keyup")]),e._v("等。所以为了把原理搞的清清楚楚，笔者把事件原理分成三部分来搞定：")]),e._v(" "),t("ul",[t("li",[e._v("1 "),t("code",[e._v("react")]),e._v("对事件是如何合成的。")]),e._v(" "),t("li",[e._v("2 "),t("code",[e._v("react")]),e._v("事件是怎么绑定的。")]),e._v(" "),t("li",[e._v("3 "),t("code",[e._v("react")]),e._v("事件触发流程。")])]),e._v(" "),t("h2",{attrs:{id:"事件合成-事件插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件合成-事件插件"}},[e._v("#")]),e._v(" 事件合成-事件插件")]),e._v(" "),t("h3",{attrs:{id:"_1-必要概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-必要概念"}},[e._v("#")]),e._v(" 1 必要概念")]),e._v(" "),t("p",[e._v("我们先来看来几个常量关系，这对于我们吃透"),t("code",[e._v("react")]),e._v("事件原理很有帮助。在解析来的讲解中，我也会讲到这几个对象如何来的，具体有什么作用。")]),e._v(" "),t("h4",{attrs:{id:"_1namestoplugins"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1namestoplugins"}},[e._v("#")]),e._v(" ①namesToPlugins")]),e._v(" "),t("p",[e._v("第一个概念："),t("strong",[e._v("namesToPlugins")]),e._v(" 装事件名 -> 事件模块插件的映射,"),t("code",[e._v("namesToPlugins")]),e._v("最终的样子如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const namesToPlugins = {\n    SimpleEventPlugin,\n    EnterLeaveEventPlugin,\n    ChangeEventPlugin,\n    SelectEventPlugin,\n    BeforeInputEventPlugin,\n}\n")])])]),t("p",[t("code",[e._v("SimpleEventPlugin")]),e._v("等是处理各个事件函数的插件，比如一次点击事件，就会找到"),t("code",[e._v("SimpleEventPlugin")]),e._v("对应的处理函数。我们先记录下它，至于具体有什么作用，接下来会讲到。")]),e._v(" "),t("h4",{attrs:{id:"_2plugins"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2plugins"}},[e._v("#")]),e._v(" ②plugins")]),e._v(" "),t("p",[t("code",[e._v("plugins")]),e._v("，这个对象就是上面注册的所有插件列表,初始化为空。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const  plugins = [LegacySimpleEventPlugin, LegacyEnterLeaveEventPlugin, ...];\n")])])]),t("h4",{attrs:{id:"_3registrationnamemodules"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3registrationnamemodules"}},[e._v("#")]),e._v(" ③registrationNameModules")]),e._v(" "),t("p",[t("code",[e._v("registrationNameModules")]),e._v("记录了React合成的事件-对应的事件插件的关系，在"),t("code",[e._v("React")]),e._v("中，处理"),t("code",[e._v("props")]),e._v("中事件的时候，会根据不同的事件名称，找到对应的事件插件，然后统一绑定在"),t("code",[e._v("document")]),e._v("上。对于没有出现过的事件，就不会绑定，我们接下来会讲到。"),t("code",[e._v("registrationNameModules")]),e._v("大致的样子如下所示。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n    onBlur: SimpleEventPlugin,\n    onClick: SimpleEventPlugin,\n    onClickCapture: SimpleEventPlugin,\n    onChange: ChangeEventPlugin,\n    onChangeCapture: ChangeEventPlugin,\n    onMouseEnter: EnterLeaveEventPlugin,\n    onMouseLeave: EnterLeaveEventPlugin,\n    ...\n}\n")])])]),t("h4",{attrs:{id:"_4事件插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4事件插件"}},[e._v("#")]),e._v(" ④事件插件")]),e._v(" "),t("p",[e._v("那么我们首先就要搞清楚，"),t("code",[e._v("SimpleEventPlugin")]),e._v(","),t("code",[e._v("EnterLeaveEventPlugin")]),e._v("每个插件都是什么？我们拿"),t("code",[e._v("SimpleEventPlugin")]),e._v("为例，看一下它究竟是什么样子？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const SimpleEventPlugin = {\n    eventTypes:{ \n        'click':{ /* 处理点击事件  */\n            phasedRegistrationNames:{\n                bubbled: 'onClick',       // 对应的事件冒泡 - onClick \n                captured:'onClickCapture' //对应事件捕获阶段 - onClickCapture\n            },\n            dependencies: ['click'], //事件依赖\n            ...\n        },\n        'blur':{ /* 处理失去焦点事件 */ },\n        ...\n    }\n    extractEvents:function(topLevelType,targetInst,){ /* eventTypes 里面的事件对应的统一事件处理函数，接下来会重点讲到 */ }\n}\n")])])]),t("p",[e._v("首先事件插件是一个对象，有两个属性，第一个"),t("code",[e._v("extractEvents")]),e._v("作为事件统一处理函数，第二个"),t("code",[e._v("eventTypes")]),e._v("是一个对象，对象保存了原生事件名和对应的配置项"),t("code",[e._v("dispatchConfig")]),e._v("的映射关系。由于v16React的事件是统一绑定在"),t("code",[e._v("document")]),e._v("上的，React用独特的事件名称比如"),t("code",[e._v("onClick")]),e._v("和"),t("code",[e._v("onClickCapture")]),e._v("，来说明我们给绑定的函数到底是在冒泡事件阶段，还是捕获事件阶段执行。")]),e._v(" "),t("h4",{attrs:{id:"_5-registrationnamedependencies"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-registrationnamedependencies"}},[e._v("#")]),e._v(" ⑤ registrationNameDependencies")]),e._v(" "),t("p",[t("code",[e._v("registrationNameDependencies")]),e._v("用来记录，合成事件比如 "),t("code",[e._v("onClick")]),e._v(" 和原生事件 "),t("code",[e._v("click")]),e._v("对应关系。比如 "),t("code",[e._v("onChange")]),e._v(" 对应 "),t("code",[e._v("change")]),e._v(" , "),t("code",[e._v("input")]),e._v(" , "),t("code",[e._v("keydown")]),e._v(" , "),t("code",[e._v("keyup")]),e._v("事件。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("{\n    onBlur: ['blur'],\n    onClick: ['click'],\n    onClickCapture: ['click'],\n    onChange: ['blur', 'change', 'click', 'focus', 'input', 'keydown', 'keyup', 'selectionchange'],\n    onMouseEnter: ['mouseout', 'mouseover'],\n    onMouseLeave: ['mouseout', 'mouseover'],\n    ...\n}\n")])])]),t("h3",{attrs:{id:"_2-事件初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-事件初始化"}},[e._v("#")]),e._v(" 2 事件初始化")]),e._v(" "),t("p",[e._v("对于事件合成，"),t("code",[e._v("v16.13.1")]),e._v("版本"),t("code",[e._v("react")]),e._v("采用了初始化注册方式。")]),e._v(" "),t("blockquote",[t("p",[e._v("react-dom/src/client/ReactDOMClientInjection.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/* 第一步：注册事件：  */\ninjectEventPluginsByName({\n    SimpleEventPlugin: SimpleEventPlugin,\n    EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n    ChangeEventPlugin: ChangeEventPlugin,\n    SelectEventPlugin: SelectEventPlugin,\n    BeforeInputEventPlugin: BeforeInputEventPlugin,\n});\n")])])]),t("p",[t("code",[e._v("injectEventPluginsByName")]),e._v(" 这个函数具体有什么用呢，它在"),t("code",[e._v("react")]),e._v("底层是默认执行的。我们来简化这个函数,看它到底是干什么的。")]),e._v(" "),t("blockquote",[t("p",[e._v("legacy-event/EventPluginRegistry.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/* 注册事件插件 */\nexport function injectEventPluginsByName(injectedNamesToPlugins){\n     for (const pluginName in injectedNamesToPlugins) {\n         namesToPlugins[pluginName] = injectedNamesToPlugins[pluginName]\n     }\n     recomputePluginOrdering()\n}\n")])])]),t("p",[t("code",[e._v("injectEventPluginsByName")]),e._v("做的事情很简单，形成上述的"),t("code",[e._v("namesToPlugins")]),e._v("，然后执行"),t("code",[e._v("recomputePluginOrdering")]),e._v("，我们接下来看一下"),t("code",[e._v("recomputePluginOrdering")]),e._v("做了写什么？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const eventPluginOrder = [ 'SimpleEventPlugin' , 'EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin' , 'BeforeInputEventPlugin' ]\n\nfunction recomputePluginOrdering(){\n    for (const pluginName in namesToPlugins) {\n        /* 找到对应的事件处理插件，比如 SimpleEventPlugin  */\n        const pluginModule = namesToPlugins[pluginName];\n        const pluginIndex = eventPluginOrder.indexOf(pluginName);\n        /* 填充 plugins 数组  */\n        plugins[pluginIndex] = pluginModule;\n    }\n\n    const publishedEvents = pluginModule.eventTypes;\n    for (const eventName in publishedEvents) {\n       // publishedEvents[eventName] -> eventConfig , pluginModule -> 事件插件 ， eventName -> 事件名称\n        publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName,)\n    } \n}\n】\n")])])]),t("p",[t("strong",[e._v("recomputePluginOrdering")]),e._v(",作用很明确了，形成上面说的那个"),t("code",[e._v("plugins")]),e._v(",数组。然后就是"),t("strong",[e._v("重点的函数"),t("code",[e._v("publishEventForPlugin")])]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/*\n  dispatchConfig -> 原生事件对应配置项 { phasedRegistrationNames :{  冒泡 捕获  } ，   }\n  pluginModule -> 事件插件 比如SimpleEventPlugin  \n  eventName -> 原生事件名称。\n*/\nfunction publishEventForPlugin (dispatchConfig,pluginModule,eventName){\n    eventNameDispatchConfigs[eventName] = dispatchConfig;\n    /* 事件 */\n    const phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n    if (phasedRegistrationNames) {\n    for (const phaseName in phasedRegistrationNames) {\n        if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n            // phasedRegistrationName React事件名 比如 onClick / onClickCapture\n            const phasedRegistrationName = phasedRegistrationNames[phaseName];\n            // 填充形成 registrationNameModules React 合成事件 -> React 处理事件插件映射关系\n            registrationNameModules[phasedRegistrationName] = pluginModule;\n            // 填充形成 registrationNameDependencies React 合成事件 -> 原生事件 映射关系\n            registrationNameDependencies[phasedRegistrationName] = pluginModule.eventTypes[eventName].dependencies;\n        }\n    }\n    return true;\n    }\n}\n")])])]),t("p",[t("code",[e._v("publishEventForPlugin")]),e._v(" 作用形成上述的 "),t("strong",[t("code",[e._v("registrationNameModules")])]),e._v(" 和 "),t("strong",[t("code",[e._v("registrationNameDependencies")])]),e._v(" 对象中的映射关系。")]),e._v(" "),t("h3",{attrs:{id:"_3-事件合成总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-事件合成总结"}},[e._v("#")]),e._v(" 3 事件合成总结")]),e._v(" "),t("p",[e._v("到这里整个初始化阶段已经完事了，我来总结一下初始化事件合成都做了些什么。这个阶段主要形成了上述的几个重要对象，构建初始化React合成事件和原生事件的对应关系，合成事件和对应的事件处理插件关系。接下来就是事件绑定阶段。")]),e._v(" "),t("h1",{attrs:{id:"三-事件绑定-从一次点击事件开始"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-事件绑定-从一次点击事件开始"}},[e._v("#")]),e._v(" 三 事件绑定-从一次点击事件开始")]),e._v(" "),t("h2",{attrs:{id:"事件绑定流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件绑定流程"}},[e._v("#")]),e._v(" 事件绑定流程")]),e._v(" "),t("p",[e._v("如果我们在一个组件中这么写一个点击事件，"),t("code",[e._v("React")]),e._v("会一步步如何处理。")]),e._v(" "),t("h3",{attrs:{id:"_1-diffproperties-处理react合成事件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-diffproperties-处理react合成事件"}},[e._v("#")]),e._v(" 1 diffProperties 处理React合成事件")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div>\n  <button onClick={ this.handerClick }  className="button" >点击</button>\n</div>\n')])])]),t("p",[e._v("第一步，首先通过上面的讲解，我们绑定给hostComponent种类的fiber(如上的button元素)，会 "),t("code",[e._v("button")]),e._v(" 对应的fiber上，以"),t("code",[e._v("memoizedProps")]),e._v(" 和 "),t("code",[e._v("pendingProps")]),e._v("形成保存。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("button 对应 fiber\nmemoizedProps = {\n   onClick:function handerClick(){},\n   className:'button'\n}\n")])])]),t("p",[e._v("结构图如下所示：")]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),e._v("58E6A4AF-1902-42BC-9D11-B47234037E01.jpg")]),e._v(" "),t("p",[e._v("第二步，React在调合子节点后，进入diff阶段，如果判断是"),t("code",[e._v("HostComponent")]),e._v("(dom元素)类型的fiber，会用diff props函数"),t("code",[e._v("diffProperties")]),e._v("单独处理。")]),e._v(" "),t("blockquote",[t("p",[e._v("react-dom/src/client/ReactDOMComponent.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function diffProperties(){\n    /* 判断当前的 propKey 是不是 React合成事件 */\n    if(registrationNameModules.hasOwnProperty(propKey)){\n         /* 这里多个函数简化了，如果是合成事件， 传入成事件名称 onClick ，向document注册事件  */\n         legacyListenToEvent(registrationName, document）;\n    }\n}\n")])])]),t("p",[t("code",[e._v("diffProperties")]),e._v("函数在 "),t("code",[e._v("diff props")]),e._v(" 如果发现是合成事件("),t("code",[e._v("onClick")]),e._v(") 就会调用"),t("code",[e._v("legacyListenToEvent")]),e._v("函数。注册事件监听器。")]),e._v(" "),t("h3",{attrs:{id:"_2-legacylistentoevent-注册事件监听器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-legacylistentoevent-注册事件监听器"}},[e._v("#")]),e._v(" 2 legacyListenToEvent 注册事件监听器")]),e._v(" "),t("blockquote",[t("p",[e._v("react-dom/src/events/DOMLegacyEventPluginSystem.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//  registrationName -> onClick 事件\n//  mountAt -> document or container\nfunction legacyListenToEvent(registrationName，mountAt){\n   const dependencies = registrationNameDependencies[registrationName]; // 根据 onClick 获取  onClick 依赖的事件数组 [ 'click' ]。\n    for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i];\n    //这个经过多个函数简化，如果是 click 基础事件，会走 legacyTrapBubbledEvent ,而且都是按照冒泡处理\n     legacyTrapBubbledEvent(dependency, mountAt);\n  }\n}\n")])])]),t("p",[e._v("legacyTrapBubbledEvent 就是执行将绑定真正的dom事件的函数 legacyTrapBubbledEvent(冒泡处理)。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function legacyTrapBubbledEvent(topLevelType,element){\n   addTrappedEventListener(element,topLevelType,PLUGIN_EVENT_SYSTEM,false)\n}\n")])])]),t("p",[e._v("第三步：在"),t("code",[e._v("legacyListenToEvent")]),e._v("函数中，先找到 "),t("code",[e._v("React")]),e._v(" 合成事件对应的原生事件集合，比如 onClick -> ['click'] , onChange -> ["),t("code",[e._v("blur")]),e._v(" , "),t("code",[e._v("change")]),e._v(" , "),t("code",[e._v("input")]),e._v(" , "),t("code",[e._v("keydown")]),e._v(" , "),t("code",[e._v("keyup")]),e._v("]，然后遍历依赖项的数组，绑定事件，"),t("strong",[e._v("这就解释了，为什么我们在刚开始的demo中，只给元素绑定了一个"),t("code",[e._v("onChange")]),e._v("事件，结果在"),t("code",[e._v("document")]),e._v("上出现很多事件监听器的原因，就是在这个函数上处理的。")])]),e._v(" "),t("p",[e._v("我们上面已经透露了React是采用事件绑定，"),t("code",[e._v("React")]),e._v(" 对于 "),t("code",[e._v("click")]),e._v(" 等基础事件，会默认按照事件冒泡阶段的事件处理，"),t("strong",[e._v("不过这也不绝对的，比如一些事件的处理，有些特殊的事件是按照事件捕获处理的。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("case TOP_SCROLL: {                                // scroll 事件\n    legacyTrapCapturedEvent(TOP_SCROLL, mountAt); // legacyTrapCapturedEvent 事件捕获处理。\n    break;\n}\ncase TOP_FOCUS: // focus 事件\ncase TOP_BLUR:  // blur 事件\nlegacyTrapCapturedEvent(TOP_FOCUS, mountAt);\nlegacyTrapCapturedEvent(TOP_BLUR, mountAt);\nbreak;\n")])])]),t("h3",{attrs:{id:"_3-绑定-dispatchevent-进行事件监听"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-绑定-dispatchevent-进行事件监听"}},[e._v("#")]),e._v(" 3 绑定 dispatchEvent，进行事件监听")]),e._v(" "),t("p",[e._v("如上述的"),t("code",[e._v("scroll")]),e._v("事件，"),t("code",[e._v("focus")]),e._v(" 事件 ，"),t("code",[e._v("blur")]),e._v("事件等，是默认按照事件捕获逻辑处理。接下来就是最重要关键的一步。React是如何绑定事件到"),t("code",[e._v("document")]),e._v("？事件处理函数函数又是什么？问题都指向了上述的"),t("code",[e._v("addTrappedEventListener")]),e._v("，让我们来揭开它的面纱。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/*\n  targetContainer -> document\n  topLevelType ->  click\n  capture = false\n*/\nfunction addTrappedEventListener(targetContainer,topLevelType,eventSystemFlags,capture){\n   const listener = dispatchEvent.bind(null,topLevelType,eventSystemFlags,targetContainer) \n   if(capture){\n       // 事件捕获阶段处理函数。\n   }else{\n       /* TODO: 重要, 这里进行真正的事件绑定。*/\n      targetContainer.addEventListener(topLevelType,listener,false) // document.addEventListener('click',listener,false)\n   }\n}\n")])])]),t("p",[e._v("第四步：这个函数内容虽然不多，但是却非常重要,首先绑定我们的事件统一处理函数 "),t("code",[e._v("dispatchEvent")]),e._v("，绑定几个默认参数，事件类型 "),t("code",[e._v("topLevelType")]),e._v(" demo中的"),t("code",[e._v("click")]),e._v(" ，还有绑定的容器"),t("code",[e._v("doucment")]),e._v("。"),t("strong",[e._v("然后真正的事件绑定,添加事件监听器"),t("code",[e._v("addEventListener")]),e._v("。")]),e._v(" 事件绑定阶段完毕。")]),e._v(" "),t("h3",{attrs:{id:"_4-事件绑定过程总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-事件绑定过程总结"}},[e._v("#")]),e._v(" 4 事件绑定过程总结")]),e._v(" "),t("p",[e._v("我们来做一下事件绑定阶段的总结。")]),e._v(" "),t("ul",[t("li",[e._v("① 在React，diff DOM元素类型的fiber的props的时候， 如果发现是React合成事件，比如"),t("code",[e._v("onClick")]),e._v("，会按照事件系统逻辑单独处理。")]),e._v(" "),t("li",[e._v("② 根据React合成事件类型，找到对应的原生事件的类型，然后调用判断原生事件类型，大部分事件都按照冒泡逻辑处理，少数事件会按照捕获逻辑处理（比如"),t("code",[e._v("scroll")]),e._v("事件）。")]),e._v(" "),t("li",[e._v("③ 调用 addTrappedEventListener 进行真正的事件绑定，绑定在"),t("code",[e._v("document")]),e._v("上，"),t("code",[e._v("dispatchEvent")]),e._v(" 为统一的事件处理函数。")]),e._v(" "),t("li",[e._v("④ "),t("strong",[e._v("有一点值得注意: 只有上述那几个特殊事件比如 "),t("code",[e._v("scorll")]),e._v(","),t("code",[e._v("focus")]),e._v(","),t("code",[e._v("blur")]),e._v("等是在事件捕获阶段发生的，其他的都是在事件冒泡阶段发生的，无论是"),t("code",[e._v("onClick")]),e._v("还是"),t("code",[e._v("onClickCapture")]),e._v("都是发生在冒泡阶段")]),e._v("，至于 React 本身怎么处理捕获逻辑的。我们接下来会讲到。")])]),e._v(" "),t("h1",{attrs:{id:"四-事件触发-一次点击事件-在react底层系统会发生什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四-事件触发-一次点击事件-在react底层系统会发生什么"}},[e._v("#")]),e._v(" 四 事件触发-一次点击事件，在"),t("code",[e._v("react")]),e._v("底层系统会发生什么？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div>\n  <button onClick={ this.handerClick }  className="button" >点击</button>\n</div>\n')])])]),t("p",[e._v("还是上面这段代码片段，当点击一下按钮，在 "),t("code",[e._v("React")]),e._v(" 底层会发生什么呢？接下来，让我共同探索事件触发的奥秘。")]),e._v(" "),t("h2",{attrs:{id:"事件触发处理函数-dispatchevent"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件触发处理函数-dispatchevent"}},[e._v("#")]),e._v(" 事件触发处理函数 dispatchEvent")]),e._v(" "),t("p",[e._v("我们在事件绑定阶段讲过，React事件注册时候，统一的监听器"),t("code",[e._v("dispatchEvent")]),e._v("，也就是当我们"),t("strong",[e._v("点击按钮之后，首先执行的是"),t("code",[e._v("dispatchEvent")]),e._v("函数")]),e._v("，因为"),t("code",[e._v("dispatchEvent")]),e._v("前三个参数已经被bind了进去，所以真正的事件源对象"),t("code",[e._v("event")]),e._v("，被默认绑定成第四个参数。")]),e._v(" "),t("blockquote",[t("p",[e._v("react-dom/src/events/ReactDOMEventListener.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function dispatchEvent(topLevelType,eventSystemFlags,targetContainer,nativeEvent){\n    /* 尝试调度事件 */\n    const blockedOn = attemptToDispatchEvent( topLevelType,eventSystemFlags, targetContainer, nativeEvent);\n}\n/*\ntopLevelType -> click\neventSystemFlags -> 1\ntargetContainer -> document\nnativeEvent -> 原生事件的 event 对象\n*/\nfunction attemptToDispatchEvent(topLevelType,eventSystemFlags,targetContainer,nativeEvent){\n    /* 获取原生事件 e.target */\n    const nativeEventTarget = getEventTarget(nativeEvent)\n    /* 获取当前事件，最近的dom类型fiber ，我们 demo中 button 按钮对应的 fiber */\n    let targetInst = getClosestInstanceFromNode(nativeEventTarget); \n    /* 重要：进入legacy模式的事件处理系统 */\n    dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,targetInst,);\n    return null;\n}\n")])])]),t("p",[e._v("在这个阶段主要做了这几件事：")]),e._v(" "),t("ul",[t("li",[e._v("① 首先根据真实的事件源对象，找到 "),t("code",[e._v("e.target")]),e._v(" 真实的 "),t("code",[e._v("dom")]),e._v(" 元素。")]),e._v(" "),t("li",[e._v("② 然后根据"),t("code",[e._v("dom")]),e._v("元素，找到与它对应的 "),t("code",[e._v("fiber")]),e._v(" 对象"),t("code",[e._v("targetInst")]),e._v("，在我们 "),t("code",[e._v("demo")]),e._v(" 中，找到 "),t("code",[e._v("button")]),e._v(" 按钮对应的 "),t("code",[e._v("fiber")]),e._v("。")]),e._v(" "),t("li",[e._v("③ 然后正式进去"),t("code",[e._v("legacy")]),e._v("模式的事件处理系统，也就是我们目前用的React模式都是"),t("code",[e._v("legacy")]),e._v("模式下的，在这个模式下，批量更新原理，即将拉开帷幕。")])]),e._v(" "),t("p",[e._v("这里有一点问题，"),t("strong",[t("code",[e._v("React")]),e._v("怎么样通过原生的"),t("code",[e._v("dom")]),e._v("元素，找到对应的"),t("code",[e._v("fiber")]),e._v("的呢？")]),e._v(" ，也就是说 "),t("code",[e._v("getClosestInstanceFromNode")]),e._v(" 原理是什么？")]),e._v(" "),t("p",[e._v("答案是首先 "),t("code",[e._v("getClosestInstanceFromNode")]),e._v(" 可以找到当前传入的 "),t("code",[e._v("dom")]),e._v(" 对应的最近的元素类型的 "),t("code",[e._v("fiber")]),e._v(" 对象。"),t("code",[e._v("React")]),e._v(" 在初始化真实 "),t("code",[e._v("dom")]),e._v(" 的时候，用一个随机的 "),t("code",[e._v("key internalInstanceKey")]),e._v(" 指针指向了当前"),t("code",[e._v("dom")]),e._v("对应的"),t("code",[e._v("fiber")]),e._v("对象，"),t("code",[e._v("fiber")]),e._v("对象用"),t("code",[e._v("stateNode")]),e._v("指向了当前的"),t("code",[e._v("dom")]),e._v("元素。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 声明随机key\nvar internalInstanceKey = '__reactInternalInstance$' + randomKey;\n\n// 使用随机key \nfunction getClosestInstanceFromNode(targetNode){\n  // targetNode -dom  targetInst -> 与之对应的fiber对象\n  var targetInst = targetNode[internalInstanceKey];\n}\n")])])]),t("p",[t("strong",[e._v("在谷歌调试器上看")])]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),e._v("fiber_dom.jpg")]),e._v(" "),t("p",[t("strong",[e._v("两者关系图")])]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),e._v("dom_fiber.jpg")]),e._v(" "),t("h2",{attrs:{id:"legacy-事件处理系统与批量更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#legacy-事件处理系统与批量更新"}},[e._v("#")]),e._v(" legacy 事件处理系统与批量更新")]),e._v(" "),t("blockquote",[t("p",[e._v("react-dom/src/events/DOMLegacyEventPluginSystem.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/* topLevelType - click事件 ｜ eventSystemFlags = 1 ｜ nativeEvent = 事件源对象  ｜ targetInst = 元素对应的fiber对象  */\nfunction dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,targetInst){\n    /* 从React 事件池中取出一个，将 topLevelType ，targetInst 等属性赋予给事件  */\n    const bookKeeping = getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst,eventSystemFlags);\n    try { /* 执行批量更新 handleTopLevel 为事件处理的主要函数 */\n    batchedEventUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    /* 释放事件池 */  \n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n")])])]),t("p",[e._v("对于v16事件池，我们接下来会讲到，首先 "),t("code",[e._v("batchedEventUpdates")]),e._v("为批量更新的主要函数。我们先来看看"),t("code",[e._v("batchedEventUpdates")])]),e._v(" "),t("blockquote",[t("p",[e._v("react-dom/src/events/ReactDOMUpdateBatching.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function batchedEventUpdates(fn,a){\n    isBatchingEventUpdates = true;\n    try{\n       fn(a) // handleTopLevel(bookKeeping)\n    }finally{\n        isBatchingEventUpdates = false\n    }\n}\n")])])]),t("p",[e._v("批量更新简化成如上的样子，从上面我们可以看到，React通过开关"),t("code",[e._v("isBatchingEventUpdates")]),e._v("来控制是否启用批量更新。"),t("code",[e._v("fn(a)")]),e._v("，事件上调用的是 "),t("code",[e._v("handleTopLevel(bookKeeping)")]),e._v("，由于js是单线程的，我们真正在组件中写的事件处理函数，比如demo 的 "),t("code",[e._v("handerClick")]),e._v("实际执行是在"),t("code",[e._v("handleTopLevel(bookKeeping)")]),e._v("中执行的。所以如果我们在"),t("code",[e._v("handerClick")]),e._v("里面触发"),t("code",[e._v("setState")]),e._v("，那么就能读取到"),t("code",[e._v("isBatchingEventUpdates = true")]),e._v("这就是React的合成事件为什么具有批量更新的功能了。比如我们这么写")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("state={number:0}\nhanderClick = () =>{\n    this.setState({number: this.state.number + 1   })\n    console.log(this.state.number) //0\n    this.setState({number: this.state.number + 1   })\n    console.log(this.state.number) //0\n    setTimeout(()=>{\n        this.setState({number: this.state.number + 1   })\n        console.log(this.state.number) //2\n        this.setState({number: this.state.number + 1   })\n        console.log(this.state.number)// 3\n    })\n}\n")])])]),t("p",[e._v("如上述所示，第一个"),t("code",[e._v("setState")]),e._v("和第二个"),t("code",[e._v("setState")]),e._v("在批量更新条件之内执行，所以打印不会是最新的值，但是如果是发生在"),t("code",[e._v("setTimeout")]),e._v("中,由于eventLoop 放在了下一次事件循环中执行，此时 batchedEventUpdates 中已经执行完"),t("code",[e._v("isBatchingEventUpdates = false")]),e._v("，所以批量更新被打破，我们就可以直接访问到最新变化的值了。")]),e._v(" "),t("p",[e._v("接下来我们有两点没有梳理：")]),e._v(" "),t("ul",[t("li",[e._v("一是React事件池概念")]),e._v(" "),t("li",[e._v("二是最后的线索是执行"),t("code",[e._v("handleTopLevel(bookKeeping)")]),e._v("，那么"),t("code",[e._v("handleTopLevel")]),e._v("到底做了写什么。")])]),e._v(" "),t("h2",{attrs:{id:"执行事件插件函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行事件插件函数"}},[e._v("#")]),e._v(" 执行事件插件函数")]),e._v(" "),t("p",[e._v("上面说到整个事件系统，最后指向函数 "),t("code",[e._v("handleTopLevel(bookKeeping)")]),e._v(" 那么 "),t("code",[e._v("handleTopLevel")]),e._v(" 到底做了什么事情？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 流程简化后\n// topLevelType - click  \n// targetInst - button Fiber\n// nativeEvent\nfunction handleTopLevel(bookKeeping){\n    const { topLevelType,targetInst,nativeEvent,eventTarget, eventSystemFlags} = bookKeeping\n    for(let i=0; i < plugins.length;i++ ){\n        const possiblePlugin = plugins[i];\n        /* 找到对应的事件插件，形成对应的合成event，形成事件执行队列  */\n        const  extractedEvents = possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,eventTarget,eventSystemFlags)  \n    }\n    if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n    }\n    /* 执行事件处理函数 */\n    runEventsInBatch(events);\n}\n")])])]),t("p",[e._v("我把整个流程简化，只保留了核心的流程，"),t("code",[e._v("handleTopLevel")]),e._v("最后的处理逻辑就是执行我们说的事件处理插件(SimpleEventPlugin)中的处理函数"),t("code",[e._v("extractEvents")]),e._v("，比如我们demo中的点击事件 onClick 最终走的就是 "),t("code",[e._v("SimpleEventPlugin")]),e._v(" 中的 "),t("code",[e._v("extractEvents")]),e._v(" 函数，那么React为什么这么做呢? 我们知道我们React是采取事件合成，事件统一绑定，并且我们写在组件中的事件处理函数( handerClick )，也不是真正的执行函数"),t("code",[e._v("dispatchAciton")]),e._v("，那么我们在"),t("code",[e._v("handerClick")]),e._v("的事件对象 "),t("code",[e._v("event")]),e._v(",也是React单独合成处理的，里面单独封装了比如 "),t("code",[e._v("stopPropagation")]),e._v("和"),t("code",[e._v("preventDefault")]),e._v("等方法，"),t("strong",[e._v("这样的好处是，我们不需要跨浏览器单独处理兼容问题，交给React底层统一处理。")])]),e._v(" "),t("h2",{attrs:{id:"extractevents-形成事件对象event-和-事件处理函数队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#extractevents-形成事件对象event-和-事件处理函数队列"}},[e._v("#")]),e._v(" extractEvents 形成事件对象event 和 事件处理函数队列")]),e._v(" "),t("p",[t("strong",[e._v("重点来了！重点来了！重点来了！")]),e._v("，extractEvents 可以作为整个事件系统核心函数，我们先回到最初的"),t("code",[e._v("demo")]),e._v("，如果我们这么写,那么四个回调函数，那么点击按钮，四个事件是如何处理的呢。首先如果点击按钮，最终走的就是"),t("code",[e._v("extractEvents")]),e._v("函数，一探究竟这个函数。")]),e._v(" "),t("blockquote",[t("p",[e._v("legacy-events/SyntheticEvent.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const  SimpleEventPlugin = {\n    extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){\n        const dispatchConfig = topLevelEventsToDispatchConfig.get(topLevelType);\n        if (!dispatchConfig) {\n            return null;\n        }\n        switch(topLevelType){\n            default:\n            EventConstructor = SyntheticEvent;\n            break;\n        }\n        /* 产生事件源对象 */\n        const event = EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget)\n        const phasedRegistrationNames = event.dispatchConfig.phasedRegistrationNames;\n        const dispatchListeners = [];\n        const {bubbled, captured} = phasedRegistrationNames; /* onClick / onClickCapture */\n        const dispatchInstances = [];\n        /* 从事件源开始逐渐向上，查找dom元素类型HostComponent对应的fiber ，收集上面的React合成事件，onClick / onClickCapture  */\n         while (instance !== null) {\n              const {stateNode, tag} = instance;\n              if (tag === HostComponent && stateNode !== null) { /* DOM 元素 */\n                   const currentTarget = stateNode;\n                   if (captured !== null) { /* 事件捕获 */\n                        /* 在事件捕获阶段,真正的事件处理函数 */\n                        const captureListener = getListener(instance, captured);\n                        if (captureListener != null) {\n                        /* 对应发生在事件捕获阶段的处理函数，逻辑是将执行函数unshift添加到队列的最前面 */\n                            dispatchListeners.unshift(captureListener);\n                            dispatchInstances.unshift(instance);\n                            dispatchCurrentTargets.unshift(currentTarget);\n                        }\n                    }\n                    if (bubbled !== null) { /* 事件冒泡 */\n                        /* 事件冒泡阶段，真正的事件处理函数，逻辑是将执行函数push到执行队列的最后面 */\n                        const bubbleListener = getListener(instance, bubbled);\n                        if (bubbleListener != null) {\n                            dispatchListeners.push(bubbleListener);\n                            dispatchInstances.push(instance);\n                            dispatchCurrentTargets.push(currentTarget);\n                        }\n                    }\n              }\n              instance = instance.return;\n         }\n          if (dispatchListeners.length > 0) {\n              /* 将函数执行队列，挂到事件对象event上 */\n            event._dispatchListeners = dispatchListeners;\n            event._dispatchInstances = dispatchInstances;\n            event._dispatchCurrentTargets = dispatchCurrentTargets;\n         }\n        return event\n    }\n}\n")])])]),t("p",[e._v("事件插件系统的核心"),t("code",[e._v("extractEvents")]),e._v("主要做的事是:")]),e._v(" "),t("ul",[t("li",[e._v("① 首先形成"),t("code",[e._v("React")]),e._v("事件独有的合成事件源对象，这个对象，保存了整个事件的信息。将作为参数传递给真正的事件处理函数(handerClick)。")]),e._v(" "),t("li",[e._v("② 然后声明事件执行队列 ，按照"),t("code",[e._v("冒泡")]),e._v("和"),t("code",[e._v("捕获")]),e._v("逻辑，从事件源开始逐渐向上，查找dom元素类型HostComponent对应的fiber ，收集上面的 "),t("code",[e._v("React")]),e._v(" 合成事件，例如 "),t("code",[e._v("onClick")]),e._v(" / "),t("code",[e._v("onClickCapture")]),e._v(" ，对于冒泡阶段的事件("),t("code",[e._v("onClick")]),e._v(")，将 "),t("code",[e._v("push")]),e._v(" 到执行队列后面 ， 对于捕获阶段的事件("),t("code",[e._v("onClickCapture")]),e._v(")，将 "),t("code",[e._v("unShift")]),e._v("到执行队列的前面。")]),e._v(" "),t("li",[e._v("③ 最后将事件执行队列，保存到React事件源对象上。等待执行。")])]),e._v(" "),t("p",[e._v("举个例子比如如下")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('handerClick = () => console.log(1)\nhanderClick1 = () => console.log(2)\nhanderClick2 = () => console.log(3) \nhanderClick3= () => console.log(4)\nrender(){\n    return <div onClick={ this.handerClick2 } onClickCapture={this.handerClick3}  > \n        <button onClick={ this.handerClick }  onClickCapture={ this.handerClick1  }  className="button" >点击</button>\n    </div>\n}\n')])])]),t("p",[e._v("打印 // 4  2  1  3")]),e._v(" "),t("p",[e._v("看到这里我们应该知道上述函数打印顺序为什么了吧，首先遍历 "),t("code",[e._v("button")]),e._v(" 对应的fiber，首先遇到了 "),t("code",[e._v("onClickCapture")]),e._v(" ,将 "),t("code",[e._v("handerClick1")]),e._v(" 放到了数组最前面，然后又把"),t("code",[e._v("onClick")]),e._v("对应"),t("code",[e._v("handerClick")]),e._v("的放到数组的最后面，形成的结构是"),t("code",[e._v("[ handerClick1 , handerClick ]")]),e._v("， 然后向上遍历，遇到了"),t("code",[e._v("div")]),e._v("对应fiber,将"),t("code",[e._v("onClickCapture")]),e._v("对应的"),t("code",[e._v("handerClick3")]),e._v("放在了数组前面，将"),t("code",[e._v("onClick")]),e._v("对应的 "),t("code",[e._v("handerClick2")]),e._v(" 放在了数组后面，形成的结构 "),t("code",[e._v("[ handerClick3,handerClick1 , handerClick,handerClick2 ]")]),e._v(" ,所以执行的顺序 // 4  2  1  3，就是这么简单，完美！")]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),e._v("FDEBA681-2E03-420B-A838-5907439837A9.jpg")]),e._v(" "),t("h2",{attrs:{id:"事件触发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件触发"}},[e._v("#")]),e._v(" 事件触发")]),e._v(" "),t("p",[e._v("有的同学可能好奇React的事件源对象是什么样的，以上面代码中"),t("code",[e._v("SyntheticEvent")]),e._v("为例子我们一起来看看：")]),e._v(" "),t("blockquote",[t("p",[e._v("legacy-events/SyntheticEvent.js/")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function SyntheticEvent( dispatchConfig,targetInst,nativeEvent,nativeEventTarget){\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n  this._dispatchListeners = null;\n  this._dispatchInstances = null;\n  this._dispatchCurrentTargets = null;\n  this.isPropagationStopped = () => false; /* 初始化，返回为false  */\n\n}\nSyntheticEvent.prototype={\n    stopPropagation(){ this.isPropagationStopped = () => true;  }, /* React单独处理，阻止事件冒泡函数 */\n    preventDefault(){ },  /* React单独处理，阻止事件捕获函数  */\n    ...\n}\n")])])]),t("p",[e._v("在 "),t("code",[e._v("handerClick")]),e._v(" 中打印 "),t("code",[e._v("e")]),e._v(" :")]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),e._v("B9180401-93FF-4EF0-A2FB-C2FA43B29550.jpg")]),e._v(" "),t("p",[e._v("既然事件执行队列和事件源对象都形成了，接下来就是最后一步"),t("strong",[e._v("事件触发")]),e._v("了。上面大家有没有注意到一个函数"),t("code",[e._v("runEventsInBatch")]),e._v("，所有事件绑定函数，就是在这里触发的。让我们一起看看。")]),e._v(" "),t("blockquote",[t("p",[e._v("legacy-events/EventBatching.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function runEventsInBatch(){\n    const dispatchListeners = event._dispatchListeners;\n    const dispatchInstances = event._dispatchInstances;\n    if (Array.isArray(dispatchListeners)) {\n    for (let i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) { /* 判断是否已经阻止事件冒泡 */\n        break;\n      }\n      \n      dispatchListeners[i](event)\n    }\n  }\n  /* 执行完函数，置空两字段 */\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n")])])]),t("p",[t("code",[e._v("dispatchListeners[i](event)")]),e._v("就是执行我们的事件处理函数比如"),t("code",[e._v("handerClick")]),e._v(",从这里我们知道，"),t("strong",[e._v("我们在事件处理函数中，返回 false ，并不会阻止浏览器默认行为")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("handerClick(){ //并不能阻止浏览器默认行为。\n    return false\n}\n")])])]),t("p",[e._v("应该改成这样：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("handerClick(e){\n    e.preventDefault()\n}\n")])])]),t("p",[e._v("另一方面React对于阻止冒泡，就是通过isPropagationStopped，判断是否已经阻止事件冒泡。如果我们在事件函数执行队列中，某一会函数中，调用"),t("code",[e._v("e.stopPropagation()")]),e._v("，就会赋值给"),t("code",[e._v("isPropagationStopped=()=>true")]),e._v("，当再执行 "),t("code",[e._v("e.isPropagationStopped()")]),e._v("就会返回 "),t("code",[e._v("true")]),e._v(" ,接下来事件处理函数，就不会执行了。")]),e._v(" "),t("h2",{attrs:{id:"其他概念-事件池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他概念-事件池"}},[e._v("#")]),e._v(" 其他概念-事件池")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" handerClick = (e) => {\n    console.log(e.target) // button \n    setTimeout(()=>{\n        console.log(e.target) // null\n    },0)\n}\n")])])]),t("p",[e._v("对于一次点击事件的处理函数，在正常的函数执行上下文中打印"),t("code",[e._v("e.target")]),e._v("就指向了"),t("code",[e._v("dom")]),e._v("元素，但是在"),t("code",[e._v("setTimeout")]),e._v("中打印却是"),t("code",[e._v("null")]),e._v("，如果这不是React事件系统，两次打印的应该是一样的，但是为什么两次打印不一样呢？"),t("strong",[e._v("因为在React采取了一个事件池的概念，每次我们用的事件源对象，在事件函数执行之后，可以通过"),t("code",[e._v("releaseTopLevelCallbackBookKeeping")]),e._v("等方法将事件源对象释放到事件池中，这样的好处每次我们不必再创建事件源对象，可以从事件池中取出一个事件源对象进行复用，在事件处理函数执行完毕后,会释放事件源到事件池中，清空属性，这就是"),t("code",[e._v("setTimeout")]),e._v("中打印为什么是"),t("code",[e._v("null")]),e._v("的原因了。")])]),e._v(" "),t("h2",{attrs:{id:"事件触发总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件触发总结"}},[e._v("#")]),e._v(" 事件触发总结")]),e._v(" "),t("p",[e._v("我把事件触发阶段做的事总结一下：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("①首先通过统一的事件处理函数 "),t("code",[e._v("dispatchEvent")]),e._v(",进行批量更新batchUpdate。")])]),e._v(" "),t("li",[t("strong",[e._v("②然后执行事件对应的处理插件中的"),t("code",[e._v("extractEvents")]),e._v("，合成事件源对象,每次React会从事件源开始，从上遍历类型为 hostComponent即 dom类型的fiber,判断props中是否有当前事件比如onClick,最终形成一个事件执行队列，React就是用这个队列，来模拟事件捕获->事件源->事件冒泡这一过程。")])]),e._v(" "),t("li",[t("strong",[e._v("③最后通过"),t("code",[e._v("runEventsInBatch")]),e._v("执行事件队列，如果发现阻止冒泡，那么break跳出循环，最后重置事件源，放回到事件池中，完成整个流程。")])])]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),e._v("evnent_click.jpg")]),e._v(" "),t("h1",{attrs:{id:"五-关于react-v17版本的事件系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五-关于react-v17版本的事件系统"}},[e._v("#")]),e._v(" 五 关于react v17版本的事件系统")]),e._v(" "),t("p",[e._v("React v17 整体改动不是很大，但是事件系统的改动却不小，首先上述的很多执行函数，在v17版本不复存在了。我来简单描述一下v17事件系统的改版。")]),e._v(" "),t("p",[t("strong",[e._v("1 事件统一绑定container上，ReactDOM.render(app， container);而不是document上，这样好处是有利于微前端的，微前端一个前端系统中可能有多个应用，如果继续采取全部绑定在"),t("code",[e._v("document")]),e._v("上，那么可能多应用下会出现问题。")])]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),e._v("react_17_delegation.png")]),e._v(" "),t("p",[t("strong",[e._v("2 对齐原生浏览器事件")])]),e._v(" "),t("p",[t("code",[e._v("React 17")]),e._v("中终于支持了原生捕获事件的支持， 对齐了浏览器原生标准。同时 "),t("code",[e._v("onScroll")]),e._v(" 事件不再进行事件冒泡。"),t("code",[e._v("onFocus")]),e._v(" 和 "),t("code",[e._v("onBlur")]),e._v(" 使用原生 "),t("code",[e._v("focusin")]),e._v("， "),t("code",[e._v("focusout")]),e._v(" 合成。")]),e._v(" "),t("p",[t("strong",[e._v("3 取消事件池")]),t("code",[e._v("React 17")]),e._v("取消事件池复用，也就解决了上述在"),t("code",[e._v("setTimeout")]),e._v("打印，找不到"),t("code",[e._v("e.target")]),e._v("的问题。")]),e._v(" "),t("h1",{attrs:{id:"六-总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六-总结"}},[e._v("#")]),e._v(" 六 总结")]),e._v(" "),t("p",[e._v("本文从"),t("strong",[e._v("事件合成")]),e._v("，"),t("strong",[e._v("事件绑定")]),e._v("，"),t("strong",[e._v("事件触发")]),e._v("三个方面详细介绍了React事件系统原理，希望大家能通过这篇文章更加深入了解v16 React 事件系统，如果有疑问和不足之处，也希望大家能在评论区指出。")]),e._v(" "),t("p",[e._v("最后, 送人玫瑰，手留余香，觉得有收获的朋友可以给笔者"),t("strong",[e._v("点赞，关注")]),e._v("一波 ，陆续更新前端超硬核文章。")]),e._v(" "),t("p",[e._v("提前透漏：接下来会出一部揭秘"),t("code",[e._v("react")]),e._v("调度系统的文章。感兴趣的同学请关注公众号 "),t("strong",[e._v("前端Sharing")]),e._v(" 第一时间更新前端硬文。")]),e._v(" "),t("h2",{attrs:{id:"往期react文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#往期react文章"}},[e._v("#")]),e._v(" 往期react文章")]),e._v(" "),t("p",[t("strong",[e._v("React进阶系列")])]),e._v(" "),t("p",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=Mzg5MjMxMzY5Mw==&mid=2247484812&idx=1&sn=d38f85074461912dfd53d5afb2a73646&chksm=cfc14cbef8b6c5a81095205f9f82c4b308455f36d261743807b3361e1d1fd5c612a25aaeca68&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("「React进阶」 React全部api解读+基础实践大全(夯实基础万字总结)"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=Mzg5MjMxMzY5Mw==&mid=2247484634&idx=1&sn=618673960ee73b55df82efe886fd6cdd&chksm=cfc14de8f8b6c4fed909929339dd7ed4092af462de88150767173baea4a7fcb3e3ed501daefd&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("「react进阶」一文吃透react-hooks原理"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=Mzg5MjMxMzY5Mw==&mid=2247484613&idx=1&sn=c97b435638d9b21c8869d4e51e3a295a&chksm=cfc14df7f8b6c4e19707a17691c16f43282ad10abc0fb046d4bdf5e4a83e0057e6ab72510e1e&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("「react进阶」一文吃透React高阶组件(HOC)"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=Mzg5MjMxMzY5Mw==&mid=2247484275&idx=1&sn=d0a2f61cfaf0004d9683c7b940ce704e&chksm=cfc14a41f8b6c35772077397e778060c7849ff8a73faf2a38c570215b2d3c924d1d6e87a28b2&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("「react进阶」年终送给react开发者的八条优化建议"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"参考文档"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[e._v("#")]),e._v(" 参考文档")]),e._v(" "),t("ul",[t("li",[e._v("react源码")]),e._v(" "),t("li",[e._v("React 事件系统工作原理")])])])}),[],!1,null,null,null);t.default=v.exports}}]);