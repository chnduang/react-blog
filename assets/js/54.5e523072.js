(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{348:function(e,t,a){"use strict";a.r(t);var o=a(4),c=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"react-组件性能优化-function-component"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-组件性能优化-function-component"}},[e._v("#")]),e._v(" React 组件性能优化—function component")]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/U4dKSNfD1dPsMemu_HAaqA",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/U4dKSNfD1dPsMemu_HAaqA"),t("OutboundLink")],1)])]),e._v(" "),t("h1",{attrs:{id:"_1-前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-前言"}},[e._v("#")]),e._v(" 1. 前言")]),e._v(" "),t("p",[e._v("函数式组件是一种非常简洁的数据驱动 UI 的实现方式。如果将 React 组件拆分成三个部分 —— 数据、计算和渲染，我们可以看到性能优化的几个方向。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCv3wqhIVIl3Swtl0YTVVYtPYtAt6oNpcrRWyrFI1u8PSg0v9P53pkUHc4L5Z9bn03hicMcbax8zuSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("ul",[t("li",[e._v("数据：利用缓存，减少 "),t("code",[e._v("rerender")]),e._v(" 的次数")]),e._v(" "),t("li",[e._v("计算：精确判断更新时机和范围，减少计算量")]),e._v(" "),t("li",[e._v("渲染：精细粒度，降低组件复杂度")])]),e._v(" "),t("p",[e._v("今天主要分享数据层面的性能优化技巧。")]),e._v(" "),t("h2",{attrs:{id:"_1-1-有什么是-hook-能做而-class-做不到的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-有什么是-hook-能做而-class-做不到的"}},[e._v("#")]),e._v(" 1.1. 有什么是 Hook 能做而 class 做不到的？")]),e._v(" "),t("p",[e._v("在学习 React "),t("code",[e._v("hook api")]),e._v(" 的过程中，发现其相比类组件的生命周期，更加抽象且灵活。在 React 官方文档的 "),t("code",[e._v("FAQ")]),e._v(" 中，有一个非常有趣的问题 —— "),t("strong",[t("code",[e._v("有什么是 Hook 能做而 class 做不到的？")])])]),e._v(" "),t("p",[e._v("前阵子我终于找到了其中一个 "),t("code",[e._v("参考答案")]),e._v(" ，此前在开发一个需求时，需要通过 url 或缓存传递一个 "),t("code",[e._v("参数")]),e._v(" 给新打开的 "),t("code",[e._v("Tab")]),e._v("。当 "),t("code",[e._v("Tab")]),e._v(" 下的页面开始加载时，会去读取这个 "),t("code",[e._v("参数")]),e._v("，并且使用它去做一些请求，获取更多的信息进行渲染。")]),e._v(" "),t("p",[e._v("最初拿到这个需求时，我使用了 "),t("code",[e._v("类组件")]),e._v(" 去开发，但实践过程中发现编写出的代码不易理解和管理。最后重构为 "),t("code",[e._v("函数式组件")]),e._v("，让代码简洁了许多。")]),e._v(" "),t("h2",{attrs:{id:"_1-2-一个不好的-🌰-getderivedstatefromprops-componentdidupdate"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-一个不好的-🌰-getderivedstatefromprops-componentdidupdate"}},[e._v("#")]),e._v(" 1.2. 一个不好的 🌰（ "),t("code",[e._v("getDerivedStateFromProps")]),e._v(" + "),t("code",[e._v("componentDidUpdate")]),e._v(" ）")]),e._v(" "),t("p",[e._v("最初我通过 "),t("code",[e._v("getDerivedStateFromProps")]),e._v(" 和 "),t("code",[e._v("componentDidUpdate")]),e._v(" 这两个生命周期。其中 "),t("code",[e._v("getDerivedStateFromProps")]),e._v(" 去实现 "),t("code",[e._v("props")]),e._v(" 的前后对比， "),t("code",[e._v("componentDidUpdate")]),e._v(" 控制组件去请求和更新。")]),e._v(" "),t("p",[e._v("首先我们有一个来自于 url 和缓存的参数，叫做 "),t("code",[e._v("productId")]),e._v("，也可以叫做 "),t("code",[e._v("商品id")]),e._v("，它在发生更新后如何通知父组件，这一点我们不需要在意。现在父组件被通知 "),t("code",[e._v("商品id")]),e._v(" 发生了更新，于是通过 "),t("code",[e._v("props")]),e._v(" 将其传递给了子组件，也就是我们的页面容器。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Parent() {\n  /**\n   * 通过某种方式，监听到 productId 更新了\n   */\n  return <Child productId={productId} />\n}\n")])])]),t("p",[e._v("在父组件改变 "),t("code",[e._v("props")]),e._v(" 中的 "),t("code",[e._v("商品id")]),e._v(" 时，我们的子组件通过 "),t("code",[e._v("getDerivedStateFromProps")]),e._v(" 去监听，经过一段比较逻辑，发生改变则更新 "),t("code",[e._v("state")]),e._v(" 触发组件的重新渲染。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 监听 props 变化，触发组件重新渲染\nstatic getDerivedStateFromProps(nextProps, prevState) {\n  const { productId } = nextProps;\n  // 当传入的 productId 与 state 中的不一致时，更新 state\n  if (productId !== prevState.productId) {\n    // 更新 state，触发重新渲染\n    return { productId };\n  }\n  return null;\n}\n")])])]),t("p",[e._v("接下来，因为 "),t("code",[e._v("商品id")]),e._v(" 发生了更新，组件需要再发一次请求去更新并重新渲染 "),t("code",[e._v("商品")]),e._v(" 的详情信息。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("componentDidUpdate(prevProps, prevState) {\n  /**\n   * state 改变，重新请求\n   * PS: 细心的你可能发现这里又跟旧的 state 比较了一次\n   */\n  if (prevState.productId !== this.state.productId) {\n    this.getProductDetailRequest();\n  }\n}\n\ngetProductDetailRequest = async () => {\n  const { productId } = this.state;\n\n  // 用更新后的 productId 去请求商品详情\n  const { result } = await getProductDetail({\n    f_id: +productId,\n  });\n\n  // setState 重新渲染商品详情\n  this.setState({\n    productDetail: result,\n  });\n};\n")])])]),t("p",[e._v("到这里就实现了我们的需求，但这份代码其实有很多不值得参考的地方：")]),e._v(" "),t("p",[e._v("1、"),t("code",[e._v("componentDidUpdate")]),e._v(" 中的 "),t("code",[e._v("setState")]),e._v(" —— 出于更新 UI 的需要，在 "),t("code",[e._v("componentDidUpdate")]),e._v(" 中又进行了一次 "),t("code",[e._v("setState")]),e._v("，其实是一种危险的写法。假如没有包裹任何条件语句，或者条件语句有漏洞，组件就会进行循环更新，隐患很大。")]),e._v(" "),t("p",[e._v("2、"),t("strong",[e._v("分散在两个生命周期中的两次数据比较")]),e._v(" —— 在一次更新中发生了两次 "),t("code",[e._v("state")]),e._v(" 的比较，虽然性能上没有太大影响，但这意味着修改代码时，要同时维护两处。假如比较逻辑非常复杂，那么改动和测试都很困难。")]),e._v(" "),t("p",[e._v("3、"),t("strong",[e._v("代码复杂度")]),e._v(" —— 仅仅是 demo 就已经编写了很多代码，不利于后续开发者理解和维护。")]),e._v(" "),t("h2",{attrs:{id:"_1-3-另一个不好的-🌰-componentwillreceiveprops"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-另一个不好的-🌰-componentwillreceiveprops"}},[e._v("#")]),e._v(" 1.3. 另一个不好的 🌰（ "),t("code",[e._v("componentWillReceiveProps")]),e._v(" ）")]),e._v(" "),t("p",[e._v("上面的 🌰 中，导致我们必须使用 "),t("code",[e._v("componentDidUpdate")]),e._v(" 的一个主要原因是，"),t("code",[e._v("getDerivedStateFromProps")]),e._v(" 是个静态方法，不能调用类上的 "),t("code",[e._v("this")]),e._v("，异步请求等副作用也不能在此使用。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCv3wqhIVIl3Swtl0YTVVYtPZVwUwp8tsPBiaQwrb4Hk30ysPrV7H4vGUFVX9J5qHmbOwB3nNUGZBIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),t("p",[e._v("为此，我们不妨使用 "),t("code",[e._v("componentWillReceiveProps")]),e._v(" 来实现，在获取到 "),t("code",[e._v("props")]),e._v(" 的时候就能直接发起请求，并且 "),t("code",[e._v("setState")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("componentWillReceiveProps(props) {\n  const { productId } = props;\n  if (`${productId}` === 'null') {\n    // 不请求\n    return;\n  }\n  if (productId !== this.state.productId) {\n    // 商品池详情的id发生改变，重新进行请求\n    this.getProductDetailRequest(productId);\n  }\n}\n")])])]),t("p",[e._v("将逻辑整合到一处，既实现了可控的更新，又能少写很多代码。")]),e._v(" "),t("p",[e._v("但这仅限 "),t("code",[e._v("React 16.4")]),e._v(" 之前。")]),e._v(" "),t("h2",{attrs:{id:"_1-4-class-component-的副作用管理之难"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-class-component-的副作用管理之难"}},[e._v("#")]),e._v(" 1.4. class component 的副作用管理之难")]),e._v(" "),t("p",[e._v("面临上述需求的时候，我们借助了两种方案，但各有缺点。")]),e._v(" "),t("ul",[t("li",[t("p",[t("code",[e._v("componentWillReceiveProps")]),e._v("：")]),e._v(" "),t("p",[t("code",[e._v("React 16.4")]),e._v(" 中将 "),t("code",[e._v("componentWillReceiveProps")]),e._v(" 定义为了 "),t("code",[e._v("unsafe")]),e._v(" 的方法，因为这个方法容易被开发者滥用，引入很多副作用。")]),e._v(" "),t("p",[e._v("正如 "),t("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490621&idx=1&sn=bc3e3ae132985648a2822e38035423f4&chksm=ea0d56c7dd7adfd15934fdbc8bf0218df50353d86196d306dd393f5365aa6f7850c8f75e5c21&mpshare=1&scene=1&srcid=0906S3TuvxMbeos9HLCgnisj&sharer_sharetime=1630926370848&sharer_shareid=127a669cda28f5e879b4b19ecc7309ed&key=8adf9203f7a8000d2840f553bc5f01381b3f0da9305adf7a5211b630069ee9e56fec6e11200984cd1a8af7b711ba9ea1eaa9ac2c5c30995ff26e96f2069e64768f2730d04c46e1770f6101ae321c194aa31c84376dc55f1a6eeb3902c2ae63dd12dff5eed45cce1c490c16269217b0f7870aafefa71cf74c1dc314f863135a65&ascene=1&uin=MTE5NzkwMDQyOA%3D%3D&devicetype=iMac+MacBookPro16%2C1+OSX+OSX+10.16+build(20G95)&version=13010510&nettype=WIFI&lang=zh_CN&fontScale=100&exportkey=AdoErQssmoFO2HXgzKwwo0k%3D&pass_ticket=fLP9V92MomGzP9pH3KLEfsm3bnRI8zfMRwFVqIdz48ri7Mz%2F8fv7z1lJc2RQBBLc&wx_header=0&fontgear=3.000000",target:"_blank",rel:"noopener noreferrer"}},[e._v("React 官方文档_unsafe_componentwillreceiveprops"),t("OutboundLink")],1),e._v(" 提到的，副作用通常建议发生在 "),t("code",[e._v("componentDidUpdate")]),e._v("。但这会造成多一次的渲染，且写法诡异。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("getDerivedStateFromProps")]),e._v(" 和 "),t("code",[e._v("componentDidUpdate")]),e._v("：")]),e._v(" "),t("p",[e._v("作为替代方案的 "),t("code",[e._v("getDerivedStateFromProps")]),e._v(" 是个静态方法，也需要结合 "),t("code",[e._v("componentDidUpdate")]),e._v("，判断是否需要进行必要的 "),t("code",[e._v("render")]),e._v("，本质上没有发生太多改变。")]),e._v(" "),t("p",[t("code",[e._v("getDerivedStateFromProps")]),e._v(" 可以认为是增加了静态方法限制的 "),t("code",[e._v("componentWillReceiveProps")]),e._v("，它们在生命周期中触发的时机是相似的，都起到了接收新的 "),t("code",[e._v("props")]),e._v(" 并更新的作用。")])])]),e._v(" "),t("p",[e._v("甚至当依赖项增多的时候，上述两种方式将会提升代码的复杂度，我们会耗费大量的精力去思考状态的比较以及副作用的管理。而 "),t("code",[e._v("React 16.8")]),e._v(" 之后的 "),t("code",[e._v("函数式组件")]),e._v(" 和 "),t("code",[e._v("hook api")]),e._v("，很好地解决了这一痛点。看看使用了 "),t("code",[e._v("函数式组件")]),e._v(" 是怎样的：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Child({ productId }) {\n  const [productDetail, setProductDetail] = useState({});\n  useEffect(() => {\n    const { result } = await getProductDetail({\n      f_id: +productId,\n    });\n    setProductDetail(result);\n  }, [productId]);\n\n  return <>......</>;\n}\n")])])]),t("p",[e._v("相比上面两个例子，是不是简单得多？上面的 "),t("code",[e._v("useEffect()")]),e._v(" 通过指定依赖项的方式，把令人头疼的副作用进行了管理，仅在依赖项改变时才会执行。")]),e._v(" "),t("p",[e._v("到这里，我们已经花了很长的篇幅去突出 "),t("code",[e._v("函数式组件")]),e._v(" 的妙处。我们能够发现，"),t("code",[e._v("函数式组件")]),e._v(" 可以让我们更多地去关注数据驱动，而不被具体的生命周期所困扰。在 "),t("code",[e._v("函数式组件")]),e._v(" 中，结合 "),t("code",[e._v("hook api")]),e._v("，也可以很好地观察组件性能优化的方向。")]),e._v(" "),t("p",[e._v("这里我们从数据缓存的层面，介绍一下函数式组件的三个性能优化方式 —— "),t("code",[e._v("React.memo")]),e._v("、"),t("code",[e._v("useCallback")]),e._v(" 和 "),t("code",[e._v("useMemo")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"_2-函数式组件性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-函数式组件性能优化"}},[e._v("#")]),e._v(" 2. 函数式组件性能优化")]),e._v(" "),t("h2",{attrs:{id:"_2-1-纯组件-pure-componet"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-纯组件-pure-componet"}},[e._v("#")]),e._v(" 2.1. 纯组件(Pure Componet)")]),e._v(" "),t("p",[e._v("纯组件（Pure Component）来源于函数式编程中纯函数（Pure Function）的概念，纯函数符合以下两个条件：")]),e._v(" "),t("ul",[t("li",[e._v("其返回值仅由其输入值决定")]),e._v(" "),t("li",[e._v("对于相同的输入值，返回值始终相同")])]),e._v(" "),t("p",[e._v("类似的，如果 React 组件"),t("strong",[e._v("为相同的 state 和 props 呈现相同的输出")]),e._v("，则可以将其视为纯组件。")]),e._v(" "),t("h3",{attrs:{id:"_2-1-1-浅层比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-浅层比较"}},[e._v("#")]),e._v(" 2.1.1. 浅层比较")]),e._v(" "),t("p",[e._v("根据数据类型，浅层比较分为两种：")]),e._v(" "),t("ul",[t("li",[e._v("基本数据类型：比较值是否相同")]),e._v(" "),t("li",[e._v("引用数据类型：比较内存中的引用地址是否相同")])]),e._v(" "),t("p",[e._v("浅层比较这一步是优先于 diff 的，能够从上游阻止重新 render。同时浅层比较只比较组件的 state 和 props，消耗更少的性能，不会像 diff 一样重新遍历整颗虚拟 DOM 树。")]),e._v(" "),t("p",[e._v("浅层比较也叫 "),t("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490621&idx=1&sn=bc3e3ae132985648a2822e38035423f4&chksm=ea0d56c7dd7adfd15934fdbc8bf0218df50353d86196d306dd393f5365aa6f7850c8f75e5c21&mpshare=1&scene=1&srcid=0906S3TuvxMbeos9HLCgnisj&sharer_sharetime=1630926370848&sharer_shareid=127a669cda28f5e879b4b19ecc7309ed&key=8adf9203f7a8000d2840f553bc5f01381b3f0da9305adf7a5211b630069ee9e56fec6e11200984cd1a8af7b711ba9ea1eaa9ac2c5c30995ff26e96f2069e64768f2730d04c46e1770f6101ae321c194aa31c84376dc55f1a6eeb3902c2ae63dd12dff5eed45cce1c490c16269217b0f7870aafefa71cf74c1dc314f863135a65&ascene=1&uin=MTE5NzkwMDQyOA%3D%3D&devicetype=iMac+MacBookPro16%2C1+OSX+OSX+10.16+build(20G95)&version=13010510&nettype=WIFI&lang=zh_CN&fontScale=100&exportkey=AdoErQssmoFO2HXgzKwwo0k%3D&pass_ticket=fLP9V92MomGzP9pH3KLEfsm3bnRI8zfMRwFVqIdz48ri7Mz%2F8fv7z1lJc2RQBBLc&wx_header=0&fontgear=3.000000",target:"_blank",rel:"noopener noreferrer"}},[e._v("shallow compare"),t("OutboundLink")],1),e._v("，在 "),t("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490621&idx=1&sn=bc3e3ae132985648a2822e38035423f4&chksm=ea0d56c7dd7adfd15934fdbc8bf0218df50353d86196d306dd393f5365aa6f7850c8f75e5c21&mpshare=1&scene=1&srcid=0906S3TuvxMbeos9HLCgnisj&sharer_sharetime=1630926370848&sharer_shareid=127a669cda28f5e879b4b19ecc7309ed&key=8adf9203f7a8000d2840f553bc5f01381b3f0da9305adf7a5211b630069ee9e56fec6e11200984cd1a8af7b711ba9ea1eaa9ac2c5c30995ff26e96f2069e64768f2730d04c46e1770f6101ae321c194aa31c84376dc55f1a6eeb3902c2ae63dd12dff5eed45cce1c490c16269217b0f7870aafefa71cf74c1dc314f863135a65&ascene=1&uin=MTE5NzkwMDQyOA%3D%3D&devicetype=iMac+MacBookPro16%2C1+OSX+OSX+10.16+build(20G95)&version=13010510&nettype=WIFI&lang=zh_CN&fontScale=100&exportkey=AdoErQssmoFO2HXgzKwwo0k%3D&pass_ticket=fLP9V92MomGzP9pH3KLEfsm3bnRI8zfMRwFVqIdz48ri7Mz%2F8fv7z1lJc2RQBBLc&wx_header=0&fontgear=3.000000",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("React.memo")]),t("OutboundLink")],1),e._v("或 "),t("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247490621&idx=1&sn=bc3e3ae132985648a2822e38035423f4&chksm=ea0d56c7dd7adfd15934fdbc8bf0218df50353d86196d306dd393f5365aa6f7850c8f75e5c21&mpshare=1&scene=1&srcid=0906S3TuvxMbeos9HLCgnisj&sharer_sharetime=1630926370848&sharer_shareid=127a669cda28f5e879b4b19ecc7309ed&key=8adf9203f7a8000d2840f553bc5f01381b3f0da9305adf7a5211b630069ee9e56fec6e11200984cd1a8af7b711ba9ea1eaa9ac2c5c30995ff26e96f2069e64768f2730d04c46e1770f6101ae321c194aa31c84376dc55f1a6eeb3902c2ae63dd12dff5eed45cce1c490c16269217b0f7870aafefa71cf74c1dc314f863135a65&ascene=1&uin=MTE5NzkwMDQyOA%3D%3D&devicetype=iMac+MacBookPro16%2C1+OSX+OSX+10.16+build(20G95)&version=13010510&nettype=WIFI&lang=zh_CN&fontScale=100&exportkey=AdoErQssmoFO2HXgzKwwo0k%3D&pass_ticket=fLP9V92MomGzP9pH3KLEfsm3bnRI8zfMRwFVqIdz48ri7Mz%2F8fv7z1lJc2RQBBLc&wx_header=0&fontgear=3.000000",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("React.PureComponent")]),t("OutboundLink")],1),e._v("出现之前，常用于 "),t("code",[e._v("shouldComponentUpdate")]),e._v(" 中的比较。")]),e._v(" "),t("h3",{attrs:{id:"_2-1-2-纯组件-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-纯组件-api"}},[e._v("#")]),e._v(" 2.1.2. 纯组件 api")]),e._v(" "),t("p",[e._v("对组件输入的数据进行浅层比较，如果当前输入的数据和上一次相同，那么组件就不会重新渲染。相当于，在类组件的 "),t("code",[e._v("shouldComponentUpdate()")]),e._v(" 中使用浅层比较，根据返回值来判断组件是否需要渲染。")]),e._v(" "),t("p",[e._v("纯组件适合定义那些 "),t("code",[e._v("props")]),e._v(" 和 "),t("code",[e._v("state")]),e._v(" 简单的组件，实现上可以总结为："),t("strong",[e._v("类组件继承 PureComponent 类，函数组件使用 memo 方法")]),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"_2-1-3-purecomponent"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-purecomponent"}},[e._v("#")]),e._v(" 2.1.3. PureComponent")]),e._v(" "),t("p",[t("code",[e._v("PureComponent")]),e._v(" 不需要开发者自己实现 "),t("code",[e._v("shouldComponentUpdate()")]),e._v("，就可以进行简单的判断，但仅限浅层比较。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import React, { PureComponent } from 'react';\n\nclass App extends PureComponent {}\nexport default App;\n")])])]),t("p",[e._v("假如依赖的引用数据发生了深层的变化，页面将不会得到更新，从而出现和预期不一致的 UI。当 props 和 state 复杂，需要深层比较的时候，我们更推荐在 Component 中自行实现 "),t("code",[e._v("shouldComponentUpdate()")]),e._v("。")]),e._v(" "),t("p",[e._v("此外，"),t("code",[e._v("React.PureComponent")]),e._v(" 中的 "),t("code",[e._v("shouldComponentUpdate()")]),e._v(" 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是纯组件。")]),e._v(" "),t("h3",{attrs:{id:"_2-1-4-react-memo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-4-react-memo"}},[e._v("#")]),e._v(" 2.1.4. React.memo")]),e._v(" "),t("p",[e._v("React.memo 是一个高阶组件，接受一个组件作为参数返回一个新的组件。新的组件仅检查 props 变更，会将当前的 props 和 上一次的 props 进行浅层比较，相同则阻止渲染。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function MyComponent(props) {\n  /* 使用 props 渲染 */\n}\nfunction areEqual(prevProps, nextProps) {\n  /*\n  memo 的第二个参数\n  可以传入自定义的比较逻辑（仅比较 props），例如实现深层比较\n  ps：与 shouldComponentUpdate 的返回值相反，该方法返回 true 代表的是阻止渲染，返回 false 代表的是 props 发生变化，应当重新渲染\n  */\n}\nexport default React.memo(MyComponent, areEqual);\n")])])]),t("p",[e._v("所以对于函数式组件来说，若实现中拥有 "),t("code",[e._v("useState")]),e._v("、"),t("code",[e._v("useReducer")]),e._v(" 或 "),t("code",[e._v("useContext")]),e._v(" 等 Hook，当 "),t("code",[e._v("state")]),e._v(" 或 "),t("code",[e._v("context")]),e._v(" 发生变化时，即使 props 比较相同，组件依然会重新渲染。所以 React.memo，或者说纯组件，更适合用于 "),t("code",[e._v("renderProps()")]),e._v(" 的情况，通过记忆输入和渲染结果，来提高组件的性能表现。")]),e._v(" "),t("h3",{attrs:{id:"_2-1-5-总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-5-总结"}},[e._v("#")]),e._v(" 2.1.5. 总结")]),e._v(" "),t("p",[e._v("将类组件和函数组件改造为纯组件，更为便捷的应该是函数组件。"),t("code",[e._v("React.memo()")]),e._v(" 可以通过第二个参数自定义比较的逻辑，以高阶函数的形式对组件进行改造，更加灵活。")]),e._v(" "),t("h2",{attrs:{id:"_2-2-usecallback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-usecallback"}},[e._v("#")]),e._v(" 2.2. useCallback")]),e._v(" "),t("p",[e._v("在函数组件中，当 "),t("code",[e._v("props")]),e._v(" 传递了回调函数时，可能会引发子组件的重复渲染。当组件庞大时，这部分不必要的重复渲染将会导致性能问题。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 父组件传递回调\nconst Parent = () => {\n   const [title, setTitle] = useState('标题');\n   const callback = () => { \n     /* do something to change Parent Component‘s state */\n     setTitle('改变标题');\n   };\n   return (\n      <>\n              <h1>{title}</h1>\n         <Child onClick={callback} />\n      </>\n   )\n}\n\n// 子组件使用回调\nconst Child = () => {\n   /* onClick will be changed after Parent Component rerender */const { onClick } = props;\n   return (\n      <>\n         <button onClick={onClick} >change title</button>\n      </>\n   )\n}\n")])])]),t("p",[e._v("props 中的回调函数经常是我们会忽略的参数，执行它时为何会引发自身的改变呢？这是因为回调函数执行过程中，耦合了父组件的状态变化，进而触发父组件的重新渲染，此时对于函数组件来说，会重新执行回调函数的创建，因此给子组件传入了一个新版本的回调函数。")]),e._v(" "),t("p",[e._v("解决这个问题的思路和 "),t("code",[e._v("memo")]),e._v(" 是一样的，我们可以通过 "),t("code",[e._v("useCallback")]),e._v(" 去包装我们即将传递给子组件的回调函数，返回一个 memoized 版本，仅当某个依赖项改变时才会更新。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 父组件传递回调\nconst Parent = () => {\n   const [title, setTitle] = useState('标题');\n   const callback = () => { \n     /* do something to change Parent Component‘s state */\n     setTitle('改变标题');\n   };\n   const memoizedCallback = useCallback(callback, []);\n   return (\n      <>\n              <h1>{title}</h1>\n         <Child onClick={memoizedCallback} />\n      </>\n   )\n}\n\n// 子组件使用回调\nconst Child = (props) => {\n   /* onClick has been memoized */const { onClick } = props;\n   return (\n      <>\n         <button onClick={onClick} >change title</button>\n      </>\n   )\n}\n")])])]),t("p",[e._v("此外，使用上， "),t("code",[e._v("useCallback(fn, deps)")]),e._v(" 相当于 "),t("code",[e._v("useMemo(() => fn, deps)")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"_2-3-usememo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-usememo"}},[e._v("#")]),e._v(" 2.3. useMemo")]),e._v(" "),t("p",[t("code",[e._v("React.memo()")]),e._v(" 和 "),t("code",[e._v("useCallback")]),e._v(" 都通过保证 "),t("code",[e._v("props")]),e._v(" 的稳定性，来减少重新 render 的次数。而减少数据处理中的重复计算，就需要依靠 "),t("code",[e._v("useMemo")]),e._v(" 了。")]),e._v(" "),t("p",[e._v("首先需要明确，"),t("code",[e._v("useMemo")]),e._v(" 中不应该有其他与渲染无关的逻辑，其包裹的函数应当专注于处理我们需要的渲染结果，例如说 UI 上的文本、数值。其他的一些逻辑如请求，应当放在 "),t("code",[e._v("useEffect")]),e._v(" 去实现。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function computeExpensiveValue() {\n  /* a calculating process needs long time */\n  return xxx\n}\n\nconst memoizedValue = useMemo(computeExpensiveValue, [a, b]);\n")])])]),t("p",[e._v("如果没有提供依赖项数组，"),t("code",[e._v("useMemo")]),e._v(" 在每次渲染时都会计算新的值。")]),e._v(" "),t("p",[e._v("以阶乘计算为例：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function CalculateFactorial() {\n  const [number, setNumber] = useState(1);\n  const [inc, setInc] = useState(0);\n\n  // Bad —— calculate again and console.log('factorialOf(n) called!');\n  // const factorial = factorialOf(number);\n  \n  // Good —— memoized\n  const factorial = useMemo(() => factorialOf(number), [number]);\n\n  const onChange = event => {\n    setNumber(Number(event.target.value));\n  };\n  const onClick = () => setInc(i => i + 1);\n  \n  return (\n    <div>\n      Factorial of \n      <input type=\"number\" value={number} onChange={onChange} />\n      is {factorial}\n      <button onClick={onClick}>Re-render</button>\n    </div>\n  );\n}\n\nfunction factorialOf(n) {\n  console.log('factorialOf(n) called!');\n  return n <= 0 ? 1 : n * factorialOf(n - 1);\n}\n")])])]),t("p",[e._v("经过 "),t("code",[e._v("useMemo")]),e._v(" 封装，"),t("code",[e._v("factorial")]),e._v(" 成为了一个记忆值。当我们点击重新渲染的按钮时，"),t("code",[e._v("inc")]),e._v(" 发生了改变引起函数式组件的 rerender，但由于依赖项 "),t("code",[e._v("number")]),e._v(" 未发生改变，所以 "),t("code",[e._v("factorial")]),e._v(" 直接返回了记忆值。")]),e._v(" "),t("h1",{attrs:{id:"_3-总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-总结"}},[e._v("#")]),e._v(" 3. 总结")]),e._v(" "),t("p",[e._v("1、通过 函数式组件 结合 hook api，能够以更简洁的方式管理我们的副作用，在涉及到类似前言的问题时，更推荐把组件改造成函数式组件。")]),e._v(" "),t("p",[e._v("2、用一个通俗的说法去区分 "),t("code",[e._v("React.memo")]),e._v(" 、"),t("code",[e._v("useCallback")]),e._v(" 和 "),t("code",[e._v("useMemo")]),e._v(" ， 那大概就是：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("React.memo()")]),e._v(" ：缓存虚拟 DOM（组件 UI）")]),e._v(" "),t("li",[t("code",[e._v("useCallback")]),e._v(" ：缓存函数")]),e._v(" "),t("li",[t("code",[e._v("useMemo")]),e._v(" ：缓存值")])])])}),[],!1,null,null,null);t.default=c.exports}}]);