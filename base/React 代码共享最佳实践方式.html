<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 代码共享最佳实践方式 | duangdong的react</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="react相关知识归纳总结">
    <meta name="keywords" content="react,react进阶,react性能优化,react-hooks,react源码">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.27287fd6.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/53.09fd35d1.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/100.27126660.js"><link rel="prefetch" href="/assets/js/101.09cf74ec.js"><link rel="prefetch" href="/assets/js/102.8cd6b4eb.js"><link rel="prefetch" href="/assets/js/103.c4f25168.js"><link rel="prefetch" href="/assets/js/104.4f1b4569.js"><link rel="prefetch" href="/assets/js/105.bc4fc023.js"><link rel="prefetch" href="/assets/js/106.b9d5be0c.js"><link rel="prefetch" href="/assets/js/107.f9a44dd7.js"><link rel="prefetch" href="/assets/js/108.0424a7b7.js"><link rel="prefetch" href="/assets/js/109.086a89ae.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/110.1e4c2c77.js"><link rel="prefetch" href="/assets/js/111.16e80560.js"><link rel="prefetch" href="/assets/js/112.441e61a6.js"><link rel="prefetch" href="/assets/js/113.41a44465.js"><link rel="prefetch" href="/assets/js/114.9efb5469.js"><link rel="prefetch" href="/assets/js/115.d095bf75.js"><link rel="prefetch" href="/assets/js/116.b368a7c1.js"><link rel="prefetch" href="/assets/js/117.3a319a71.js"><link rel="prefetch" href="/assets/js/118.7ea17677.js"><link rel="prefetch" href="/assets/js/119.df1f998f.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/120.935f9aea.js"><link rel="prefetch" href="/assets/js/121.c09de772.js"><link rel="prefetch" href="/assets/js/122.32443376.js"><link rel="prefetch" href="/assets/js/123.d0f8ea63.js"><link rel="prefetch" href="/assets/js/124.fdbcd92d.js"><link rel="prefetch" href="/assets/js/125.0de5eb94.js"><link rel="prefetch" href="/assets/js/126.fb5e629b.js"><link rel="prefetch" href="/assets/js/127.866d8d58.js"><link rel="prefetch" href="/assets/js/128.1aad073e.js"><link rel="prefetch" href="/assets/js/129.328f52fd.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/130.ac9676d9.js"><link rel="prefetch" href="/assets/js/131.9852c015.js"><link rel="prefetch" href="/assets/js/132.806bcfe3.js"><link rel="prefetch" href="/assets/js/133.073ecd1e.js"><link rel="prefetch" href="/assets/js/134.e2683d73.js"><link rel="prefetch" href="/assets/js/135.d16cdb0b.js"><link rel="prefetch" href="/assets/js/136.c3b47da6.js"><link rel="prefetch" href="/assets/js/137.f7fec328.js"><link rel="prefetch" href="/assets/js/138.ec6ab500.js"><link rel="prefetch" href="/assets/js/139.18b97522.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/140.c7df1047.js"><link rel="prefetch" href="/assets/js/141.484c6ca5.js"><link rel="prefetch" href="/assets/js/142.8eff7a66.js"><link rel="prefetch" href="/assets/js/143.60569694.js"><link rel="prefetch" href="/assets/js/144.01883b7c.js"><link rel="prefetch" href="/assets/js/145.a9241012.js"><link rel="prefetch" href="/assets/js/146.4b6f364c.js"><link rel="prefetch" href="/assets/js/147.9ed57153.js"><link rel="prefetch" href="/assets/js/148.e18d806a.js"><link rel="prefetch" href="/assets/js/149.e24c9de5.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/23.f1afbc9c.js"><link rel="prefetch" href="/assets/js/24.7f3fc444.js"><link rel="prefetch" href="/assets/js/25.5a945cd4.js"><link rel="prefetch" href="/assets/js/26.7ef56339.js"><link rel="prefetch" href="/assets/js/27.74941107.js"><link rel="prefetch" href="/assets/js/28.20a36928.js"><link rel="prefetch" href="/assets/js/29.7cda6a44.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.97f5cf7e.js"><link rel="prefetch" href="/assets/js/31.eeee5c14.js"><link rel="prefetch" href="/assets/js/32.a2125816.js"><link rel="prefetch" href="/assets/js/33.b3fdf3bc.js"><link rel="prefetch" href="/assets/js/34.908ac5fb.js"><link rel="prefetch" href="/assets/js/35.9459a7c7.js"><link rel="prefetch" href="/assets/js/36.dc8e2582.js"><link rel="prefetch" href="/assets/js/37.27c69606.js"><link rel="prefetch" href="/assets/js/38.10b82911.js"><link rel="prefetch" href="/assets/js/39.fdc5aecb.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.901c96dc.js"><link rel="prefetch" href="/assets/js/41.4cbb9c4b.js"><link rel="prefetch" href="/assets/js/42.da47ce58.js"><link rel="prefetch" href="/assets/js/43.a7669073.js"><link rel="prefetch" href="/assets/js/44.08cc8605.js"><link rel="prefetch" href="/assets/js/45.5461c987.js"><link rel="prefetch" href="/assets/js/46.4c5ed7f9.js"><link rel="prefetch" href="/assets/js/47.450abe13.js"><link rel="prefetch" href="/assets/js/48.d0a778f3.js"><link rel="prefetch" href="/assets/js/49.611d9085.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.2563fd92.js"><link rel="prefetch" href="/assets/js/51.ff64258c.js"><link rel="prefetch" href="/assets/js/52.d47acb9b.js"><link rel="prefetch" href="/assets/js/54.5e523072.js"><link rel="prefetch" href="/assets/js/55.8278650d.js"><link rel="prefetch" href="/assets/js/56.425f7e44.js"><link rel="prefetch" href="/assets/js/57.44699db6.js"><link rel="prefetch" href="/assets/js/58.25067fcf.js"><link rel="prefetch" href="/assets/js/59.3814ee9e.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/60.82621500.js"><link rel="prefetch" href="/assets/js/61.9880375b.js"><link rel="prefetch" href="/assets/js/62.3924c2b9.js"><link rel="prefetch" href="/assets/js/63.ff3650b8.js"><link rel="prefetch" href="/assets/js/64.0d46b236.js"><link rel="prefetch" href="/assets/js/65.f255f222.js"><link rel="prefetch" href="/assets/js/66.d797120d.js"><link rel="prefetch" href="/assets/js/67.aa46c62c.js"><link rel="prefetch" href="/assets/js/68.0dbf39cf.js"><link rel="prefetch" href="/assets/js/69.116b53df.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/70.a05986f2.js"><link rel="prefetch" href="/assets/js/71.562a4365.js"><link rel="prefetch" href="/assets/js/72.c10c6194.js"><link rel="prefetch" href="/assets/js/73.d85c71e5.js"><link rel="prefetch" href="/assets/js/74.73f72e00.js"><link rel="prefetch" href="/assets/js/75.62c76a28.js"><link rel="prefetch" href="/assets/js/76.8d0d9036.js"><link rel="prefetch" href="/assets/js/77.4ede6642.js"><link rel="prefetch" href="/assets/js/78.7d4d4152.js"><link rel="prefetch" href="/assets/js/79.720e767d.js"><link rel="prefetch" href="/assets/js/80.e9d86233.js"><link rel="prefetch" href="/assets/js/81.40ea5e9f.js"><link rel="prefetch" href="/assets/js/82.78074ee1.js"><link rel="prefetch" href="/assets/js/83.72133cbf.js"><link rel="prefetch" href="/assets/js/84.52c5ea65.js"><link rel="prefetch" href="/assets/js/85.afce36a7.js"><link rel="prefetch" href="/assets/js/86.bdc638dd.js"><link rel="prefetch" href="/assets/js/87.11e34480.js"><link rel="prefetch" href="/assets/js/88.5fd9f0ef.js"><link rel="prefetch" href="/assets/js/89.718ec134.js"><link rel="prefetch" href="/assets/js/90.11f956de.js"><link rel="prefetch" href="/assets/js/91.985d80f2.js"><link rel="prefetch" href="/assets/js/92.9c876df3.js"><link rel="prefetch" href="/assets/js/93.da92c068.js"><link rel="prefetch" href="/assets/js/94.cf4ee959.js"><link rel="prefetch" href="/assets/js/95.665f55e6.js"><link rel="prefetch" href="/assets/js/96.2e80356d.js"><link rel="prefetch" href="/assets/js/97.d7d8ba2d.js"><link rel="prefetch" href="/assets/js/98.70eab878.js"><link rel="prefetch" href="/assets/js/99.60ddb42d.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的react</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/events/" class="nav-link">
  事件机制
</a></div><div class="nav-item"><a href="/fiber/" class="nav-link">
  Fiber
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  进阶
</a></div><div class="nav-item"><a href="/hooks/" class="nav-link">
  Hooks
</a></div><div class="nav-item"><a href="/source-code/" class="nav-link">
  源码解读
</a></div><div class="nav-item"><a href="/performance/" class="nav-link">
  性能优化
</a></div><div class="nav-item"><a href="/base/" class="nav-link router-link-active">
  基础
</a></div><div class="nav-item"><a href="/jest/" class="nav-link">
  单元测试
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/events/" class="nav-link">
  事件机制
</a></div><div class="nav-item"><a href="/fiber/" class="nav-link">
  Fiber
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  进阶
</a></div><div class="nav-item"><a href="/hooks/" class="nav-link">
  Hooks
</a></div><div class="nav-item"><a href="/source-code/" class="nav-link">
  源码解读
</a></div><div class="nav-item"><a href="/performance/" class="nav-link">
  性能优化
</a></div><div class="nav-item"><a href="/base/" class="nav-link router-link-active">
  基础
</a></div><div class="nav-item"><a href="/jest/" class="nav-link">
  单元测试
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/base/" aria-current="page" class="sidebar-link">性能优化</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>6-SSR</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>7-hooks基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Native</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/base/React 代码共享最佳实践方式.html" class="active sidebar-link">React 代码共享最佳实践方式</a></li><li><a href="/base/React组件性能优化—function-component.html" class="sidebar-link">React 组件性能优化—function component</a></li><li><a href="/base/clean-react.html" class="sidebar-link">如何编写Cleaner React代码</a></li><li><a href="/base/life.html" class="sidebar-link">componentWillReceiveProps</a></li><li><a href="/base/propType.html" class="sidebar-link">propType</a></li><li><a href="/base/修改端口.html" class="sidebar-link">关于脚手架生成的运行端口配置</a></li><li><a href="/base/初学.html" class="sidebar-link">今日小结</a></li><li><a href="/base/如何使用React创建视频和动画.html" class="sidebar-link">如何使用React创建视频和动画</a></li><li><a href="/base/提高 React 代码质量.html" class="sidebar-link">6 个提高 React 代码质量的方法 - 让你的 React 代码更简洁</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="react-代码共享最佳实践方式"><a href="#react-代码共享最佳实践方式" class="header-anchor">#</a> React 代码共享最佳实践方式</h2> <blockquote><p><a href="https://mp.weixin.qq.com/s/xhiMjirgUhfO9dVqY5M9tQ" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/xhiMjirgUhfO9dVqY5M9tQ<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>任何一个项目发展到一定复杂性的时候，必然会面临逻辑复用的问题。在<code>React</code>中实现逻辑复用通常有以下几种方式：<code>Mixin</code>、<code>高阶组件(HOC)</code>、<code>修饰器(decorator)</code>、<code>Render Props</code>、<code>Hook</code>。本文主要就以上几种方式的优缺点作分析，帮助开发者针对业务场景作出更适合的方式。</p> <h2 id="mixin"><a href="#mixin" class="header-anchor">#</a> <strong>Mixin</strong>**—**</h2> <p>这或许是刚从<code>Vue</code>转向<code>React</code>的开发者第一个能够想到的方法。<code>Mixin</code>一直被广泛用于各种面向对象的语言中，<strong>其作用是为单继承语言创造一种类似多重继承的效果</strong>。虽然现在<code>React</code>已将其放弃中，但<code>Mixin</code>的确曾是<code>React</code>实现代码共享的一种设计模式。</p> <p>广义的 mixin 方法，就是用赋值的方式将 mixin 对象中的方法都挂载到原对象上，来实现对象的混入，类似 ES6 中的 Object.assign()的作用。原理如下：</p> <div class="language- extra-class"><pre class="language-text"><code>const mixin = function (obj, mixins) {
  const newObj = obj
  newObj.prototype = Object.create(obj.prototype)

  for (let prop in mixins) {
    // 遍历mixins的属性
    if (mixins.hasOwnPrototype(prop)) {
      // 判断是否为mixin的自身属性
      newObj.prototype[prop] = mixins[prop]; // 赋值
    }
  }
  return newObj
};
</code></pre></div><h3 id="在-react-中使用-mixin"><a href="#在-react-中使用-mixin" class="header-anchor">#</a> 在 React 中使用 Mixin</h3> <p>假设在我们的项目中，多个组件都需要设置默认的<code>name</code>属性，使用<code>mixin</code>可以使我们不必在不同的组件里写多个同样的<code>getDefaultProps</code>方法，我们可以定义一个<code>mixin</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>const DefaultNameMixin = {
  getDefaultProps: function () {
    return {
      name: &quot;Joy&quot;
    }
  }
}
</code></pre></div><p>为了使用<code>mixin</code>，需要在组件中加入<code>mixins</code>属性，然后把我们写好的<code>mixin</code>包裹成一个数组，将它作为<code>mixins</code>的属性值：</p> <div class="language- extra-class"><pre class="language-text"><code>const ComponentOne = React.createClass({
  mixins: [DefaultNameMixin]
  render: function () {
    return &lt;h2&gt;Hello {this.props.name}&lt;/h2&gt;
  }
})
</code></pre></div><p><strong>写好的<code>mixin</code>可以在其他组件里重复使用。</strong></p> <p>由于<code>mixins</code>属性值是一个数组，意味着我们<strong>可以同一个组件里调用多个<code>mixin</code></strong>。在上述例子中稍作更改得到：</p> <div class="language- extra-class"><pre class="language-text"><code>const DefaultFriendMixin = {
  getDefaultProps: function () {
    return {
      friend: &quot;Yummy&quot;
    }
  }
}

const ComponentOne = React.createClass({
  mixins: [DefaultNameMixin, DefaultFriendMixin]
  render: function () {
    return (
      &lt;div&gt;
        &lt;h2&gt;Hello {this.props.name}&lt;/h2&gt;
        &lt;h2&gt;This is my friend {this.props.friend}&lt;/h2&gt;
      &lt;/div&gt;
    )
  }
})
</code></pre></div><p><strong>我们甚至可以在一个<code>mixin</code>里包含其他的<code>mixin</code></strong>。</p> <p>比如写一个新的<code>mixin``DefaultProps</code>包含以上的<code>DefaultNameMixin</code>和<code>DefaultFriendMixin</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>const DefaultPropsMixin = {
  mixins: [DefaultNameMixin, DefaultFriendMixin]
}

const ComponentOne = React.createClass({
  mixins: [DefaultPropsMixin]
  render: function () {
    return (
      &lt;div&gt;
        &lt;h2&gt;Hello {this.props.name}&lt;/h2&gt;
        &lt;h2&gt;This is my friend {this.props.friend}&lt;/h2&gt;
      &lt;/div&gt;
    )
  }
})
</code></pre></div><p>至此，我们可以总结出<code>mixin</code>至少拥有以下优势:</p> <ul><li><strong>可以在多个组件里使用相同的<code>mixin</code></strong>；</li> <li><strong>可以在同一个组件里使用多个<code>mixin</code></strong>；</li> <li><strong>可以在同一个<code>mixin</code>里嵌套多个<code>mixin</code></strong>；</li></ul> <p>但是在不同场景下，优势也可能变成劣势：</p> <ul><li><strong>破坏原有组件的封装，可能需要去维护新的<code>state</code>和<code>props</code>等状态</strong>；</li> <li><strong>不同<code>mixin</code>里的命名不可知，非常容易发生冲突</strong>；</li> <li><strong>可能产生递归调用问题，增加了项目复杂性和维护难度</strong>；</li></ul> <p>除此之外，<code>mixin</code>在状态冲突、方法冲突、多个生命周期方法的调用顺序等问题拥有自己的处理逻辑。感兴趣的同学可以参考一下以下文章：</p> <ul><li><strong>React Mixin 的使用</strong>[1]</li> <li><strong>Mixins Considered Harmful</strong>[2]</li></ul> <h2 id="高阶组件"><a href="#高阶组件" class="header-anchor">#</a> <strong>高阶组件</strong>**—**</h2> <p>由于<code>mixin</code>存在上述缺陷，故<code>React</code>剥离了<code>mixin</code>，改用<code>高阶组件</code>来取代它。</p> <p><strong><code>高阶组件</code>本质上是一个函数，它接受一个组件作为参数，返回一个新的组件</strong>。</p> <p><code>React</code>官方在实现一些公共组件时，也用到了<code>高阶组件</code>，比如<code>react-router</code>中的<code>withRouter</code>，以及<code>Redux</code>中的<code>connect</code>。在这以<code>withRouter</code>为例。</p> <p>默认情况下，必须是经过<code>Route</code>路由匹配渲染的组件才存在<code>this.props</code>、才拥有<code>路由参数</code>、才能使用<code>函数式导航</code>的写法执行<code>this.props.history.push('/next')</code>跳转到对应路由的页面。<code>高阶组件</code>中的<code>withRouter</code>作用是将一个没有被<code>Route</code>路由包裹的组件，包裹到<code>Route</code>里面，从而将<code>react-router</code>的三个对象<code>history</code>、<code>location</code>、<code>match</code>放入到该组件的<code>props</code>属性里，因此能实现<code>函数式导航跳转</code>。</p> <p><code>withRouter</code>的实现原理：</p> <div class="language- extra-class"><pre class="language-text"><code>const withRouter = (Component) =&gt; {
  const displayName = `withRouter(${Component.displayName || Component.name})`
  const C = props =&gt; {
    const { wrappedComponentRef, ...remainingProps } = props
    return (
      &lt;RouterContext.Consumer&gt;
        {context =&gt; {
          invariant(
            context,
            `You should not use &lt;${displayName} /&gt; outside a &lt;Router&gt;`
          );
          return (
            &lt;Component
              {...remainingProps}
              {...context}
              ref={wrappedComponentRef}
            /&gt;
          )
        }}
      &lt;/RouterContext.Consumer&gt;
    )
}
</code></pre></div><p>使用代码：</p> <div class="language- extra-class"><pre class="language-text"><code>import React, { Component } from &quot;react&quot;
import { withRouter } from &quot;react-router&quot;
class TopHeader extends Component {
  render() {
    return (
      &lt;div&gt;
        导航栏
        {/* 点击跳转login */}
        &lt;button onClick={this.exit}&gt;退出&lt;/button&gt;
      &lt;/div&gt;
    )
  }

  exit = () =&gt; {
    // 经过withRouter高阶函数包裹，就可以使用this.props进行跳转操作
    this.props.history.push(&quot;/login&quot;)
  }
}
// 使用withRouter包裹组件，返回history,location等
export default withRouter(TopHeader)
</code></pre></div><p>由于<code>高阶组件</code>的本质是<code>获取组件并且返回新组件的方法</code>，所以理论上它也可以像<code>mixin</code>一样实现多重嵌套。</p> <p>例如：</p> <p>写一个赋能唱歌的高阶函数</p> <div class="language- extra-class"><pre class="language-text"><code>import React, { Component } from 'react'

const widthSinging = WrappedComponent =&gt; {
 return class HOC extends Component {
  constructor () {
   super(...arguments)
   this.singing = this.singing.bind(this)
  }

  singing = () =&gt; {
   console.log('i am singing!')
  }

  render() {
   return &lt;WrappedComponent /&gt;
  }
 }
}
</code></pre></div><p>写一个赋能跳舞的高阶函数</p> <div class="language- extra-class"><pre class="language-text"><code>import React, { Component } from 'react'

const widthDancing = WrappedComponent =&gt; {
 return class HOC extends Component {
  constructor () {
   super(...arguments)
   this.dancing = this.dancing.bind(this)
  }

  dancing = () =&gt; {
   console.log('i am dancing!')
  }

  render() {
   return &lt;WrappedComponent /&gt;
  }
 }
}
</code></pre></div><p>使用以上高阶组件</p> <div class="language- extra-class"><pre class="language-text"><code>import React, { Component } from &quot;react&quot;
import { widthSing, widthDancing } from &quot;hocs&quot;

class Joy extends Component {
  render() {
    return &lt;div&gt;Joy&lt;/div&gt;
  }
}

// 给Joy赋能唱歌和跳舞的特长
export default widthSinging(withDancing(Joy))
</code></pre></div><p>由上可见，只需使用高阶函数进行简单的包裹，就可以把原本单纯的 Joy 变成一个既能唱歌又能跳舞的夜店小王子了！</p> <h3 id="使用-hoc-的约定"><a href="#使用-hoc-的约定" class="header-anchor">#</a> 使用 HOC 的约定</h3> <p>在使用<code>HOC</code>的时候，有一些墨守成规的约定：</p> <ul><li>将不相关的 Props 传递给包装组件（传递与其具体内容无关的 props）；</li> <li>分步组合（避免不同形式的 HOC 串联调用）；</li> <li>包含显示的 displayName 方便调试（每个 HOC 都应该符合规则的显示名称）；</li> <li>不要在<code>render</code>函数中使用高阶组件（每次 render，高阶都返回新组件，影响 diff 性能）；</li> <li>静态方法必须被拷贝（经过高阶返回的新组件，并不会包含原始组件的静态方法）；</li> <li>避免使用 ref（ref 不会被传递）;</li></ul> <h3 id="hoc-的优缺点"><a href="#hoc-的优缺点" class="header-anchor">#</a> HOC 的优缺点</h3> <p>至此我们可以总结一下<code>高阶组件(HOC)</code>的优点：</p> <ul><li><code>HOC</code>是一个纯函数，便于使用和维护；</li> <li>同样由于<code>HOC</code>是一个纯函数，支持传入多个参数，增强其适用范围；</li> <li><code>HOC</code>返回的是一个组件，可组合嵌套，灵活性强；</li></ul> <p>当然<code>HOC</code>也会存在一些问题：</p> <ul><li>当多个<code>HOC</code>嵌套使用时，无法直接判断子组件的<code>props</code>是从哪个<code>HOC</code>负责传递的；</li> <li>当父子组件有同名<code>props</code>，会导致父组件覆盖子组件同名<code>props</code>的问题，且<code>react</code>不会报错，开发者感知性低；</li> <li>每一个<code>HOC</code>都返回一个新组件，从而产生了很多无用组件，同时加深了组件层级，不便于排查问题；</li></ul> <p><code>修饰器</code>和<code>高阶组件</code>属于同一模式，在此不展开讨论。</p> <h2 id="render-props"><a href="#render-props" class="header-anchor">#</a> <strong>Render Props</strong>**—**</h2> <p><strong><code>Render Props</code>是一种非常灵活复用性非常高的模式，它可以把特定行为或功能封装成一个组件，提供给其他组件使用让其他组件拥有这样的能力</strong>。</p> <blockquote><p>The term “render prop” refers to a technique for sharing code between React components using a prop whose value is a function.</p></blockquote> <p>这是<code>React</code>官方对于<code>Render Props</code>的定义，翻译成大白话即：“<code>Render Props</code>是实现<code>React Components</code>之间代码共享的一种技术，组件的<code>props</code>里边包含有一个<code>function</code>类型的属性，组件可以调用该<code>props</code>属性来实现组件内部渲染逻辑”。</p> <p>官方示例：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;DataProvider render={(data) =&gt; &lt;h1&gt;Hello {data.target}&lt;/h1&gt;} /&gt;
</code></pre></div><p>如上，<code>DataProvider</code>组件拥有一个叫做<code>render</code>（也可以叫做其他名字）的<code>props</code>属性，该属性是一个函数，并且这个函数返回了一个<code>React Element</code>，在组件内部通过调用该函数来完成渲染，那么这个组件就用到了<code>render props</code>技术。</p> <p>读者或许会疑惑，“我们为什么需要调用<code>props</code>属性来实现组件内部渲染，而不直接在组件内完成渲染”？借用<code>React</code>官方的答复，<code>render props</code>并非每个<code>React</code>开发者需要去掌握的技能，甚至你或许永远都不会用到这个方法，但它的存在的确为开发者在思考组件代码共享的问题时，提供了多一种选择。</p> <h3 id="render-props使用场景"><a href="#render-props使用场景" class="header-anchor">#</a> <code>Render Props</code>使用场景</h3> <p>我们在项目开发中可能需要频繁的用到弹窗，弹窗 UI 可以千变万化，但是功能却是类似的，即<code>打开</code>和<code>关闭</code>。以<code>antd</code>为例：</p> <div class="language- extra-class"><pre class="language-text"><code>import { Modal, Button } from &quot;antd&quot;
class App extends React.Component {
  state = { visible: false }

  // 控制弹窗显示隐藏
  toggleModal = (visible) =&gt; {
    this.setState({ visible })
  };

  handleOk = (e) =&gt; {
    // 做点什么
    this.setState({ visible: false })
  }

  render() {
    const { visible } = this.state
    return (
      &lt;div&gt;
        &lt;Button onClick={this.toggleModal.bind(this, true)}&gt;Open&lt;/Button&gt;
        &lt;Modal
          title=&quot;Basic Modal&quot;
          visible={visible}
          onOk={this.handleOk}
          onCancel={this.toggleModal.bind(this, false)}
        &gt;
          &lt;p&gt;Some contents...&lt;/p&gt;
        &lt;/Modal&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre></div><p>以上是最简单的<code>Model</code>使用实例，即便是简单的使用，我们仍需要关注它的显示状态，实现它的切换方法。但是开发者其实只想关注与业务逻辑相关的<code>onOk</code>，理想的使用方式应该是这样的：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;MyModal&gt;
  &lt;Button&gt;Open&lt;/Button&gt;
  &lt;Modal title=&quot;Basic Modal&quot; onOk={this.handleOk}&gt;
    &lt;p&gt;Some contents...&lt;/p&gt;
  &lt;/Modal&gt;
&lt;/MyModal&gt;
</code></pre></div><p>可以通过<code>render props</code>实现以上使用方式：</p> <div class="language- extra-class"><pre class="language-text"><code>import { Modal, Button } from &quot;antd&quot;
class MyModal extends React.Component {
  state = { on: false }

  toggle = () =&gt; {
    this.setState({
      on: !this.state.on
    })
  }

  renderButton = (props) =&gt; &lt;Button {...props} onClick={this.toggle} /&gt;

  renderModal = ({ onOK, ...rest }) =&gt; (
    &lt;Modal
      {...rest}
      visible={this.state.on}
      onOk={() =&gt; {
        onOK &amp;&amp; onOK()
        this.toggle()
      }}
      onCancel={this.toggle}
    /&gt;
  )

  render() {
    return this.props.children({
      Button: this.renderButton,
      Modal: this.renderModal
    })
  }
}
</code></pre></div><p>这样我们就完成了一个具备状态和基础功能的<code>Modal</code>，我们在其他页面使用该<code>Modal</code>时，只需要关注特定的业务逻辑即可。</p> <p>以上可以看出，<code>render props</code>是一个真正的<code>React</code>组件，而不是像<code>HOC</code>一样只是一个<strong>可以返回组件的函数</strong>，这也意味着使用<code>render props</code>不会像<code>HOC</code>一样产生组件层级嵌套的问题，也不用担心<code>props</code>命名冲突产生的覆盖问题。</p> <h3 id="render-props使用限制"><a href="#render-props使用限制" class="header-anchor">#</a> <code>render props</code>使用限制</h3> <p>在<code>render props</code>中应该避免使用<code>箭头函数</code>，因为这会造成性能影响。</p> <p>比如：</p> <div class="language- extra-class"><pre class="language-text"><code>// 不好的示例
class MouseTracker extends React.Component {
  render() {
    return (
      &lt;Mouse render={mouse =&gt; (
        &lt;Cat mouse={mouse} /&gt;
      )}/&gt;
    )
  }
}
</code></pre></div><p>这样写是不好的，因为<code>render</code>方法是有可能多次渲染的，使用<code>箭头函数</code>，会导致每次渲染的时候，传入<code>render</code>的值都会不一样，而实际上并没有差别，这样会导致性能问题。</p> <p>所以更好的写法应该是将传入<code>render</code>里的函数定义为实例方法，这样即便我们多次渲染，但是绑定的始终是同一个函数。</p> <div class="language- extra-class"><pre class="language-text"><code>// 好的示例
class MouseTracker extends React.Component {
  renderCat(mouse) {
   return &lt;Cat mouse={mouse} /&gt;
  }

  render() {
    return (
    &lt;Mouse render={this.renderTheCat} /&gt;
    )
  }
}
</code></pre></div><h3 id="render-props的优缺点"><a href="#render-props的优缺点" class="header-anchor">#</a> <code>render props</code>的优缺点</h3> <ul><li><p>优点</p></li> <li><ul><li>props 命名可修改，不存在相互覆盖；</li> <li>清楚 props 来源；</li> <li>不会出现组件多层嵌套；</li></ul></li> <li><p>缺点</p></li> <li><ul><li><p>写法繁琐；</p></li> <li><p>无法在<code>return</code>语句外访问数据；</p></li> <li><p>容易产生函数回调嵌套；</p> <p>如下代码：</p> <div class="language- extra-class"><pre class="language-text"><code>const MyComponent = () =&gt; {
  return (
    &lt;Mouse&gt;
      {({ x, y }) =&gt; (
        &lt;Page&gt;
          {({ x: pageX, y: pageY }) =&gt; (
            &lt;Connection&gt;
              {({ api }) =&gt; {
                // yikes
              }}
            &lt;/Connection&gt;
          )}
        &lt;/Page&gt;
      )}
    &lt;/Mouse&gt;
  )
}
</code></pre></div></li></ul></li></ul> <h2 id="hook"><a href="#hook" class="header-anchor">#</a> <strong>Hook</strong>**—**</h2> <p><code>React</code>的核心是组件，因此，<code>React</code>一直致力于优化和完善声明组件的方式。从最早的<code>类组件</code>，再到<code>函数组件</code>，各有优缺点。<code>类组件</code>可以给我们提供一个完整的生命周期和状态（state）,但是在写法上却十分笨重，而<code>函数组件</code>虽然写法非常简洁轻便，但其限制是<strong>必须是纯函数，不能包含状态，也不支持生命周期</strong>，因此<code>类组件</code>并不能取代<code>函数组件</code>。</p> <p>而<code>React</code>团队觉得<strong>组件的最佳写法应该是函数，而不是类</strong>，由此产生了<code>React Hooks</code>。</p> <p><strong>React Hooks 的设计目的，就是加强版函数组件，完全不使用&quot;类&quot;，就能写出一个全功能的组件</strong>。</p> <p>为什么说<code>类组件</code>“笨重”，借用<code>React</code>官方的例子说明：</p> <div class="language- extra-class"><pre class="language-text"><code>import React, { Component } from &quot;react&quot;

export default class Button extends Component {
  constructor() {
    super()
    this.state = { buttonText: &quot;Click me, please&quot; }
    this.handleClick = this.handleClick.bind(this)
  }
  handleClick() {
    this.setState(() =&gt; {
      return { buttonText: &quot;Thanks, been clicked!&quot; }
    })
  }
  render() {
    const { buttonText } = this.state
    return &lt;button onClick={this.handleClick}&gt;{buttonText}&lt;/button&gt;
  }
}
</code></pre></div><p>以上是一个简单的按钮组件，包含最基础的状态和点击方法，点击按钮后状态发生改变。</p> <p>本是很简单的功能组件，但是却需要大量的代码去实现。由于<code>函数组件</code>不包含状态，所以我们并不能用<code>函数组件</code>来声明一个具备如上功能的组件。但是我们可以用<code>Hook</code>来实现：</p> <div class="language- extra-class"><pre class="language-text"><code>import React, { useState } from &quot;react&quot;

export default function Button() {
  const [buttonText, setButtonText] = useState(&quot;Click me,   please&quot;)

  function handleClick() {
    return setButtonText(&quot;Thanks, been clicked!&quot;)
  }

  return &lt;button onClick={handleClick}&gt;{buttonText}&lt;/button&gt;
}
</code></pre></div><p>相较而言，<code>Hook</code>显得更轻量，在贴近<code>函数组件</code>的同时，保留了自己的状态。</p> <p>在上述例子中引入了第一个钩子<code>useState()</code>，除此之外，<code>React</code>官方还提供了<code>useEffect()</code>、<code>useContext()</code>、<code>useReducer()</code>等钩子。具体钩子及其用法详情请见<strong>官方</strong>[3]。</p> <p><code>Hook</code>的灵活之处还在于，除了官方提供的基础钩子之外，我们还可以利用这些基础钩子来封装和自定义钩子，从而实现更容易的代码复用。</p> <h3 id="hook-优缺点"><a href="#hook-优缺点" class="header-anchor">#</a> Hook 优缺点</h3> <ul><li><p>优点</p></li> <li><ul><li>更容易复用代码；</li> <li>清爽的代码风格；</li> <li>代码量更少；</li></ul></li> <li><p>缺点</p></li> <li><ul><li>状态不同步（函数独立运行，每个函数都有一份独立的作用域）</li> <li>需要更合理的使用<code>useEffect</code></li> <li>颗粒度小，对于复杂逻辑需要抽象出很多<code>hook</code></li></ul></li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> <strong>总结</strong>**—**</h2> <p>除了<code>Mixin</code>因为自身的明显缺陷而稍显落后之外，对于<code>高阶组件</code>、<code>render props</code>、<code>react hook</code>而言，并没有哪种方式可称为<code>最佳方案</code>，它们都是优势与劣势并存的。哪怕是最为最热门的<code>react hook</code>，虽然每一个<code>hook</code>看起来都是那么的简短和清爽，但是在实际业务中，通常都是一个业务功能对应多个<code>hook</code>，这就意味着当业务改变时，需要去维护多个<code>hook</code>的变更，相对于维护一个<code>class</code>而言，心智负担或许要增加许多。只有切合自身业务的方式，才是<code>最佳方案</code>。</p> <hr> <p><strong>参考资料</strong></p> <p>[1]React Mixin 的使用: <em>https://segmentfault.com/a/1190000003016446</em>[2]Mixins Considered Harmful: <em>https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html</em>[3]官方: <em>https://zh-hans.reactjs.org/docs/hooks-reference.html</em>[4]React Mixin 的使用: <em>https://segmentfault.com/a/1190000003016446</em>[5]Mixins Considered Harmful: <em>https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html</em>[6]Higher-Order Components: <em>https://reactjs.org/docs/higher-order-components.html</em>[7]Render Props: <em>https://reactjs.org/docs/render-props.html</em>[8]React 拾遗：Render Props 及其使用场景: <em>https://www.imooc.com/article/39388</em>[9]Hook 简介: <em>https://zh-hans.reactjs.org/docs/hooks-state.html</em></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/8/2024, 3:01:19 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/base/Native/初次运行的问题.html" class="prev">
        Windows环境下运行react-native run-android相关问题
      </a></span> <span class="next"><a href="/base/React组件性能优化—function-component.html">
        React 组件性能优化—function component
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.27287fd6.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/53.09fd35d1.js" defer></script>
  </body>
</html>
