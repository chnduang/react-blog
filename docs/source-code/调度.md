# 基础

## React API

> 虽然平时我们都喜欢说我们用`React`作为我们的核心框架，但其实大部分人都不知道`React`到底是个什么东东。事实上自从Facebook把`React`和`ReactDOM`分包发布之后，`React`就不仅仅是一开始的前端框架了，如果在15版本之后去看一下`react`和`react-dom`的源码大小，你就会发现，`react`仅仅1000多行代码，而`react-dom`却将近2w行。是的你没看错，而且你很可能也没有想错，其实大部分的框架逻辑都在`react-dom`当中，那么`react`到底是个什么东东呢？

关于版本，本书是在React16+的基础上写的，React16相较于之前的版本是核心上的一次重写，虽然主要的API都没有变化，但是增加了很多能力。并且首次引入了`Fiber`的概念，之后新的功能都是围绕`Fiber`进行实现，比如`AsyncMode`，`Profiler`等。

这里并不会讲16版本之前的实现，一是面向未来，二是之前版本的源码我也没看过。

我们来看一下React暴露出来的API

```js
const React = {
  Children: {
    map,
    forEach,
    count,
    toArray,
    only,
  },

  createRef,
  Component,
  PureComponent,

  createContext,
  forwardRef,

  Fragment: REACT_FRAGMENT_TYPE,
  StrictMode: REACT_STRICT_MODE_TYPE,
  unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,
  unstable_Profiler: REACT_PROFILER_TYPE,

  createElement: __DEV__ ? createElementWithValidation : createElement,
  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,
  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,
  isValidElement: isValidElement,

  version: ReactVersion,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,
};
```

请先无视`__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED`

### Children

这个对象提供了一堆帮你处理`props.children`的方法，因为`children`是一个类似数组但是不是数组的数据结构，如果你要对其进行处理可以用`React.Children`外挂的方法。

### createRef

新的`ref`用法，React即将抛弃``这种`string ref`的用法，将来你只能使用两种方式来使用`ref`

```js
class App extends React.Component{

  constructor() {
    this.ref = React.createRef()
  }

  render() {
    return <div ref={this.ref} />
    // or
    return <div ref={(node) => this.funRef = node} />
  }

}
```

### Component & PureComponent

这两个类基本相同，唯一的区别是`PureComponent`的原型上多了一个标识

```js
if (ctor.prototype && ctor.prototype.isPureReactComponent) {
  return (
    !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
  );
}
```

这是检查组件是否需要更新的一个判断，`ctor`就是你声明的继承自`Component or PureComponent`的类，他会判断你是否继承自`PureComponent`，如果是的话就`shallowEqual`比较`state`和`props`。

顺便说一下：**React中对比一个ClassComponent是否需要更新，只有两个地方。一是看有没有`shouldComponentUpdate`方法，二就是这里的`PureComponent`判断**

### createContext

`createContext`是官方定稿的`context`方案，在这之前我们一直在用的老的`context API`都是React不推荐的API，现在新的API释出，官方也已经确定在17大版本会把老`API`去除。

新API的使用方法：

```js
const { Provider, Consumer } = React.createContext('defaultValue')

const ProviderComp = (props) => (
  <Provider value={'realValue'}>
    {props.children}
  </Provider>
)

const ConsumerComp = () => (
  <Consumer>
    {(value) => <p>{value}</p>}
  </Consumber>
)
```

后面讲`context`会专门比较新老的API的差异，提前说一句，老API的性能不是一般的差

### forwardRef

`forwardRef`是用来解决HOC组件传递`ref`的问题的，所谓HOC就是`Higher Order Component`，比如使用`redux`的时候，我们用`connect`来给组件绑定需要的state，这其中其实就是给我们的组件在外部包了一层组件，然后通过`...props`的方式把外部的`props`传入到实际组件。`forwardRef`的使用方法如下：

```js
const TargetComponent = React.forwardRef((props, ref) => (
  <TargetComponent ref={ref} />
))
```

这也是为什么要提供`createRef`作为新的`ref`使用方法的原因，如果用`string ref`就没法当作参数传递了。

这里只是简单说一下使用方法，后面讲`ref`的时候会详细分析。

### 类型

```js
Fragment: REACT_FRAGMENT_TYPE,
StrictMode: REACT_STRICT_MODE_TYPE,
unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,
unstable_Profiler: REACT_PROFILER_TYPE,
```

这四个都是React提供的*组件*，但他们呢其实都只是占位符，都是一个`Symbol`，在React实际检测到他们的时候会做一些特殊的处理，比如`StrictMode`和`AsyncMode`会让他们的子节点对应的Fiber的`mode`都变成和他们一样的`mode`

### createElement & cloneElement & createFactory & isValidElement

`createElement`可谓是React中最重要的API了，他是用来创建`ReactElement`的，但是很多同学却从没见过也没用过，这是为啥呢？因为你用了JSX，JSX并不是标准的js，所以要经过编译才能变成可运行的js，而编译之后，`createElement`就出现了：

```js
// jsx
<div id="app">content</div>

// js
React.createElement('div', { id: 'app' }, 'content')
```

`cloneElement`就很明显了，是用来克隆一个`ReactElement`的

`createFactory`是用来创建专门用来创建某一类`ReactElement`的工厂的，

```js
export function createFactory(type) {
  const factory = createElement.bind(null, type);
  factory.type = type;
  return factory;
}
```

他其实就是绑定了第一个参数的`createElement`，一般我们用JSX进行编程的时候不会用到这个API

`isValidElement`顾名思义就是用来验证是否是一个`ReactElement`的，基本也用不太到

## ReactElement

`ReactElement`通过`createElement`创建，调用该方法需要传入三个参数：

- type
- config
- children

`type`指代这个`ReactElement`的类型

- 字符串比如`div`，`p`代表原生DOM，称为`HostComponent`
- Class类型是我们继承自`Component`或者`PureComponent`的组件，称为`ClassComponent`
- 方法就是`functional Component`
- 原生提供的`Fragment`、`AsyncMode`等是Symbol，会被特殊处理
- TODO: 是否有其他的

从源码可以看出虽然创建的时候都是通过`config`传入的，但是`key`和`ref`不会跟其他`config`中的变量一起被处理，而是单独作为变量出现在`ReactElement`上。

在最后创建`ReactElement`我们看到了这么一个变量`$$typeof`，这是个啥呢，在这里可以看出来他是一个常量：`REACT_ELEMENT_TYPE`，但有一个特例：`ReactDOM.createPortal`的时候是`REACT_PORTAL_TYPE`，不过他不是通过`createElement`创建的，所以他应该也不属于`ReactElement`

```js
export function createElement(type, config, children) {
  // 处理参数

  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props,
  );
}

const ReactElement = function(type, key, ref, self, source, owner, props) {
  const element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner,
  };

  return element
}
```

`ReactElement`只是一个用来承载信息的容器，他会告诉后续的操作这个节点的以下信息：

1. `type`类型，用于判断如何创建节点
2. `key`和`ref`这些特殊信息
3. `props`新的属性内容
4. `$$typeof`用于确定是否属于`ReactElement`

这些信息对于后期构建应用的树结构是非常重要的，**而React通过提供这种类型的数据，来脱离平台的限制**

## React Children

> 最开始`React.Children`这个 API 是不想讲的，一方面平时不怎么用，另一方面跟数组处理功能差不多，不深究实现是比较容易理解的。但是后来实际去看了一下源码之后发现，他的实现方式还是非常有趣的，尤其是`map`和`forEach`，我们就按照`map`的流程来看一下，`forEach`其实差不多，只是没有返回新的节点。

先来看一下流程图：

![map流程](https://pozvqg.dm.files.1drv.com/y4mmeXuR-FkgNj-8c2xEInueibhFoYSEdG7un9nWggJFV1nYGsjb6S8m0D776nWAyuXHwKz1kCVMelh96STs4RYe9EVppRjlQyiu7jwrPqH9iM-cR4YPS7UbJkFTZHg62yMg6k8n_c-DMQOoEzZhvmCdR8LAEPFY4JQvypWYj3LF1EpeR5zp6OIfkPOk3qei4Qwz903Q9lxtWpavsva6TceyQ?width=768&height=1152&cropmode=none)

当然这么看肯定云里雾里，接下去会对各个函数进行讲解，然后再回过头来配合图片观看更好理解。

### 开始

```js
function mapChildren(children, func, context) {
  if (children == null) {
    return children
  }
  const result = []
  mapIntoWithKeyPrefixInternal(children, result, null, func, context)
  return result
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  let escapedPrefix = ''
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/'
  }
  const traverseContext = getPooledTraverseContext(
    array,
    escapedPrefix,
    func,
    context,
  )
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext)
  releaseTraverseContext(traverseContext)
}
```

`map`和`forEach`的最大区别就是有没有`return result`。

`getPooledTraverseContext`就是从`pool`里面找一个对象，`releaseTraverseContext`会把当前的`context`对象清空然后放回到`pool`中。

```js
const POOL_SIZE = 10
const traverseContextPool = []
function getPooledTraverseContext() {
  // args
  if (traverseContextPool.length) {
    const traverseContext = traverseContextPool.pop()
    // set attrs
    return traverseContext
  } else {
    return {
      /* attrs */
    }
  }
}

function releaseTraverseContext(traverseContext) {
  // clear attrs
  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext)
  }
}
```

那么按照这个流程来看，是不是`pool`永远都只有一个值呢，毕竟推出之后操作完了就推入了，这么循环着。答案肯定是否的，这就要讲到`React.Children.map`的一个特性了，那就是对每个节点的`map`返回的如果是数组，那么还会继续展开，这是一个递归的过程。接下去我们就来看看。

```js
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext)
}

function traverseAllChildrenImpl(
  children,
  nameSoFar,
  callback,
  traverseContext,
) {
  const type = typeof children

  if (type === 'undefined' || type === 'boolean') {
    children = null
  }

  let invokeCallback = false

  if (children === null) {
    invokeCallback = true
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true
        break
      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true
        }
    }
  }

  if (invokeCallback) {
    callback(
      traverseContext,
      children,
      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,
    )
    return 1
  }

  let child
  let nextName
  let subtreeCount = 0 // Count of children found in the current subtree.
  const nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR

  if (Array.isArray(children)) {
    for (let i = 0; i < children.length; i++) {
      child = children[i]
      nextName = nextNamePrefix + getComponentKey(child, i)
      subtreeCount += traverseAllChildrenImpl(
        child,
        nextName,
        callback,
        traverseContext,
      )
    }
  } else {
    const iteratorFn = getIteratorFn(children)
    if (typeof iteratorFn === 'function') {
      // iterator，和array差不多
    } else if (type === 'object') {
      // 提醒不正确的children类型
    }
  }

  return subtreeCount
}
```

这里就是一层递归了，对于可循环的`children`，都会重复调用`traverseAllChildrenImpl`，直到是一个节点的情况，然后调用`callback`，也就是`mapSingleChildIntoContext`

```js
function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  const { result, keyPrefix, func, context } = bookKeeping

  let mappedChild = func.call(context, child, bookKeeping.count++)
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c => c)
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(
        mappedChild,
        keyPrefix +
          (mappedChild.key && (!child || child.key !== mappedChild.key)
            ? escapeUserProvidedKey(mappedChild.key) + '/'
            : '') +
          childKey,
      )
    }
    result.push(mappedChild)
  }
}
```

`mapSingleChildIntoContext`这个方法其实就是调用`React.Children.map(children, callback)`这里的`callback`，就是我们传入的第二个参数，并得到`map`之后的结果。注意重点来了，**如果`map`之后的节点还是一个数组，那么再次进入`mapIntoWithKeyPrefixInternal`，那么这个时候我们就会再次从`pool`里面去`context`了，而`pool`的意义大概也就是在这里了，如果循环嵌套多了，可以减少很多对象创建和`gc`的损耗。**

而如果不是数组并且是一个合规的`ReactElement`，就触达顶点了，替换一下`key`就推入`result`了。

React 这么实现主要是两个目的：

1. 拆分`map`出来的数组
2. 因为对`Children`的处理一般在`render`里面，所以会比较频繁，所以设置一个`pool`减少声明和`gc`的开销

这就是`Children.map`的实现，虽然不算什么特别神奇的代码，但是阅读一下还是挺有意思的。

## React 中的数据结构

> 本文中使用 gist 进行展示，可能会被 Adblock 屏蔽，如果发现无法看到 gist 的内容请尝试刷新，如果还不行可以[反馈给我](mailto:jokcy@hotmail.com)

### FiberRoot

```js
type BaseFiberRootProperties = {|
  // root节点，render方法接收的第二个参数
  containerInfo: any,
  // 只有在持久更新中会用到，也就是不支持增量更新的平台，react-dom不会用到
  pendingChildren: any,
  // 当前应用对应的Fiber对象，是Root Fiber
  current: Fiber,

  // 一下的优先级是用来区分
  // 1) 没有提交(committed)的任务
  // 2) 没有提交的挂起任务
  // 3) 没有提交的可能被挂起的任务
  // 我们选择不追踪每个单独的阻塞登记，为了兼顾性能
  // The earliest and latest priority levels that are suspended from committing.
  // 最老和新的在提交的时候被挂起的任务
  earliestSuspendedTime: ExpirationTime,
  latestSuspendedTime: ExpirationTime,
  // The earliest and latest priority levels that are not known to be suspended.
  // 最老和最新的不确定是否会挂起的优先级（所有任务进来一开始都是这个状态）
  earliestPendingTime: ExpirationTime,
  latestPendingTime: ExpirationTime,
  // The latest priority level that was pinged by a resolved promise and can
  // be retried.
  // 最新的通过一个promise被reslove并且可以重新尝试的优先级
  latestPingedTime: ExpirationTime,

  // 如果有错误被抛出并且没有更多的更新存在，我们尝试在处理错误前同步重新从头渲染
  // 在`renderRoot`出现无法处理的错误时会被设置为`true`
  didError: boolean,

  // 正在等待提交的任务的`expirationTime`
  pendingCommitExpirationTime: ExpirationTime,
  // 已经完成的任务的FiberRoot对象，如果你只有一个Root，那他永远只可能是这个Root对应的Fiber，或者是null
  // 在commit阶段只会处理这个值对应的任务
  finishedWork: Fiber | null,
  // 在任务被挂起的时候通过setTimeout设置的返回内容，用来下一次如果有新的任务挂起时清理还没触发的timeout
  timeoutHandle: TimeoutHandle | NoTimeout,
  // 顶层context对象，只有主动调用`renderSubtreeIntoContainer`时才会有用
  context: Object | null,
  pendingContext: Object | null,
  // 用来确定第一次渲染的时候是否需要融合
  +hydrate: boolean,
  // 当前root上剩余的过期时间
  // TODO: 提到renderer里面区处理
  nextExpirationTimeToWorkOn: ExpirationTime,
  // 当前更新对应的过期时间
  expirationTime: ExpirationTime,
  // List of top-level batches. This list indicates whether a commit should be
  // deferred. Also contains completion callbacks.
  // TODO: Lift this into the renderer
  // 顶层批次（批处理任务？）这个变量指明一个commit是否应该被推迟
  // 同时包括完成之后的回调
  // 貌似用在测试的时候？
  firstBatch: Batch | null,
  // root之间关联的链表结构
  nextScheduledRoot: FiberRoot | null,
|};
```

### Fiber

```js
// Fiber对应一个组件需要被处理或者已经处理了，一个组件可以有一个或者多个Fiber
type Fiber = {|
  // 标记不同的组件类型
  tag: WorkTag,

  // ReactElement里面的key
  key: null | string,

  // ReactElement.type，也就是我们调用`createElement`的第一个参数
  elementType: any,

  // The resolved function/class/ associated with this fiber.
  // 异步组件resolved之后返回的内容，一般是`function`或者`class`
  type: any,

  // The local state associated with this fiber.
  // 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）
  stateNode: any,

  // 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回
  return: Fiber | null,

  // 单链表树结构
  // 指向自己的第一个子节点
  child: Fiber | null,
  // 指向自己的兄弟结构
  // 兄弟节点的return指向同一个父节点
  sibling: Fiber | null,
  index: number,

  // ref属性
  ref: null | (((handle: mixed) => void) & {_stringRef: ?string}) | RefObject,

  // 新的变动带来的新的props
  pendingProps: any, 
  // 上一次渲染完成之后的props
  memoizedProps: any,

  // 该Fiber对应的组件产生的Update会存放在这个队列里面
  updateQueue: UpdateQueue<any> | null,

  // 上一次渲染的时候的state
  memoizedState: any,

  // 一个列表，存放这个Fiber依赖的context
  firstContextDependency: ContextDependency<mixed> | null,

  // 用来描述当前Fiber和他子树的`Bitfield`
  // 共存的模式表示这个子树是否默认是异步渲染的
  // Fiber被创建的时候他会继承父Fiber
  // 其他的标识也可以在创建的时候被设置
  // 但是在创建之后不应该再被修改，特别是他的子Fiber创建之前
  mode: TypeOfMode,

  // Effect
  // 用来记录Side Effect
  effectTag: SideEffectTag,

  // 单链表用来快速查找下一个side effect
  nextEffect: Fiber | null,

  // 子树中第一个side effect
  firstEffect: Fiber | null,
  // 子树中最后一个side effect
  lastEffect: Fiber | null,

  // 代表任务在未来的哪个时间点应该被完成
  // 不包括他的子树产生的任务
  expirationTime: ExpirationTime,

  // 快速确定子树中是否有不在等待的变化
  childExpirationTime: ExpirationTime,

  // 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber
  // 我们称他为`current <==> workInProgress`
  // 在渲染完成之后他们会交换位置
  alternate: Fiber | null,

  // 下面是调试相关的，收集每个Fiber和子树渲染时间的

  actualDuration?: number,

  // If the Fiber is currently active in the "render" phase,
  // This marks the time at which the work began.
  // This field is only set when the enableProfilerTimer flag is enabled.
  actualStartTime?: number,

  // Duration of the most recent render time for this Fiber.
  // This value is not updated when we bailout for memoization purposes.
  // This field is only set when the enableProfilerTimer flag is enabled.
  selfBaseDuration?: number,

  // Sum of base times for all descedents of this Fiber.
  // This value bubbles up during the "complete" phase.
  // This field is only set when the enableProfilerTimer flag is enabled.
  treeBaseDuration?: number,

  // Conceptual aliases
  // workInProgress : Fiber ->  alternate The alternate used for reuse happens
  // to be the same as work in progress.
  // __DEV__ only
  _debugID?: number,
  _debugSource?: Source | null,
  _debugOwner?: Fiber | null,
  _debugIsCurrentlyTiming?: boolean,
|};
```

### effectTags

```js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */

export type SideEffectTag = number;

// Don't change these two values. They're used by React Dev Tools.
export const NoEffect = /*              */ 0b00000000000;
export const PerformedWork = /*         */ 0b00000000001;

// You can change the rest (and add more).
export const Placement = /*             */ 0b00000000010;
export const Update = /*                */ 0b00000000100;
export const PlacementAndUpdate = /*    */ 0b00000000110;
export const Deletion = /*              */ 0b00000001000;
export const ContentReset = /*          */ 0b00000010000;
export const Callback = /*              */ 0b00000100000;
export const DidCapture = /*            */ 0b00001000000;
export const Ref = /*                   */ 0b00010000000;
export const Snapshot = /*              */ 0b00100000000;

// Update & Callback & Ref & Snapshot
export const LifecycleEffectMask = /*   */ 0b00110100100;

// Union of all host effects
export const HostEffectMask = /*        */ 0b00111111111;

export const Incomplete = /*            */ 0b01000000000;
export const ShouldCapture = /*         */ 0b10000000000;
```

### ReactWorkTag

```js
export const FunctionComponent = 0;
export const ClassComponent = 1;
export const IndeterminateComponent = 2; // Before we know whether it is function or class
export const HostRoot = 3; // Root of a host tree. Could be nested inside another node.
export const HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
export const HostComponent = 5;
export const HostText = 6;
export const Fragment = 7;
export const Mode = 8;
export const ContextConsumer = 9;
export const ContextProvider = 10;
export const ForwardRef = 11;
export const Profiler = 12;
export const SuspenseComponent = 13;
export const MemoComponent = 14;
export const SimpleMemoComponent = 15;
export const LazyComponent = 16;
export const IncompleteClassComponent = 17;
```

### sideEffects

```js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */

export type SideEffectTag = number;

// Don't change these two values. They're used by React Dev Tools.
export const NoEffect = /*              */ 0b00000000000;
export const PerformedWork = /*         */ 0b00000000001;

// You can change the rest (and add more).
export const Placement = /*             */ 0b00000000010;
export const Update = /*                */ 0b00000000100;
export const PlacementAndUpdate = /*    */ 0b00000000110;
export const Deletion = /*              */ 0b00000001000;
export const ContentReset = /*          */ 0b00000010000;
export const Callback = /*              */ 0b00000100000;
export const DidCapture = /*            */ 0b00001000000;
export const Ref = /*                   */ 0b00010000000;
export const Snapshot = /*              */ 0b00100000000;

// Update & Callback & Ref & Snapshot
export const LifecycleEffectMask = /*   */ 0b00110100100;

// Union of all host effects
export const HostEffectMask = /*        */ 0b00111111111;

export const Incomplete = /*            */ 0b01000000000;
export const ShouldCapture = /*         */ 0b10000000000;
```

### Update & UpdateQueue

```js
export type Update<State> = {
  // 更新的过期时间
  expirationTime: ExpirationTime,

  // export const UpdateState = 0;
  // export const ReplaceState = 1;
  // export const ForceUpdate = 2;
  // export const CaptureUpdate = 3;
  // 指定更新的类型，值为以上几种
  tag: 0 | 1 | 2 | 3,
  // 更新内容，比如`setState`接收的第一个参数
  payload: any,
  // 对应的回调，`setState`，`render`都有
  callback: (() => mixed) | null,

  // 指向下一个更新
  next: Update<State> | null,
  // 指向下一个`side effect`
  nextEffect: Update<State> | null,
};

export type UpdateQueue<State> = {
  // 每次操作完更新之后的`state`
  baseState: State,

  // 队列中的第一个`Update`
  firstUpdate: Update<State> | null,
  // 队列中的最后一个`Update`
  lastUpdate: Update<State> | null,

  // 第一个捕获类型的`Update`
  firstCapturedUpdate: Update<State> | null,
  // 最后一个捕获类型的`Update`
  lastCapturedUpdate: Update<State> | null,

  // 第一个`side effect`
  firstEffect: Update<State> | null,
  // 最后一个`side effect`
  lastEffect: Update<State> | null,

  // 第一个和最后一个捕获产生的`side effect`
  firstCapturedEffect: Update<State> | null,
  lastCapturedEffect: Update<State> | null,
};
```

# 创建更新

## ReactDOM.render

### 开始

创建`ReactRoot`，并且根据情况调用`root.legacy_renderSubtreeIntoContainer`或者`root.render`，前者是遗留的 API 将来应该会删除，根据`ReactDOM.render`的调用情况也可以发现`parentComponent`是写死的`null`

`DOMRenderer.unbatchedUpdates`制定不使用`batchedUpdates`，因为这是初次渲染，需要尽快完成。

```js
ReactDOM = {
  render(
    element: React$Element<any>,
    container: DOMContainer,
    callback: ?Function,
  ) {
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      false,
      callback,
    )
  },
}

function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component<any, any>,
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?Function,
) {
  let root: Root = (container._reactRootContainer: any)
  if (!root) {
    // Initial mount
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    )
    if (typeof callback === 'function') {
      const originalCallback = callback
      callback = function() {
        const instance = DOMRenderer.getPublicRootInstance(root._internalRoot)
        originalCallback.call(instance)
      }
    }
    // Initial mount should not be batched.
    DOMRenderer.unbatchedUpdates(() => {
      if (parentComponent != null) {
        // 一般不会出现
      } else {
        root.render(children, callback)
      }
    })
  } else {
    // 有root的情况
  }
  return DOMRenderer.getPublicRootInstance(root._internalRoot)
}
```

首先会创建`ReactRoot`对象，然后调用他的`render`方法

创建`ReactRoot`的时候会调用`DOMRenderer.createContainer`创建`FiberRoot`，在后期调度更新的过程中这个节点非常重要

这两个数据结构看[这里](https://react.jokcy.me/book/api/react-structure.html)

```js
function legacyCreateRootFromDOMContainer(
  container: DOMContainer,
  forceHydrate: boolean,
): Root {
  const shouldHydrate =
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container)
  // First clear any existing content.
  if (!shouldHydrate) {
    let warned = false
    let rootSibling
    while ((rootSibling = container.lastChild)) {
      container.removeChild(rootSibling)
    }
  }
  // Legacy roots are not async by default.
  const isConcurrent = false
  return new ReactRoot(container, isConcurrent, shouldHydrate)
}

function ReactRoot(
  container: Container,
  isConcurrent: boolean,
  hydrate: boolean,
) {
  const root = DOMRenderer.createContainer(container, isConcurrent, hydrate)
  this._internalRoot = root
}

ReactRoot.prototype.render = function(
  children: ReactNodeList,
  callback: ?() => mixed,
): Work {
  const root = this._internalRoot
  const work = new ReactWork()
  callback = callback === undefined ? null : callback
  if (__DEV__) {
    warnOnInvalidCallback(callback, 'render')
  }
  if (callback !== null) {
    work.then(callback)
  }
  DOMRenderer.updateContainer(children, root, null, work._onCommit)
  return work
}
```

其中`DOMRenderer`是`react-reconciler/src/ReactFiberReconciler`，他的`updateContainer`如下在这里计算了一个时间，这个时间叫做`expirationTime`，顾名思义就是这次更新的 **超时时间**。

关于时间是如何计算的[看这里](https://react.jokcy.me/book/update/expiration-time.html)

然后调用了`updateContainerAtExpirationTime`，在这个方法里调用了`scheduleRootUpdate`就非常重要了

```js
export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): ExpirationTime {
  const current = container.current
  const currentTime = requestCurrentTime()
  const expirationTime = computeExpirationForFiber(currentTime, current)
  return updateContainerAtExpirationTime(
    element,
    container,
    parentComponent,
    expirationTime,
    callback,
  )
}

export function updateContainerAtExpirationTime(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  expirationTime: ExpirationTime,
  callback: ?Function,
) {
  // TODO: If this is a nested container, this won't be the root.
  const current = container.current
  const context = getContextForSubtree(parentComponent)
  if (container.context === null) {
    container.context = context
  } else {
    container.pendingContext = context
  }

  return scheduleRootUpdate(current, element, expirationTime, callback)
}
```

### 开始调度

首先要生成一个`update`，不管你是`setState`还是`ReactDOM.render`造成的 React 更新，都会生成一个叫`update`的对象，并且会赋值给`Fiber.updateQueue`

关于`update`请[看这里](https://react.jokcy.me/book/api/react-structure.html)

然后就是调用`scheduleWork`。注意到这里之前`setState`和`ReactDOM.render`是不一样，但进入`schedulerWork`之后，就是任务调度的事情了，跟之前你是怎么调用的没有任何关系

```js
function scheduleRootUpdate(
  current: Fiber,
  element: ReactNodeList,
  expirationTime: ExpirationTime,
  callback: ?Function,
) {
  const update = createUpdate(expirationTime)

  update.payload = { element }

  callback = callback === undefined ? null : callback
  if (callback !== null) {
    warningWithoutStack(
      typeof callback === 'function',
      'render(...): Expected the last optional `callback` argument to be a ' +
        'function. Instead received: %s.',
      callback,
    )
    update.callback = callback
  }
  enqueueUpdate(current, update)

  scheduleWork(current, expirationTime)
  return expirationTime
}
```

## setState

`setState`调用`updater.enqueueSetState`，我们先不管这个对象什么时候设置进来的，先来看一下代码

```
setState`和`forceUpdate`的代码我们可以看到，几乎是一模一样的。唯一的区别是`Update.tag
```

关于`Update`和`UpdateQueue`的数据结构可以看[这里](https://react.jokcy.me/book/api/react-structure.html)

在当前节点对应的`Fiber`对象上创建了`Update`之后，进就如`scheduleWork`调度阶段。

```js
const classComponentUpdater = {
  // isMounted
  enqueueSetState(inst, payload, callback) {
    const fiber = ReactInstanceMap.get(inst)
    const currentTime = requestCurrentTime()
    const expirationTime = computeExpirationForFiber(currentTime, fiber)

    const update = createUpdate(expirationTime)
    update.payload = payload
    if (callback !== undefined && callback !== null) {
      update.callback = callback
    }

    enqueueUpdate(fiber, update)
    scheduleWork(fiber, expirationTime)
  },
  // replaceState
  enqueueForceUpdate(inst, callback) {
    const fiber = ReactInstanceMap.get(inst)
    const currentTime = requestCurrentTime()
    const expirationTime = computeExpirationForFiber(currentTime, fiber)

    const update = createUpdate(expirationTime)
    update.tag = ForceUpdate

    if (callback !== undefined && callback !== null) {
      update.callback = callback
    }

    enqueueUpdate(fiber, update)
    scheduleWork(fiber, expirationTime)
  },
}
```

## expirationTime 公式

讲公式就有必要把代码亮出来了，毕竟代码量也不多

```js
const UNIT_SIZE = 10
const MAGIC_NUMBER_OFFSET = 2

export function msToExpirationTime(ms: number): ExpirationTime {
  return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET
}

export function expirationTimeToMs(expirationTime: ExpirationTime): number {
  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE
}

function ceiling(num: number, precision: number): number {
  return (((num / precision) | 0) + 1) * precision
}

function computeExpirationBucket(
  currentTime,
  expirationInMs,
  bucketSizeMs,
): ExpirationTime {
  return (
    MAGIC_NUMBER_OFFSET +
    ceiling(
      currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE,
      bucketSizeMs / UNIT_SIZE,
    )
  )
}

export const LOW_PRIORITY_EXPIRATION = 5000
export const LOW_PRIORITY_BATCH_SIZE = 250

export function computeAsyncExpiration(
  currentTime: ExpirationTime,
): ExpirationTime {
  return computeExpirationBucket(
    currentTime,
    LOW_PRIORITY_EXPIRATION,
    LOW_PRIORITY_BATCH_SIZE,
  )
}

export const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150
export const HIGH_PRIORITY_BATCH_SIZE = 100

export function computeInteractiveExpiration(currentTime: ExpirationTime) {
  return computeExpirationBucket(
    currentTime,
    HIGH_PRIORITY_EXPIRATION,
    HIGH_PRIORITY_BATCH_SIZE,
  )
}
```

React 中有两种类型的`ExpirationTime`，一个是`Interactive`的，另一种是普通的异步。`Interactive`的比如说是由事件触发的，那么他的响应优先级会比较高因为涉及到交互。

在整个计算公式中只有`currentTime`是变量，也就是当前的时间戳。我们拿`computeAsyncExpiration`举例，在`computeExpirationBucket`中接收的就是`currentTime`、`5000`和`250`

最终的公式就是酱紫的：`((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25`

其中`25`是`250 / 10`，`| 0`的作用是取整数

翻译一下就是：**当前时间加上`498`然后处以`25`取整再加`1`再乘以 5，需要注意的是这里的`currentTime`是经过`msToExpirationTime`处理的，也就是`((now / 10) | 0) + 2`，所以这里的减去`2`可以无视，而除以 10 取整应该是要抹平 10 毫秒内的误差，当然最终要用来计算时间差的时候会调用`expirationTimeToMs`恢复回去，但是被取整去掉的 10 毫秒误差肯定是回不去的。**

现在应该很明白了吧？再解释一下吧：简单来说在这里，最终结果是以`25`为单位向上增加的，比如说我们输入`10002 - 10026`之间，最终得到的结果都是`10525`，但是到了`10027`的到的结果就是`10550`，这就是除以`25`取整的效果。

另外一个要提的就是`msToExpirationTime`和`expirationTimeToMs`方法，他们是想换转换的关系。**有一点非常重要，那就是用来计算`expirationTime`的`currentTime`是通过`msToExpirationTime(now)`得到的，也就是预先处理过的，先处以`10`再加了`2`，所以后面计算`expirationTime`要减去`2`也就不奇怪了**

### 小结一下

React 这么设计抹相当于抹平了`25ms`内计算过期时间的误差，那他为什么要这么做呢？我思考了很久都没有得到答案，直到有一天我盯着代码发呆，看到`LOW_PRIORITY_BATCH_SIZE`这个字样，`bacth`，是不是就对应`batchedUpdates`？再细想了一下，这么做也许是为了让非常相近的两次更新得到相同的`expirationTime`，然后在一次更新中完成，相当于一个自动的`batchedUpdates`。

不禁感叹，真的是细啊！

以上就是`expirationTime`的计算方法。

### currentTime

```js
function requestCurrentTime() {
  if (isRendering) {
    return currentSchedulerTime
  }
  findHighestPriorityRoot()
  if (
    nextFlushedExpirationTime === NoWork ||
    nextFlushedExpirationTime === Never
  ) {
    recomputeCurrentRendererTime()
    currentSchedulerTime = currentRendererTime
    return currentSchedulerTime
  }
  return currentSchedulerTime
}
```

在 React 中我们计算`expirationTime`要基于当前得*时钟时间*，一般来说我们只需要获取`Date.now`或者`performance.now`就可以了，但是每次获取一下呢比较消耗性能，所以呢 React 设置了`currentRendererTime`来记录这个值，用于一些不需要重新计算得场景。

但是在 React 中呢又提供了`currentSchedulerTime`这个变量，同样也是记录这个值的，那么为什么要用两个值呢？我们看一下`requestCurrentTime`方法的实现。

#### 首先是:

```js
if (isRendering) {
  return currentSchedulerTime
}
```

这个`isRendering`只有在`performWorkOnRoot`的时候才会被设置为`true`，而其本身是一个同步的方法，不存在他执行到一半没有设置`isRendering`为`false`的时候就跳出，那么什么情况下会在这里出现新的`requestCurrentTime`呢？

- 在生命周期方法中调用了`setState`
- 需要挂起任务的时候

也就是说 React 要求**在一次`rendering`过程中，新产生的`update`用于计算过期时间的`current`必须跟目前的`renderTime`保持一致，同理在这个周期中所有产生的新的更新的过期时间都会保持一致！**

#### 然后第二个判断：

```js
if (
  nextFlushedExpirationTime === NoWork ||
  nextFlushedExpirationTime === Never
)
```

也就是说在一个`batched`更新中，只有第一次创建更新才会重新计算时间，后面的所有更新都会复用第一次创建更新的时候的时间，这个也是为了**保证在一个批量更新中产生的同类型的更新只会有相同的过期时间**

### 各种不同的 expirationTime

在 React 的调度过程中存在着非常多不同的*`expirationTime`*变量帮助 React 去实现在单线程环境中调度不同优先级的任务这个需求，这篇文章我们就来一一列举他们的含义以及作用，来帮助我们更好得理解 React 中的整个调度过程。

- `root.expirationTime`
- `root.nextExpirationTimeToWorkOn`
- `root.childExpirationTime`
- `root.earliestPendingTime & root.lastestPendingTime`
- `root.earliestSuspendedTime & root.lastestSuspendedTime`
- `root.lastestPingedTime`
- `nextFlushedExpirationTime`
- `nextLatestAbsoluteTimeoutMs`
- `currentRendererTime`
- `currentSchedulerTime`

另外，所有节点都会具有`expirationTime`和`childExpirationTime`两个属性

以上所有值初始都是`NoWork`也就是`0`，以及他们一共会有三种情况：

- `NoWork`，代表没有更新
- `Sync`，代表同步执行，不会被调度也不会被打断
- `async`模式下计算出来的过期时间，一个时间戳

接下去的例子我们都会根据下面的例子结构来讲，我们假设有如下结构的一个 React 节点树，他的`Fiber`结构如下：

![基础结构](https://kgfacq.dm.files.1drv.com/y4mdey9O6FJ59ftJnhP1ej6YNMd0z1HWSQsmF42mJjlUiM8fVYKjcyV-0AlUvMdE5SpBHkRl7Wn_WcqaBlhtY-ifm4GLrc_whI9LlUsJyeKOdbmcwCdlqByqYRkCdbjm-6I8d0MuICm3TeAxxyttW3SNKRLWYPeinkDSrH31VLXI4I5M9IJ60x8d6RR1OtOcctUwRNExxMvS6yFQVUEuBulKA?width=721&height=471&cropmode=none)

后续我们会在这个基础上讲解不同情况下`expirationTime`的情况

#### childExpirationTime

在之前我们说过，每次一个节点调用`setState`或者`forceUpdate`都会产生一个更新并且计算一个`expirationTime`，那么这个节点的`expirationTime`就是当时计算出来的值，**因为这个更新本身就是由这个节点产生的**

最终因为 React 的更新需要从`FiberRoot`开始，所以会执行一次向上遍历找到`FiberRoot`，而向上遍历则正好是一步步找到**创建更新的节点的父节点**的过程，这时候 React 就会对每一个该节点的父节点链上的节点设置`childExpirationTime`，因为这个更新是他们的子孙节点造成的

![img](https://h2facq.dm.files.1drv.com/y4mphJBnkRInXVdei2q3h0etKGLWTB5irIH2w23DMcoAKRIl0K7EJPFHjykQ5enpm5lgi_Jp9qTPhBTM64CQF2J_6wxtL1j2raUeLNUm7zXZzclXJQ6iPXjw75oGcdUMdsYCKNm2YawmEsJy2joPddhFLBN4PK51oGM16974Ad3A7azsRa0NunaDYNB1Lvhb3ZMrwKrx-3Yvi90e4vW3A02Iw?width=841&height=571&cropmode=none)

如上图所示，我们先忽略最左边的`child1`产生的一次异步更新，如果当前只有`child2`产生了一个`Sync`更新，那么`App`和`FiberRoot`的`childExpirationTime`都会更新成`Sync`

那么这个值有什么用呢？在我们向下更新整棵`Fiber`树的时候，每个节点都会执行对应的`update`方法，在这个方法里面就会使用节点本身的`expirationTime`和`childExpirationTime`来判断他是否可以直接跳过，不更新子树。**`expirationTime`代表他本身是否有更新，如果他本身有更新，那么他的更新可能会影响子树；`childExpirationTime`表示他的子树是否产生了更新；如果两个都没有，那么子树是不需要更新的。**

对应图中，如果`child1`，`child3`，`child4`还有子树，那么在这次`child2`的更新中，他们是不需要重新渲染的，在遍历到他们的时候，会直接跳过

*注意：这里只讨论没有其他副作用的情况，比如使用老的`context api`之类的最终会强制导致没有更新的组件重新渲染的情况我们先不考虑。*

了解了`childExpirationTime`的作用之后，我们再来讲一下他的特性：

- 同一个节点产生的连续两次更新，最红在父节点上只会体现一次`childExpirationTime`
- 不同子树产生的更新，最终体现在跟节点上的是优先级最高的那个更新

第一点很好理解，同一个节点在第一次更新还没有结束的情况下再次产生更新，那么不管他们优先级哪个高，最终都会按照高优先级那个过期时间把所有更新都更新掉了，因为`Fiber`对象只有一个，`updateQueue`也只有一个，无法区分同一个对象上连续的不同更新。

第二点是因为 React 在创建更新向上寻找`root`并设置`childExpirationTime`的时候，会对比之前设置过的和现在的，最终会等于**非`NoWork`的最小的`childExpirationTime`，因为`expirationTime`越小优先级越高，`Sync`是最高优先级**

对应到上面的例子中，`child1`产生的更新是异步的，所以他的`expirationTime`是计算出来的时间戳，那么肯定比`Sync`大，所以率先记录到父节点的是`child2`，同时也是`child2`的更新先被执行。**即便是`child1`的更新先产生，如果他在`chidl2`产生更新的时候他还没更新完，那么也会被打断，先完成`child2`的渲染，再回头来渲染`child1`**

以上是`childExpirationTime`的作用和特性，他在每个节点`completeWork`的时候会`reset`父链上的`childExpirationTime`，也就是说这个节点已经更新完了，那么他的`childExpirationTime`也就没有意义了。那么这个我们在讲[节点更新](https://react.jokcy.me/book/update/expiration-time.html)的时候会讲到，到时候大家再对应起来看效果会更好。

#### pendingTime

在`FiberRoot`上有两个值`earliestPendingTime`和`lastestPedingTime`，他们是一对值，**用来记录所有子树中需要进行渲染的更新的`expirationTime`的区间**

![pendingTime demo](https://hmfacq.dm.files.1drv.com/y4mTm9k8wciS1LTgRpOidtojQQIgCWVhDtXluYnvYIqbK0Z6NUXFqzm76SlooXVfTHb9sAU2pE7du3AbbR23JlZU0vJ1FghvT6X5HXcoguLi4Mp4PdE25AGFt_1w2NJ1K7o3UiqV3mH-kWnlEuWd5xPlkueCdm2FfYDWvCT40ynsrbziTCoE7QMxIbpHyAg6fYkKPHh0qRDY5vrK8ssy8jzuQ?width=841&height=586&cropmode=none)

在这个例子里，我们同时在`child1`、`child2`、`child3`产生里更新，并且根据优先级计算出了不同的更新时间（**再次重申，请忽略细节，现实中不太会出现同时产生的情况**）。

每个更新创建的时候，React 会通过`markPendingPriorityLevel`标记`root`节点的`earliestPendingTime`和`lastestPedingTime`。他们只记录区间，也就是说现在我们产生了三个不同的过期时间，但是这里只记录最大和最小的。

那么他的作用就很明显了，**通过追踪最大和最小值，React 可以判断在当前更新之后是否还具有优先级更低的任务需要执行（当前过期时间处理这两个值之间）。**

#### suspendedTime

同样的在`ReactFiber`上有两个值`earliestSuspendedTime`和`lastestSuspendedTime`，**这两个值是用来记录被挂起的任务的过期时间的**

首先我们定义一下什么情况下任务是被挂起的：

- 出现可捕获的错误并且还有优先级更低的任务的情况下
- 当捕获到`thenable`，并且需要设置`onTimeout`的时候

我们称这个任务被`suspended`(挂起)了。记录这个时间主要是在`resolve`了`promise`之后，判断被挂起的组件更新是否依然处于目前已有的`suspenedTime`中间，如果不是的话是需要重新计算一个新的过期时间，然后从新加入队列进行调度更新的。

另外就是在确定目前需要执行的任务的过期时间，也就是`root.expirationTime`和`root.nextExpirationTimeToWorkOn`的时候也是一个考虑因素。我们接下去会讲到

#### lastestPingedTime

这个值是用来记录最新的一次`suspended`组件`resolve`之后，如果挂起之前的`expirationTime`依然在`earliestSuspendedTime`和`lastestSuspendedTime`之间，则会标志这个时间为`pingedTime`

`pingedTime`目前看来没有什么别的作用，唯一跟`suspendedTime`的区别是他的优先级比`suspendedTime`高一些，会优先选择为渲染目标。

#### root.expirationTime 和 root.nextExpirationTimeToWorkOn

`root.expirationTime`是用来标志当前渲染的过期时间的，请注意他只管本渲染周期，他并不管你现在的渲染目标是哪个，渲染目标是由`root.nextExpirationTimeToWorkOn`来决定的。

那么他们有什么区别呢？主要区别在于发挥作用的阶段

`expirationTime`作用于调度阶段，主要指责是：

- 决定是异步执行渲染还是同步执行渲染
- 作为`react-scheduler`的`timeout`标准，决定是否要优先渲染

`nextExpirationTimeToWorkOn`主要作用于渲染阶段：

- 决定那些更新要在当前周期中被执行
- 通过跟每个节点的`expirationTime`比较决定该节点是否可以直接`bailout`（跳过）

他们都是通过`pendingTime`、`suspenededTime`和`pingedTime`中删选出来的，唯一的不同是，`nextExpirationTimeToWorkOn`在没有`pending`或者`pinged`的任务的时候会选择最晚的`suspendedTime`，而`expirationTime`会选择最早的

`expirationTime`的变化：

- 在`scheduleWork`的时候通过`markPendingExpirationTime`设置
- 在`beginWork`的时候被设置为`NoWork`
- 在`onUncaughtError`的时候设置为`NoWork`
- `onSuspend`的时候又会设置回当次更新的`expirationTime`

**这里的不同选择我到目前也没有非常清晰的理解，尝试跟\*dan\*沟通了解没得到什么反馈，跟\*司徒正美\*大大聊起过，他觉得这部分功能目前其实还不是特别稳定，有些代码还是比较临时性的，所以现在可以不必要太深究，所以目前来说大家只要知道代码逻辑就可以**

展示一下代码：

```js
function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
  const earliestSuspendedTime = root.earliestSuspendedTime
  const latestSuspendedTime = root.latestSuspendedTime
  const earliestPendingTime = root.earliestPendingTime
  const latestPingedTime = root.latestPingedTime

  let nextExpirationTimeToWorkOn =
    earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime

  if (
    nextExpirationTimeToWorkOn === NoWork &&
    (completedExpirationTime === NoWork ||
      latestSuspendedTime > completedExpirationTime)
  ) {
    nextExpirationTimeToWorkOn = latestSuspendedTime
  }

  let expirationTime = nextExpirationTimeToWorkOn
  if (
    expirationTime !== NoWork &&
    earliestSuspendedTime !== NoWork &&
    earliestSuspendedTime < expirationTime
  ) {
    expirationTime = earliestSuspendedTime
  }

  root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn
  root.expirationTime = expirationTime
}
```

每次开始调度任务，或者设置`pendingTime`、`suspendedTime`、`pingedTime`都会调用这个方法重新删选接下去执行的任务。

需要注意一点，并不是所有情况都是从这个方法删选出这两个值的，比如在`renderRoot`出现错误捕获，并且没有更低优先级的任务的时候，强制以同步的方式把当前`expirationTime`的任务再重新执行了一遍

```js
root.didError = true
const suspendedExpirationTime = (root.nextExpirationTimeToWorkOn = expirationTime)
const rootExpirationTime = (root.expirationTime = Sync)
// 什么事情都不做，回到主线程
onSuspend(
  root,
  rootWorkInProgress,
  suspendedExpirationTime,
  rootExpirationTime,
  -1, // Indicates no timeout
)
return
```

这里直接把`root.expirationTime`设置为`Sync`，然后直接`return`，这样回到`performWork`的时候调用`findHighestPriorityRoot`会直接设置当前`root`为下一个渲染的目标，然后再次进行渲染。`performWork`的循环我们在[`fiber-scheduler`](https://react.jokcy.me/book/update/expiration-time.html)中有详细讲解

#### nextFlushedExpirationTime

这个是在`fiber-scheduler`中的一个全局变量，用来记录下一个需要渲染的`FiberRoot`的过期时间。注意他删选的时候整个应用中所有`FiberRoot`的优先级（是的，你没看错，应该 React 应用是可以有多个`FiberRoot`，比如你执行两次`ReactDOM.render`），并不关心每个`FiberRoot`子树的优先级。

他是在`findHighestPriorityRoot`中被赋值的，会遍历`firstScheduleRoot -> lastScheduledRoot`链表中所有`root`，并找到优先级最高（也就是`expirationTime`最小）的那个`root`进行赋值，并安排渲染

#### nextLatestAbsoluteTimeoutMs

他的作用是在`Suspense`组件捕获到挂起之后，增加一个`timeout`来强制重新渲染一次的，不过目前看不出这个`timeout`有什么用

这个跟`Suspense`组件的`maxDuration`有关，但是官方没公布用法，从源码中也看不出有什么用处，原以为是**多少毫秒内不显示`fallback`的内容**，结果测试了一下发现没用。等有空再研究一下，或者等官方正式发布吧，*毕竟现在就算研究出来了，可能分分钟就被改了，16.5 的时候还叫`delayMs`，16.6 就改成`maxDuration`了*。

#### currentSchedulerTime & currentRendererTime

这两个时间是用来是用来记录当前时间的，在**计算过期时间**和**比较任务是否过期**的时候都会用到`currentRendererTime`，`currentSchedulerTime`大部分时候都是等于`currentRendererTime`的，那为什么要设置两个时间呢？

这就是因为`batchedUpdates`了，在这种情况下如果同时创建了多个更新是会为每次更新计算过期时间的，而计算是要花时间的，如果每次都是请求当前时间，那么同一个`batch`中的不同更新得到的过期时间就会是不一样的，所以在一个`batch`中获取的当前时间应该是一样的，所以就设置了这么一个值，在我们请求当前时间的方法中有这么一段代码：

```js
findHighestPriorityRoot()
if (
  nextFlushedExpirationTime === NoWork ||
  nextFlushedExpirationTime === Never
) {
  recomputeCurrentRendererTime()
  currentSchedulerTime = currentRendererTime
  return currentSchedulerTime
}
```

`findHighestPriorityRoot`会设置`nextFlushedExpirationTime`，也就是只有在当前没有等待中的更新的情况下，才会重新计算当前时间。

# 任务调度

## 全局变量

### 在 FiberScheduler 中的全局变量

```js
// Used to ensure computeUniqueAsyncExpiration is monotonically increasing.
let lastUniqueAsyncExpiration: number = 0

// Represents the expiration time that incoming updates should use. (If this
// is NoWork, use the default strategy: async updates in async mode, sync
// updates in sync mode.)
let expirationContext: ExpirationTime = NoWork

let isWorking: boolean = false

// The next work in progress fiber that we're currently working on.
let nextUnitOfWork: Fiber | null = null
let nextRoot: FiberRoot | null = null
// The time at which we're currently rendering work.
let nextRenderExpirationTime: ExpirationTime = NoWork
let nextLatestAbsoluteTimeoutMs: number = -1
let nextRenderDidError: boolean = false

// The next fiber with an effect that we're currently committing.
let nextEffect: Fiber | null = null

let isCommitting: boolean = false

let legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null

// Used for performance tracking.
let interruptedBy: Fiber | null = null
```

#### lastUniqueAsyncExpiration

在`createBatch`中有调用，但是没发现`createBatch`在哪里被调用，所以，目前没发现什么作用。

```js
function computeUniqueAsyncExpiration(): ExpirationTime {
  const currentTime = requestCurrentTime()
  let result = computeAsyncExpiration(currentTime)
  if (result <= lastUniqueAsyncExpiration) {
    result = lastUniqueAsyncExpiration + 1
  }
  lastUniqueAsyncExpiration = result
  return lastUniqueAsyncExpiration
}
```

#### expirationContext

保存创建`expirationTime`的上下文，在`syncUpdates`和`deferredUpdates`中分别被设置为`Sync`和`AsyncExpirationTime`，在有这个上下文的时候任何更新计算出来的过期时间都等于`expirationContext`。

比如调用`ReactDOM.flushSync`的时候，他接受的回调中的`setState`

#### isWorking

```
commitRoot`和`renderRoot`开始都会设置为`true`，然后在他们各自阶段结束的时候都重置为`false
```

**用来标志是否当前有更新正在进行，不区分阶段**

#### isCommitting

```
commitRoot`开头设置为`true`，结束之后设置为`false
```

**用来标志是否处于`commit`阶段**

#### nextUnitOfWork

用于记录`render`阶段`Fiber`树遍历过程中下一个需要执行的节点。

在`resetStack`中分别被重置

他只会指向`workInProgress`

#### nextRoot & nextRenderExpirationTime

用于记录**下一个将要渲染的`root`节点**和**下一个要渲染的任务的**

在`renderRoot`开始的时候赋值，需要符合如下条件才会重新赋值

```js
if (
  expirationTime !== nextRenderExpirationTime ||
  root !== nextRoot ||
  nextUnitOfWork === null
) {
  resetStack()
  nextRoot = root
  nextRenderExpirationTime = expirationTime
  nextUnitOfWork = createWorkInProgress(
    nextRoot.current,
    null,
    nextRenderExpirationTime,
  )
}
```

解释一下就是说，只有这一次调用`renderRoot`的时候，有

- 新的`root`要渲染
- 相同的`root`但是任务有不同优先级的任务要渲染
- 或者在老的任务上没有下一个节点需要渲染了

#### nextLatestAbsoluteTimeoutMs

用来记录`Suspense`组件何时重新尝试渲染，涉及复杂的公式，这里就不详细说了。

可以看[`renderRoot`](https://react.jokcy.me/book/flow/render-root.html)

#### nextRenderDidError

用于记录当前`render`流程是否有错误产生

```
resetStack`重置为`false
```

在`throwException`中如果发现了不能直接处理的错误（除了 Promise 之外），那么就调用`renderDidError`设置为`true`

#### nextEffect

用于`commit`阶段记录`firstEffect -> lastEffect`链遍历过程中的每一个`Fiber`

#### interruptedBy

给开发工具用的，用来展示被哪个节点打断了异步任务

### 跟调度有关的全局变量

> ReactFiberScheduler.js 1797-1826

```js
// Linked-list of roots
let firstScheduledRoot: FiberRoot | null = null
let lastScheduledRoot: FiberRoot | null = null

let callbackExpirationTime: ExpirationTime = NoWork
let callbackID: *
let isRendering: boolean = false
let nextFlushedRoot: FiberRoot | null = null
let nextFlushedExpirationTime: ExpirationTime = NoWork
let lowestPriorityPendingInteractiveExpirationTime: ExpirationTime = NoWork
let deadlineDidExpire: boolean = false
let hasUnhandledError: boolean = false
let unhandledError: mixed | null = null
let deadline: Deadline | null = null

let isBatchingUpdates: boolean = false
let isUnbatchingUpdates: boolean = false
let isBatchingInteractiveUpdates: boolean = false

let completedBatches: Array<Batch> | null = null

let originalStartTimeMs: number = now()
let currentRendererTime: ExpirationTime = msToExpirationTime(
  originalStartTimeMs,
)
let currentSchedulerTime: ExpirationTime = currentRendererTime

// Use these to prevent an infinite loop of nested updates
const NESTED_UPDATE_LIMIT = 50
let nestedUpdateCount: number = 0
let lastCommittedRootDuringThisBatch: FiberRoot | null = null
```

#### firstScheduledRoot & lastScheduledRoot

用于存放有任务的所有`root`的单列表结构

- 在`findHighestPriorityRoot`用来检索优先级最高的`root`
- 在`addRootToSchedule`中会修改

在`findHighestPriorityRoot`中会判断`root`的`expirationTime`，并不会直接删除`root`

#### callbackExpirationTime & callbackID

记录请求`ReactScheduler`的时候用的过期时间，如果在一次调度期间有新的调度请求进来了，而且优先级更高，那么需要取消上一次请求，如果更低则无需再次请求调度。

`callbackID`是`ReactScheduler`返回的用于取消调度的 ID

#### isRendering

`performWorkOnRoot`开始设置为`true`，结束的时候设置为`false`，表示进入渲染阶段，这是包含`render`和`commit`阶段的。

#### nextFlushedRoot & nextFlushedExpirationTime

用来标志下一个需要渲染的`root`和对应的`expirtaionTime`，注意：

- 通过`findHighestPriorityRoot`找到最高优先级的
- 通过`flushRoot`会直接设置指定的，不进行筛选

#### lowestPriorityPendingInteractiveExpirationTime

类似`expirationContext`，用来存储`interactiveUpdates`产生的最小的`expirationTime`，在下一次外部指定的`interactiveUpdates`情况下会强制输出上一次的`interactiveUpdates`，**因为`interactiveUpdates`主要是用户输入之类的操作，如果不及时输出会给用户造成断层感**

可以通过调用`ReactDOM.unstable_interactiveUpdates`来实现以上目的

#### deadline & deadlineDidExpire

`deadline`是`ReactScheduler`中返回的时间片调度信息对象

用于记录是否时间片调度是否过期，在`shouldYield`根据`deadline`是否过期来设置

#### hasUnhandledError & unhandledError

`Profiler`调试相关

#### isBatchingUpdates & isUnbatchingUpdates & isBatchingInteractiveUpdates

`batchedUpdates`、`unBatchedUpdates`，`deferredUpdates`、`interactiveUpdates`等这些方法用来存储更新产生的上下文的变量

#### originalStartTimeMs

固定值，js 加载完一开始计算的结果

#### currentRendererTime & currentSchedulerTime

计算从页面加载到现在为止的毫秒数，后者会在`isRendering === true`的时候用作固定值返回，不然每次`requestCurrentTime`都会重新计算新的时间。

#### nestedUpdateCount & lastCommittedRootDuringThisBatch

用来记录是否有嵌套得再生命周期方法中产生更新导致应用无限循环更新得计数器，用于提醒用户书写的不正确的代码。

## scheduleWork

这里先`scheduleWorkToRoot`，这一步非常重要，他主要做了一下几个任务

- 找到当前`Fiber`的 root
- 给更新节点的父节点链上的每个节点的`expirationTime`设置为这个`update`的`expirationTime`，除非他本身时间要小于`expirationTime`
- 给更新节点的父节点链上的每个节点的`childExpirationTime`设置为这个`update`的`expirationTime`，除非他本身时间要小于`expirationTime`

最终返回 root 节点的`Fiber`对象

然后进入一个判断：

```js
if (
  !isWorking &&
  nextRenderExpirationTime !== NoWork &&
  expirationTime < nextRenderExpirationTime
)
```

我们来解释一下这几个变量的意思

1. `isWorking`代表是否正在工作，在开始`renderRoot`和`commitRoot`的时候会设置为 true，也就是在`render`和`commit`两个阶段都会为`true`
2. `nextRenderExpirationTime`在是新的`renderRoot`的时候会被设置为当前任务的`expirationTime`，而且一旦他被，只有当下次任务是`NoWork`的时候他才会被再次设置为`NoWork`，当然最开始也是`NoWork`

那么这个条件就很明显了：**目前没有任何任务在执行，并且之前有执行过任务，同时当前的任务比之前执行的任务过期时间要早（也就是优先级要高）**

那么这种情况会出现在什么时候呢？答案就是：**上一个任务是异步任务（优先级很低，超时时间是 502ms），并且在上一个时间片（初始是 33ms）任务没有执行完，而且等待下一次`requestIdleCallback`的时候新的任务进来了，并且超时时间很短（52ms 或者 22ms 甚至是 Sync），那么优先级就变成了先执行当前任务，也就意味着上一个任务被打断了（interrupted）**

被打断的任务会从当前节点开始往上推出`context`，因为在 React 只有一个`stack`，而下一个任务会从头开始的，所以在开始之前需要清空之前任务的的`stack`。

[`context`请看这里](https://react.jokcy.me/book/flow/context.md)

[`unwindWork`请看这里](https://react.jokcy.me/book/flow/unwindWork.md)

然后重置所有的公共变量：

```js
nextRoot = null
nextRenderExpirationTime = NoWork
nextLatestAbsoluteTimeoutMs = -1
nextRenderDidError = false
nextUnitOfWork = null
```

##### markPendingPriorityLevel

这个方法会记录当前的`expirationTime`到`pendingTime`，让`expirationTime`处于`earliestPendingTime`和`latestPendingTime`之间

并且会设置`root.nextExpirationTimeToWorkOn`和`root.expirationTime = expirationTime`分别是：

- 最早的`pendingTime`或者`pingedTime`，如果都没有则是`lastestSuspendTime`
- `suspendedTime`和`nextExpirationTimeToWorkOn`中较早的一个

##### 调用 requestWork

```js
if (
  !isWorking ||
  isCommitting ||
  nextRoot !== root
)
```

这个判断条件就比较简单了，`!isWorking || isCommitting`简单来说就是要么处于没有 work 的状态，要么只能在 render 阶段，不能处于 commit 阶段（比较好奇什么时候会在 commit 阶段有新的任务进来，commit 都是同步的无法打断）。还有一个选项`nextRoot !== root`，这个的意思就是你的 APP 如果有两个不同的 root，这时候也符合条件。

在符合条件之后就`requestWork`了

```js
function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) {
  const root = scheduleWorkToRoot(fiber, expirationTime)

  if (enableSchedulerTracing) {
    storeInteractionsForExpirationTime(root, expirationTime, true)
  }

  if (
    !isWorking &&
    nextRenderExpirationTime !== NoWork &&
    expirationTime < nextRenderExpirationTime
  ) {
    // This is an interruption. (Used for performance tracking.)
    interruptedBy = fiber
    resetStack()
  }
  markPendingPriorityLevel(root, expirationTime)
  if (
    // If we're in the render phase, we don't need to schedule this root
    // for an update, because we'll do it before we exit...
    !isWorking ||
    isCommitting ||
    // ...unless this is a different root than the one we're rendering.
    nextRoot !== root
  ) {
    const rootExpirationTime = root.expirationTime
    requestWork(root, rootExpirationTime)
  }
}

function scheduleWorkToRoot(fiber: Fiber, expirationTime): FiberRoot | null {
  // Update the source fiber's expiration time
  if (
    fiber.expirationTime === NoWork ||
    fiber.expirationTime > expirationTime
  ) {
    fiber.expirationTime = expirationTime
  }
  let alternate = fiber.alternate
  if (
    alternate !== null &&
    (alternate.expirationTime === NoWork ||
      alternate.expirationTime > expirationTime)
  ) {
    alternate.expirationTime = expirationTime
  }
  // Walk the parent path to the root and update the child expiration time.
  let node = fiber.return
  if (node === null && fiber.tag === HostRoot) {
    return fiber.stateNode
  }
  while (node !== null) {
    alternate = node.alternate
    if (
      node.childExpirationTime === NoWork ||
      node.childExpirationTime > expirationTime
    ) {
      node.childExpirationTime = expirationTime
      if (
        alternate !== null &&
        (alternate.childExpirationTime === NoWork ||
          alternate.childExpirationTime > expirationTime)
      ) {
        alternate.childExpirationTime = expirationTime
      }
    } else if (
      alternate !== null &&
      (alternate.childExpirationTime === NoWork ||
        alternate.childExpirationTime > expirationTime)
    ) {
      alternate.childExpirationTime = expirationTime
    }
    if (node.return === null && node.tag === HostRoot) {
      return node.stateNode
    }
    node = node.return
  }
  return null
}

function resetStack() {
  if (nextUnitOfWork !== null) {
    let interruptedWork = nextUnitOfWork.return
    while (interruptedWork !== null) {
      unwindInterruptedWork(interruptedWork)
      interruptedWork = interruptedWork.return
    }
  }

  nextRoot = null
  nextRenderExpirationTime = NoWork
  nextLatestAbsoluteTimeoutMs = -1
  nextRenderDidError = false
  nextUnitOfWork = null
}
```

### requestWork

`addRootToSchedule`把 root 加入到调度队列，但是要注意一点，不会存在两个相同的 root 前后出现在队列中

可以看出来，如果第一次调用`addRootToSchedule`的时候，`nextScheduledRoot`是`null`，这时候公共变量`firstScheduledRoot`和`lastScheduledRoot`也是`null`，所以会把他们都赋值成`root`，同时`root.nextScheduledRoot = root`。然后第二次进来的时候，如果前后`root`是同一个，那么之前的`firstScheduledRoot`和`lastScheduledRoot`都是 root，所以`lastScheduledRoot.nextScheduledRoot = root`就等于`root.nextScheduledRoot = root`

这么做是因为同一个`root`不需要存在两个，因为前一次调度如果中途被打断，下一次调度进入还是从同一个`root`开始，就会把新的任务一起执行了。

之后根据`expirationTime`调用`performSyncWork`还是`scheduleCallbackWithExpirationTime`

`scheduleCallbackWithExpirationTime`是根据时间片来执行任务的，会涉及到`requestIdleCallback`，详细解析看[这里](https://react.jokcy.me/book/flow/react-scheduler.md)

`isBatchingUpdates`和`isUnbatchingUpdates`涉及到事件系统，看[React 事件系统](https://react.jokcy.me/book/event-system/README.md)

他们最终都要调用`performWork`

```js
function requestWork(root: FiberRoot, expirationTime: ExpirationTime) {
  addRootToSchedule(root, expirationTime)
  if (isRendering) {
    // Prevent reentrancy. Remaining work will be scheduled at the end of
    // the currently rendering batch.
    return
  }

  if (isBatchingUpdates) {
    // Flush work at the end of the batch.
    if (isUnbatchingUpdates) {
      nextFlushedRoot = root
      nextFlushedExpirationTime = Sync
      performWorkOnRoot(root, Sync, true)
    }
    return
  }

  if (expirationTime === Sync) {
    performSyncWork()
  } else {
    scheduleCallbackWithExpirationTime(root, expirationTime)
  }
}

function addRootToSchedule(root: FiberRoot, expirationTime: ExpirationTime) {
  // Add the root to the schedule.
  // Check if this root is already part of the schedule.
  if (root.nextScheduledRoot === null) {
    // This root is not already scheduled. Add it.
    root.expirationTime = expirationTime
    if (lastScheduledRoot === null) {
      firstScheduledRoot = lastScheduledRoot = root
      root.nextScheduledRoot = root
    } else {
      lastScheduledRoot.nextScheduledRoot = root
      lastScheduledRoot = root
      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot
    }
  } else {
    // This root is already scheduled, but its priority may have increased.
    const remainingExpirationTime = root.expirationTime
    if (
      remainingExpirationTime === NoWork ||
      expirationTime < remainingExpirationTime
    ) {
      // Update the priority.
      root.expirationTime = expirationTime
    }
  }
}
```

关于`scheduleCallbackWithExpirationTime`的看[这里](https://react.jokcy.me/book/flow/scheduler-pkg.html)

接下去就进入了[`performWork`阶段](https://react.jokcy.me/book/flow/perform-work.html)

## scheduler

> React16.5 之后把`scheduler`单独发一个包了，就叫`scheduler`

### scheduleCallbackWithExpirationTime

异步进行`root`任务调度就是通过这个方法来做的，这里最主要的就是调用了`scheduler`的`scheduleDeferredCallback`方法（在`scheduler`包中是`scheduleWork`）

传入的的是回调函数`performAsyncWork`，以及一个包含`timeout`超时事件的对象

```js
function scheduleCallbackWithExpirationTime(
  root: FiberRoot,
  expirationTime: ExpirationTime,
) {
  if (callbackExpirationTime !== NoWork) {
    // A callback is already scheduled. Check its expiration time (timeout).
    if (expirationTime > callbackExpirationTime) {
      // Existing callback has sufficient timeout. Exit.
      return
    } else {
      if (callbackID !== null) {
        // Existing callback has insufficient timeout. Cancel and schedule a
        // new one.
        cancelDeferredCallback(callbackID)
      }
    }
    // The request callback timer is already running. Don't start a new one.
  } else {
    startRequestCallbackTimer()
  }

  callbackExpirationTime = expirationTime
  const currentMs = now() - originalStartTimeMs
  const expirationTimeMs = expirationTimeToMs(expirationTime)
  const timeout = expirationTimeMs - currentMs
  callbackID = scheduleDeferredCallback(performAsyncWork, { timeout })
}
```

### scheduler.scheduleWork

创建一个调度节点`newNode`，并按照`timoutAt`的顺序加入到`CallbackNode`链表，调用`ensureHostCallbackIsScheduled`

这里面的`expirationTime`是调用时传入的`timeoutAt`加上当前时间形成的过期时间。

```js
function unstable_scheduleCallback(callback, deprecated_options) {
  var startTime =
    currentEventStartTime !== -1 ? currentEventStartTime : getCurrentTime()

  var expirationTime
  if (
    typeof deprecated_options === 'object' &&
    deprecated_options !== null &&
    typeof deprecated_options.timeout === 'number'
  ) {
    // FIXME: Remove this branch once we lift expiration times out of React.
    expirationTime = startTime + deprecated_options.timeout
  } else {
    // 这里是以后把`expirationTime`从React中抽离出来之后的逻辑
  }

  var newNode = {
    callback,
    priorityLevel: currentPriorityLevel,
    expirationTime,
    next: null,
    previous: null,
  }

  // Insert the new callback into the list, ordered first by expiration, then
  // by insertion. So the new callback is inserted any other callback with
  // equal expiration.
  if (firstCallbackNode === null) {
    // This is the first callback in the list.
    firstCallbackNode = newNode.next = newNode.previous = newNode
    ensureHostCallbackIsScheduled()
  } else {
    var next = null
    var node = firstCallbackNode
    do {
      if (node.expirationTime > expirationTime) {
        // The new callback expires before this one.
        next = node
        break
      }
      node = node.next
    } while (node !== firstCallbackNode)

    if (next === null) {
      // No callback with a later expiration was found, which means the new
      // callback has the latest expiration in the list.
      next = firstCallbackNode
    } else if (next === firstCallbackNode) {
      // The new callback has the earliest expiration in the entire list.
      firstCallbackNode = newNode
      ensureHostCallbackIsScheduled()
    }

    var previous = next.previous
    previous.next = next.previous = newNode
    newNode.next = next
    newNode.previous = previous
  }

  return newNode
}
```

### ensureHostCallbackIsScheduled

如果已经在调用回调了，就 return，因为本来就会继续调用下去，`isExecutingCallback`在`flushWork`的时候会被修改为`true`

如果`isHostCallbackScheduled`为`false`，也就是还没开始调度，那么设为`true`，如果已经开始了，就直接取消，因为顺序可能变了。

调用`requestHostCallback`开始调度

这里

```js
function ensureHostCallbackIsScheduled() {
  if (isExecutingCallback) {
    // Don't schedule work yet; wait until the next time we yield.
    return
  }
  // Schedule the host callback using the earliest expiration in the list.
  var expirationTime = firstCallbackNode.expirationTime
  if (!isHostCallbackScheduled) {
    isHostCallbackScheduled = true
  } else {
    // Cancel the existing host callback.
    cancelHostCallback()
  }
  requestHostCallback(flushWork, expirationTime)
}

cancelHostCallback = function() {
  scheduledHostCallback = null
  isMessageEventScheduled = false
  timeoutTime = -1
}
```

### requestHostCallback

开始进入调度，设置调度的内容，用`scheduledHostCallback`和`timeoutTime`这两个全局变量记录回调函数和对应的过期时间

调用`requestAnimationFrameWithTimeout`，其实就是调用`requestAnimationFrame`在加上设置了一个`100ms`的定时器，防止`requestAnimationFrame`太久不触发。

调用回调`animtionTick`并设置`isAnimationFrameScheduled`全局变量为`true`

```js
requestHostCallback = function(callback, absoluteTimeout) {
  scheduledHostCallback = callback
  timeoutTime = absoluteTimeout
  if (isFlushingHostCallback || absoluteTimeout < 0) {
    // Don't wait for the next frame. Continue working ASAP, in a new event.
    window.postMessage(messageKey, '*')
  } else if (!isAnimationFrameScheduled) {
    isAnimationFrameScheduled = true
    requestAnimationFrameWithTimeout(animationTick)
  }
}
```

### 模拟 requestIdleCallback

因为`requestIdleCallback`这个 API 目前还处于草案阶段，所以浏览器实现率还不高，所以在这里 React 直接使用了`polyfill`的方案。

这个方案简单来说是通过`requestAnimationFrame`在浏览器渲染一帧之前做一些处理，然后通过`postMessage`在`macro task`（类似 setTimeout）中加入一个回调，在因为接下去会进入浏览器渲染阶段，所以主线程是被 block 住的，等到渲染完了然后回来清空`macro task`。

总体上跟`requestIdleCallback`差不多，**等到主线程有空的时候回来调用**

### animationTick

只要`scheduledHostCallback`还在就继续调要`requestAnimationFrameWithTimeout`因为这一帧渲染完了可能队列还没情况，本身也是要进入再次调用的，这边就省去了`requestHostCallback`在次调用的必要性

接下去一段代码是用来计算相隔的`requestAnimationFrame`的时差的，这个时差如果连续两次都小鱼当前的`activeFrameTime`，说明平台的帧率是很高的，这种情况下会动态得缩小帧时间。

最后更新`frameDeadline`，然后如果没有触发`idleTick`则发送消息

```js
var animationTick = function(rafTime) {
  if (scheduledHostCallback !== null) {
    requestAnimationFrameWithTimeout(animationTick)
  } else {
    isAnimationFrameScheduled = false
    return
  }

  var nextFrameTime = rafTime - frameDeadline + activeFrameTime
  if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
    if (nextFrameTime < 8) {
      nextFrameTime = 8
    }
    activeFrameTime =
      nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime
  } else {
    previousFrameTime = nextFrameTime
  }
  frameDeadline = rafTime + activeFrameTime
  if (!isMessageEventScheduled) {
    isMessageEventScheduled = true
    window.postMessage(messageKey, '*')
  }
}
```

### idleTick

首先判断`postMessage`是不是自己的，不是直接返回

清空`scheduledHostCallback`和`timeoutTime`

获取当前时间，对比`frameDeadline`，查看是否已经超时了，如果超时了，判断一下任务`callback`的过期时间有没有到，如果没有到，则重新对这个`callback`进行一次调度，然后返回。如果到了，则设置`didTimeout`为`true`

接下去就是调用`callback`了，这里设置`isFlushingHostCallback`全局变量为`true`代表正在执行。并且调用`callback`也就是`flushWork`并传入`didTimeout`

```js
var idleTick = function(event) {
  if (event.source !== window || event.data !== messageKey) {
    return
  }

  isMessageEventScheduled = false

  var prevScheduledCallback = scheduledHostCallback
  var prevTimeoutTime = timeoutTime
  scheduledHostCallback = null
  timeoutTime = -1

  var currentTime = getCurrentTime()

  var didTimeout = false
  if (frameDeadline - currentTime <= 0) {
    if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {
      didTimeout = true
    } else {
      if (!isAnimationFrameScheduled) {
        isAnimationFrameScheduled = true
        requestAnimationFrameWithTimeout(animationTick)
      }
      scheduledHostCallback = prevScheduledCallback
      timeoutTime = prevTimeoutTime
      return
    }
  }

  if (prevScheduledCallback !== null) {
    isFlushingHostCallback = true
    try {
      prevScheduledCallback(didTimeout)
    } finally {
      isFlushingHostCallback = false
    }
  }
}
```

### flushWork

先设置`isExecutingCallback`为`true`，代表正在调用`callback`

设置`deadlineObject.didTimeout`，在 React 业务中可以用来判断任务是否超时

如果`didTimeout`，会一次从`firstCallbackNode`向后一直执行，知道第一个没过期的任务

如果没有超时，则依此执行第一个`callback`，知道帧时间结束为止

最后清理变量，如果任务没有执行完，则再次调用`ensureHostCallbackIsScheduled`进入调度

顺便把`Immedia`优先级的任务都调用一遍。

```js
function flushWork(didTimeout) {
  isExecutingCallback = true
  deadlineObject.didTimeout = didTimeout
  try {
    if (didTimeout) {
      while (firstCallbackNode !== null) {
        var currentTime = getCurrentTime()
        if (firstCallbackNode.expirationTime <= currentTime) {
          do {
            flushFirstCallback()
          } while (
            firstCallbackNode !== null &&
            firstCallbackNode.expirationTime <= currentTime
          )
          continue
        }
        break
      }
    } else {
      if (firstCallbackNode !== null) {
        do {
          flushFirstCallback()
        } while (
          firstCallbackNode !== null &&
          getFrameDeadline() - getCurrentTime() > 0
        )
      }
    }
  } finally {
    isExecutingCallback = false
    if (firstCallbackNode !== null) {
      ensureHostCallbackIsScheduled()
    } else {
      isHostCallbackScheduled = false
    }
    flushImmediateWork()
  }
}
```

### flushFirstCallback

代码太长不放了，他做的事情很简单

- 如果当前队列中只有一个回调，清空队列
- 调用回调并传入`deadline`对象，里面有`timeRemaining`方法通过`frameDeadline - now()`来判断是否帧时间已经到了
- 如果回调有返回内容，把这个返回加入到回调队列

### 全局变量参考

#### isHostCallbackScheduled

是否已经开始调度了，在`ensureHostCallbackIsScheduled`设置为`true`，在结束执行`callback`之后设置为`false`

#### scheduledHostCallback

在`requestHostCallback`设置，值一般为`flushWork`，代表下一个调度要做的事情

#### isMessageEventScheduled

是否已经发送调用`idleTick`的消息，在`animationTick`中设置为`true`

#### timeoutTime

表示过期任务的时间，在`idleTick`中发现第一个任务的时间已经过期的时候设置

#### isAnimationFrameScheduled

是否已经开始调用`requestAnimationFrame`

#### activeFrameTime

给一帧渲染用的时间，默认是 33，也就是 1 秒 30 帧

#### frameDeadline

记录当前帧的到期时间，他等于`currentTime + activeFraeTime`，也就是`requestAnimationFrame`回调传入的时间，加上一帧的时间。

#### isFlushingHostCallback

是否正在执行`callback`





[JavaScript](https://react.jokcy.me/book/flow/perform-work.html#)

## performWork

`performWork`通过两种方式调用

##### performAsyncWork 异步方式

异步情况给`performWork`设置的`minExpirationTime`是`NoWork`，并且会判断`dl.didTimeout`，这个值是指任务的`expirationTime`是否已经超时，如果超时了，则直接设置`newExpirationTimeToWorkOn`为当前时间，表示这个任务直接执行就行了，不需要判断是否超过了帧时间

##### performSyncWork 同步方式

同步方式久比较简单了，设置`minExpirationTime`为`Sync`也就是`1`

##### 具体 performWork

首先要通过`findHighestPriorityRoot`找到下一个需要操作的`root`，会设置两个全局变量

这里判断是否有`deadline`来分成两种渲染方式，但最大的差距其实是`while`循环的判断条件，有`deadline`的多了一个条件`(!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime)`

我们先来看相同的部分

```js
nextFlushedRoot !== null &&
  nextFlushedExpirationTime !== NoWork &&
  (minExpirationTime === NoWork ||
    minExpirationTime >= nextFlushedExpirationTime)
```

下一个输出节点不是`null`，并且过期时间不是`NoWork`，同时*超时时间是`NoWork`，或者超时时间大于下个节点的超时时间*，一般来说`minExpirationTime`应该就等于`nextFlushedExpirationTime`因为他们来自同一个 root，`nextFlushedExpirationTime`是在`findHighestPriorityRoot`阶段读取出来的`root.expirationTime`

在非异步的情况下，接下去就是循环执行`performWorkOnRoot`然后再找下一个优先级的`root`执行

而在异步的情况下多了一个判断`(!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime)`，什么意思呢？`deadlineDidExpire`是用来判断时间片是否到期的，也就是`deadline`中设置的，而第二个条件是*当前渲染时间是否大于`nextFlushedExpirationTime`*，也就是判断任务是否已经超时了了，如果超时了，根据下面调用`performWorkOnRoot`的参数中有一个`currentRendererTime >= nextFlushedExpirationTime`，也就是这种情况下为`true`，代表的意思是同步执行任务不再判断是否时间片到期。

##### 收尾

最后如果跳出循环，有两种可能，一是任务已经完成，一是时间片用完了并且任务没过期。对于第二种情况会重新发起一次异步调度，等`requestIdleCallback`有空了再回来继续执行。

```js
function performAsyncWork(dl) {
  if (dl.didTimeout) {
    if (firstScheduledRoot !== null) {
      recomputeCurrentRendererTime()
      let root: FiberRoot = firstScheduledRoot
      do {
        didExpireAtExpirationTime(root, currentRendererTime)
        // The root schedule is circular, so this is never null.
        root = (root.nextScheduledRoot: any)
      } while (root !== firstScheduledRoot)
    }
  }
  performWork(NoWork, dl)
}

function performSyncWork() {
  performWork(Sync, null)
}

function performWork(minExpirationTime: ExpirationTime, dl: Deadline | null) {
  deadline = dl

  // Keep working on roots until there's no more work, or until we reach
  // the deadline.
  findHighestPriorityRoot()

  if (deadline !== null) {
    recomputeCurrentRendererTime()
    currentSchedulerTime = currentRendererTime

    if (enableUserTimingAPI) {
      const didExpire = nextFlushedExpirationTime < currentRendererTime
      const timeout = expirationTimeToMs(nextFlushedExpirationTime)
      stopRequestCallbackTimer(didExpire, timeout)
    }

    while (
      nextFlushedRoot !== null &&
      nextFlushedExpirationTime !== NoWork &&
      (minExpirationTime === NoWork ||
        minExpirationTime >= nextFlushedExpirationTime) &&
      (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime)
    ) {
      performWorkOnRoot(
        nextFlushedRoot,
        nextFlushedExpirationTime,
        currentRendererTime >= nextFlushedExpirationTime,
      )
      findHighestPriorityRoot()
      recomputeCurrentRendererTime()
      currentSchedulerTime = currentRendererTime
    }
  } else {
    while (
      nextFlushedRoot !== null &&
      nextFlushedExpirationTime !== NoWork &&
      (minExpirationTime === NoWork ||
        minExpirationTime >= nextFlushedExpirationTime)
    ) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true)
      findHighestPriorityRoot()
    }
  }

  // We're done flushing work. Either we ran out of time in this callback,
  // or there's no more work left with sufficient priority.

  // If we're inside a callback, set this to false since we just completed it.
  if (deadline !== null) {
    callbackExpirationTime = NoWork
    callbackID = null
  }
  // If there's work left over, schedule a new callback.
  if (nextFlushedExpirationTime !== NoWork) {
    scheduleCallbackWithExpirationTime(
      ((nextFlushedRoot: any): FiberRoot),
      nextFlushedExpirationTime,
    )
  }

  // Clean-up.
  deadline = null
  deadlineDidExpire = false

  finishRendering()
}
```

### performWorkOnRoot

这里也分为同步和异步两种情况，但是这两种情况的区别其实非常小。

首先是一个参数的区别，`isYieldy`在同步的情况下是`false`，而在异步情况下是`true`。这个参数顾名思义就是*是否可以中断*，那么这个区别也就很好理解了。

第二个区别就是在`renderRoot`之后判断一下`shouldYeild`，如果时间片已经用完，则不直接`completeRoot`，而是等到一下次`requestIdleCallback`之后再执行。

`renderRoot`和`completeRoot`分别对应两个阶段：

- 渲染阶段
- 提交阶段

渲染阶段可以被打断，而提交阶段不能

```js
function performWorkOnRoot(
  root: FiberRoot,
  expirationTime: ExpirationTime,
  isExpired: boolean,
) {
  isRendering = true

  if (deadline === null || isExpired) {
    let finishedWork = root.finishedWork
    if (finishedWork !== null) {
      // This root is already complete. We can commit it.
      completeRoot(root, finishedWork, expirationTime)
    } else {
      root.finishedWork = null
      const timeoutHandle = root.timeoutHandle
      if (enableSuspense && timeoutHandle !== noTimeout) {
        root.timeoutHandle = noTimeout
        cancelTimeout(timeoutHandle)
      }
      const isYieldy = false
      renderRoot(root, isYieldy, isExpired)
      finishedWork = root.finishedWork
      if (finishedWork !== null) {
        // We've completed the root. Commit it.
        completeRoot(root, finishedWork, expirationTime)
      }
    }
  } else {
    // Flush async work.
    let finishedWork = root.finishedWork
    if (finishedWork !== null) {
      // This root is already complete. We can commit it.
      completeRoot(root, finishedWork, expirationTime)
    } else {
      root.finishedWork = null
      // If this root previously suspended, clear its existing timeout, since
      // we're about to try rendering again.
      const timeoutHandle = root.timeoutHandle
      if (enableSuspense && timeoutHandle !== noTimeout) {
        root.timeoutHandle = noTimeout
        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
        cancelTimeout(timeoutHandle)
      }
      const isYieldy = true
      renderRoot(root, isYieldy, isExpired)
      finishedWork = root.finishedWork
      if (finishedWork !== null) {
        if (!shouldYield()) {
          // Still time left. Commit the root.
          completeRoot(root, finishedWork, expirationTime)
        } else {
          root.finishedWork = finishedWork
        }
      }
    }
  }

  isRendering = false
}
```

### findHighestPriorityRoot

一般情况下我们的 React 应用只会有一个`root`，所以这里的大部分逻辑其实都不是常见情况

循环`firstScheduledRoot => lastScheduledRoot`，`remainingExpirationTime`是`root.expirationTime`，也就是最早的过期时间。

如果他是`NoWork`说明他已经没有任务了，从链表中删除。

从剩下的中找到`expirationTime`最小的也就是优先级最高的`root`然后把他赋值给`nextFlushedRoot`并把他的`expirationTime`赋值给`nextFlushedExpirationTime`这两个公共变量。

一般来说会直接执行下面这个逻辑

```js
if (root === root.nextScheduledRoot) {
  // This is the only root in the list.
  root.nextScheduledRoot = null;
  firstScheduledRoot = lastScheduledRoot = null;
  break;
}
function findHighestPriorityRoot() {
  let highestPriorityWork = NoWork
  let highestPriorityRoot = null
  if (lastScheduledRoot !== null) {
    let previousScheduledRoot = lastScheduledRoot
    let root = firstScheduledRoot
    while (root !== null) {
      const remainingExpirationTime = root.expirationTime
      if (remainingExpirationTime === NoWork) {
        // This root no longer has work. Remove it from the scheduler.

        // TODO: This check is redudant, but Flow is confused by the branch
        // below where we set lastScheduledRoot to null, even though we break
        // from the loop right after.
        invariant(
          previousScheduledRoot !== null && lastScheduledRoot !== null,
          'Should have a previous and last root. This error is likely ' +
            'caused by a bug in React. Please file an issue.',
        )
        if (root === root.nextScheduledRoot) {
          // This is the only root in the list.
          root.nextScheduledRoot = null
          firstScheduledRoot = lastScheduledRoot = null
          break
        } else if (root === firstScheduledRoot) {
          // This is the first root in the list.
          const next = root.nextScheduledRoot
          firstScheduledRoot = next
          lastScheduledRoot.nextScheduledRoot = next
          root.nextScheduledRoot = null
        } else if (root === lastScheduledRoot) {
          // This is the last root in the list.
          lastScheduledRoot = previousScheduledRoot
          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot
          root.nextScheduledRoot = null
          break
        } else {
          previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot
          root.nextScheduledRoot = null
        }
        root = previousScheduledRoot.nextScheduledRoot
      } else {
        if (
          highestPriorityWork === NoWork ||
          remainingExpirationTime < highestPriorityWork
        ) {
          // Update the priority, if it's higher
          highestPriorityWork = remainingExpirationTime
          highestPriorityRoot = root
        }
        if (root === lastScheduledRoot) {
          break
        }
        if (highestPriorityWork === Sync) {
          // Sync is highest priority by definition so
          // we can stop searching.
          break
        }
        previousScheduledRoot = root
        root = root.nextScheduledRoot
      }
    }
  }

  nextFlushedRoot = highestPriorityRoot
  nextFlushedExpirationTime = highestPriorityWork
}
```

